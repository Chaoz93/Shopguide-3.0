<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Shopguide V3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Tailwind for easy styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- GridStack styles and scripts -->
  <link href="https://cdn.jsdelivr.net/npm/gridstack@9.2.2/dist/gridstack.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/gridstack@9.2.2/dist/gridstack-all.js"></script>
  <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
  <script src="https://code.jquery.com/ui/1.14.1/jquery-ui.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>

  <link rel="stylesheet" href="https://code.jquery.com/ui/1.14.1/themes/base/jquery-ui.css">
  <style>
    :root {
      /* General colours */
      --app-bg: #f3f4f6;
      --sidebar-bg: #f3f4f6;
      --sidebar-text: #1f2937;
      --top-bar-bg: #ffffff;
      --button-bg: #2563eb;
      --button-text: #ffffff;
      --border-color: #e5e7eb;
      /* Module colours */
      --module-bg: #005983;
      --text-color: #ffffff;
      --module-border-radius: 1.25rem;
      --module-header-bg: rgba(255,255,255,0.08);
      --module-header-text: #ffffff;
      /* Module border */
      --module-border-color: #e5e7eb;
      --danger-bg: #ef4444;
      --danger-text: #ffffff;
      /* Tabs colours */
      --tab-active-bg: #2563eb;
      --tab-active-text: #ffffff;
      --tab-inactive-bg: #e5e7eb;
      --tab-inactive-text: #1f2937;
      /* Grid hint */
      --grid-hint: #60a5fa;

      /* Sidebar module card colours */
      --sidebar-module-card-bg: #ffffff;
      --sidebar-module-card-text: #1f2937;
      --sidebar-module-card-border: #e5e7eb;

      /* Attachment text colour for module cards */
      --sidebar-module-card-attachment-color: #6B7280;

      /* Body text colour (used for general text; separate from sidebar text) */
      --body-text: #1f2937;
    }

    html, body { height: 100%; }
    body { margin: 0; background: var(--app-bg); color: var(--body-text); }
    /* module contents */
    .grid-stack-item-content {
      background: var(--module-bg);
      border-radius: var(--module-border-radius);
      color: var(--text-color);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      min-height: 10px;
      /* apply border using module border colour */
      border: 1px solid var(--module-border-color);
    }
    .drag-handle {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:.5rem;
      cursor: move;
      background: var(--module-header-bg);
      color: var(--module-header-text);
      border-radius: calc(var(--module-border-radius) - 0.25rem);
      padding: .25rem .5rem;
    }
    .module-card.dragging { opacity: 0.5; }
    .grid-drop-hint { outline: 2px dashed var(--grid-hint); outline-offset: -6px; }
    .module-card {
      -webkit-user-drag: element;
      user-select: none;
      /* use CSS variables for sidebar module appearance */
      background-color: var(--sidebar-module-card-bg);
      color: var(--sidebar-module-card-text);
      border: 1px solid var(--sidebar-module-card-border);
    }
    /* Sidebar collapsed state */
    #sidebar.collapsed { width: 2.5rem !important; min-width: 2.5rem !important; padding-left: 0; padding-right: 0; }
    #sidebar.collapsed .list-content { display: none; }
    #sidebar.collapsed .collapse-icon { transform: rotate(180deg); }
    #sidebar.collapsed .module-card { pointer-events: none; }
    #sidebar.collapsed #module-list { pointer-events: none; }
    /* Topbar, sidebar and buttons use variables */
    #top-bar { background-color: var(--top-bar-bg) !important; border-bottom: 1px solid var(--border-color) !important; }
    #sidebar { background-color: var(--sidebar-bg) !important; border-right: 1px solid var(--border-color) !important; color: var(--sidebar-text); overflow-y: auto; }
    #select-root { background-color: var(--button-bg) !important; color: var(--button-text) !important; }
    button.remove { background-color: var(--danger-bg) !important; color: var(--danger-text) !important; }
    /* Tabs */
    .tab-item { user-select: none; }
    .tab-active { background: var(--tab-active-bg); color: var(--tab-active-text); }
    .tab-inactive { background: var(--tab-inactive-bg); color: var(--tab-inactive-text); }
    /* Settings Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 50;
    }
    .modal {
      background: white;
      border-radius: 0.75rem;
      padding: 1rem;
      width: 95%;
      max-width: 720px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);

      /* Ensure modal text colour does not inherit sidebar text colour */
      color: var(--body-text);
    }
    .settings-nav button {
      border-radius: .5rem;
      padding: .5rem .75rem;
    }
    .settings-nav button.active { background: #e5e7eb; }
    .settings-section { display: none; }
    .settings-section.active { display: block; }
    .field-grid {
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: .75rem;
    }
    @media (max-width: 640px){ .field-grid { grid-template-columns: 1fr; } }
    .form-field label { font-size:.875rem; font-weight:600; }

    /* Simple fade-in animation for startup and loading */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .fade-in {
      animation: fadeIn 0.5s ease-out;
    }

    /* Attachment text style in sidebar module cards */
    #module-list .sidebar-module-attachment {
      color: var(--sidebar-module-card-attachment-color);
      font-size: 0.75rem;
    }

    /* Ensure module names in the sidebar wrap rather than truncate */
    #module-list .module-card .font-semibold {
      word-break: break-word;
      white-space: normal;
    }
    .gs-remove {
      position: absolute;
      top: .35rem;
      right: .35rem;
    }
  </style>
  <style id="custom-styles"></style>
</head>
<body>
  <!-- Top bar with tabs and buttons -->
  <header id="top-bar" class="flex items-center gap-1 px-3 py-2 shadow" style="height:40px">
    <div id="tabs-container" class="flex items-center gap-1 flex-wrap"></div>
    <button id="add-tab" title="Neuen Tab erstellen" class="text-xl px-2 py-1 leading-none hover:opacity-80">➕</button>
    <button id="select-root" class="ml-auto text-sm px-3 py-1 rounded">Ordner wählen</button>
    <button id="open-settings" title="Einstellungen" class="bg-gray-300 hover:bg-gray-400 text-gray-800 text-sm px-3 py-1 rounded ml-2">⚙️</button>
  </header>
  <div class="flex" style="height: calc(100% - 40px);">
    <aside id="sidebar" class="w-72 min-h-full p-3 relative transition-all duration-300 ease-in-out">
      <button id="sidebar-toggle" class="absolute top-2 right-2 text-xl collapse-icon" title="Liste ein-/ausblenden">⬅️</button>
      <h2 class="font-semibold mb-2 list-content">Module</h2>
      <div id="module-list" class="list-content flex flex-col gap-2 text-sm">
        <div class="text-gray-400">Wähle oben einen Ordner…</div>
      </div>
    </aside>
    <main class="flex-1 min-h-full overflow-auto">
      <div id="grids" class="relative w-full h-full"></div>
    </main>
  </div>
  <input type="file" id="folder-input" webkitdirectory directory mozdirectory multiple hidden />
  <!-- Settings Modal -->
  <div id="settings-modal" class="modal-overlay hidden">
    <div class="modal">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-lg font-semibold">Einstellungen</h2>
        <div class="flex gap-2"></div>
      </div>
      <div class="settings-nav flex gap-2 mb-3">
        <button data-section="general" class="active">Allgemein</button>
        <button data-section="topbar">Topbar</button>
        <button data-section="sidebar">Sidebar</button>
        <button data-section="modules">Module</button>
      </div>
      <!-- Allgemein section -->
      <div id="section-general" class="settings-section active">
        <div class="field-grid">
          <div class="form-field">
            <label>App Hintergrundfarbe</label>
            <input type="color" id="setting-app-bg" value="#f3f4f6" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Border Farbe</label>
            <input type="color" id="setting-border-color" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Primäre Buttonfarbe</label>
            <input type="color" id="setting-button-bg" value="#2563eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Primäre Buttontextfarbe</label>
            <input type="color" id="setting-button-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field col-span-2">
            <div class="flex items-center justify-between gap-4">
              <div>
                <label for="setting-grid-auto-arrange">Automatisches Nachrücken</label>
                <p class="text-xs text-gray-500">Module rücken Lücken automatisch nach oben, wenn diese Option aktiv ist.</p>
              </div>
              <label for="setting-grid-auto-arrange" class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="setting-grid-auto-arrange" class="sr-only peer">
                <div class="w-11 h-6 bg-gray-300 rounded-full transition peer-focus:ring-2 peer-focus:ring-blue-300 peer-checked:bg-blue-600"></div>
                <span class="absolute left-1 top-1 h-4 w-4 rounded-full bg-white transition-transform peer-checked:translate-x-5"></span>
              </label>
            </div>
          </div>
        </div>
      </div>
      <!-- Topbar section -->
      <div id="section-topbar" class="settings-section">
        <div class="field-grid">
          <div class="form-field">
            <label>Topbar Hintergrundfarbe</label>
            <input type="color" id="setting-topbar-bg" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Aktiver Tab Hintergrund</label>
            <input type="color" id="setting-tab-active-bg" value="#2563eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Aktiver Tab Text</label>
            <input type="color" id="setting-tab-active-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Inaktiver Tab Hintergrund</label>
            <input type="color" id="setting-tab-inactive-bg" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Inaktiver Tab Text</label>
            <input type="color" id="setting-tab-inactive-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
      <!-- Sidebar section -->
      <div id="section-sidebar" class="settings-section">
        <div class="field-grid">
          <div class="form-field">
            <label>Sidebar Hintergrundfarbe</label>
            <input type="color" id="setting-sidebar-bg" value="#f3f4f6" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Sidebar Textfarbe</label>
            <input type="color" id="setting-sidebar-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Drag &amp; Drop Hinweisfarbe</label>
            <input type="color" id="setting-grid-hint" value="#60a5fa" class="w-full border rounded p-1">
          </div>
          <!-- New sidebar module card settings -->
          <div class="form-field">
            <label>Sidebar Modul Hintergrundfarbe</label>
            <input type="color" id="setting-sidebar-module-bg" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Sidebar Modul Textfarbe</label>
            <input type="color" id="setting-sidebar-module-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Sidebar Modul Rahmenfarbe</label>
            <input type="color" id="setting-sidebar-module-border" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
      <!-- Modules section -->
      <div id="section-modules" class="settings-section">
        <div class="field-grid">
          <div class="form-field">
            <label>Modul Hintergrundfarbe</label>
            <input type="color" id="setting-module-bg" value="#005983" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Modul Textfarbe</label>
            <input type="color" id="setting-text-color" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Modul Rundung (px)</label>
            <input type="number" id="setting-border-radius" value="20" class="w-full border rounded p-1" min="0">
          </div>
          <div class="form-field">
            <label>Modul Kopfzeile Hintergrund</label>
            <input type="color" id="setting-module-header-bg" value="#0a0a0a" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Modul Kopfzeile Textfarbe</label>
            <input type="color" id="setting-module-header-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Löschen-Button Hintergrundfarbe</label>
            <input type="color" id="setting-danger-bg" value="#ef4444" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Löschen-Button Textfarbe</label>
            <input type="color" id="setting-danger-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Modul Rahmenfarbe</label>
            <input type="color" id="setting-module-border-color" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
      <div class="mt-4 flex justify-end gap-2">
        <button id="close-settings" class="bg-gray-300 hover:bg-gray-400 text-gray-800 text-sm px-3 py-1 rounded">Abbrechen</button>
        <button id="save-settings" class="bg-blue-600 hover:bg-blue-700 text-white text-sm px-3 py-1 rounded">Speichern</button>
      </div>
    </div>
  </div>
  <script>
/*
 * Global settings object; defaults correspond to CSS variables defined above.
 * New properties for border colour and sidebar text are included.
 */
let appSettings = {
  appBgColor: '#f3f4f6',
  sidebarBg: '#f3f4f6',
  sidebarText: '#1f2937',
  topBarBg: '#ffffff',
  buttonBg: '#2563eb',
  buttonText: '#ffffff',
  borderColor: '#e5e7eb',
  autoArrangeModules: true,
  moduleBgColor: '#005983',
  textColor: '#ffffff',
  moduleBorderRadius: '1.25rem',
  moduleHeaderBg: 'rgba(255,255,255,0.08)',
  moduleHeaderText: '#ffffff',
  dangerBg: '#ef4444',
  dangerText: '#ffffff',
  tabActiveBg: '#2563eb',
  tabActiveText: '#ffffff',
  tabInactiveBg: '#e5e7eb',
  tabInactiveText: '#1f2937',
  gridHint: '#60a5fa',
  moduleBorderColor: '#e5e7eb',
  sidebarModuleCardBg: '#ffffff',
  sidebarModuleCardText: '#1f2937',
  sidebarModuleCardBorder: '#e5e7eb'
};


const layoutFileName = 'layout.json';
const settingsFileName = 'settings.json';
let rootDirHandle = null;
let modulesDirHandle = null;
let liveModuleTemplates = [];
let tabs = [];
let activeTabIndex = 0;
let tabContextMenu = null;
// Start with sidebar closed by default
let isSidebarOpen = false;

/* ==== UNIQUE IDs ==== */
let usedInstanceIds = new Set();
let nextModuleInstanceId = 1;
function generateInstanceId() {
  if (window.crypto?.randomUUID) {
    let id;
    do { id = 'mod-' + crypto.randomUUID(); }
    while (usedInstanceIds.has(id));
    usedInstanceIds.add(id);
    return id;
  }
  let id;
  do { id = 'mod-' + (nextModuleInstanceId++); }
  while (usedInstanceIds.has(id));
  usedInstanceIds.add(id);
  return id;
}

// Cache DOM elements
const listEl = document.getElementById('module-list');
const gridsContainer = document.getElementById('grids');
const tabsContainer = document.getElementById('tabs-container');
const addTabBtn = document.getElementById('add-tab');
const sidebarEl = document.getElementById('sidebar');
const sidebarToggle = document.getElementById('sidebar-toggle');
const rootBtn = document.getElementById('select-root');
const settingsBtn = document.getElementById('open-settings');
const settingsModal = document.getElementById('settings-modal');
const closeSettingsBtn = document.getElementById('close-settings');
const saveSettingsBtn = document.getElementById('save-settings');
const folderInput = document.getElementById('folder-input');
// Settings inputs
const inputAppBg = document.getElementById('setting-app-bg');
const inputBorderColor = document.getElementById('setting-border-color');
const inputButtonBg = document.getElementById('setting-button-bg');
const inputButtonText = document.getElementById('setting-button-text');
const inputTopBarBg = document.getElementById('setting-topbar-bg');
const inputTabActiveBg = document.getElementById('setting-tab-active-bg');
const inputTabActiveText = document.getElementById('setting-tab-active-text');
const inputTabInactiveBg = document.getElementById('setting-tab-inactive-bg');
const inputTabInactiveText = document.getElementById('setting-tab-inactive-text');
const inputSidebarBg = document.getElementById('setting-sidebar-bg');
const inputSidebarText = document.getElementById('setting-sidebar-text');
const inputGridHint = document.getElementById('setting-grid-hint');
const inputAutoArrange = document.getElementById('setting-grid-auto-arrange');
const inputModuleBg = document.getElementById('setting-module-bg');
const inputTextColor = document.getElementById('setting-text-color');
const inputBorderRadius = document.getElementById('setting-border-radius');
const inputModuleHeaderBg = document.getElementById('setting-module-header-bg');
const inputModuleHeaderText = document.getElementById('setting-module-header-text');
const inputDangerBg = document.getElementById('setting-danger-bg');
const inputDangerText = document.getElementById('setting-danger-text');

// New module border and sidebar module card inputs
const inputModuleBorderColor = document.getElementById('setting-module-border-color');
const inputSidebarModuleBg = document.getElementById('setting-sidebar-module-bg');
const inputSidebarModuleText = document.getElementById('setting-sidebar-module-text');
const inputSidebarModuleBorder = document.getElementById('setting-sidebar-module-border');

const supportsDirectoryPicker = typeof window.showDirectoryPicker === 'function';
const rememberedRootMeta = (() => {
  try {
    const raw = localStorage.getItem('rememberRootMeta');
    return raw ? JSON.parse(raw) : null;
  } catch (error) {
    console.warn('Konnte gespeicherte Root-Metadaten nicht lesen', error);
    return null;
  }
})();

if (rememberedRootMeta?.name && (!supportsDirectoryPicker || rememberedRootMeta.fallback)) {
  rootBtn.textContent = rememberedRootMeta.name;
  rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
  rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
}

// Navigation buttons for settings
const settingsNavButtons = document.querySelectorAll('.settings-nav button');

let fallbackInputCleanup = null;
let fallbackSelection = null;

function normalizeRelativePath(file) {
  const raw = file?.webkitRelativePath || file?.relativePath || file?.path || '';
  if (!raw) return '';
  return raw.replace(/^[\\/]+/, '').replace(/\\/g, '/');
}

function deriveFallbackRootName(files) {
  // Try explicit paths exposed by Firefox (mozFullPath/path) first so we can
  // show the actual folder name that was picked.
  for (const file of files) {
    const fullPath = (file && typeof file.path === 'string' && file.path) ||
      (file && typeof file.mozFullPath === 'string' && file.mozFullPath);
    if (!fullPath) continue;
    const parts = fullPath.replace(/^[a-z]+:\\+/i, '').replace(/\\/g, '/').split('/').filter(Boolean);
    if (parts.length >= 2) {
      const modulesIndex = parts.lastIndexOf('modules');
      if (modulesIndex > 0) {
        return parts[modulesIndex - 1];
      }
      return parts[parts.length - 2];
    }
  }

  let fallbackName = null;
  for (const file of files) {
    const rel = normalizeRelativePath(file);
    if (!rel) continue;
    const parts = rel.split('/').filter(Boolean);
    if (parts.length) {
      const modulesIndex = parts.indexOf('modules');
      if (modulesIndex > 0) {
        return parts[modulesIndex - 1];
      }
      if (modulesIndex === 0 && parts.length >= 2) {
        return parts[1] || parts[0];
      }
      if (!fallbackName) fallbackName = parts[0];
    }
  }
  if (fallbackName) return fallbackName;
  if (files.length && files[0]?.name) {
    return files[0].name;
  }
  return 'Ausgewählter Ordner';
}

function prepareFallbackSelection(files) {
  const fileArray = Array.from(files || []);
  const segmentLists = fileArray.map(file => {
    const rel = normalizeRelativePath(file);
    const segments = rel ? rel.split('/').filter(Boolean) : [];
    if (!segments.length && file?.name) segments.push(file.name);
    return segments;
  });
  const dirSegments = segmentLists.map(segs => segs.slice(0, -1));
  let commonPrefix = [];
  if (dirSegments.length) {
    commonPrefix = dirSegments[0].slice();
    for (const dirs of dirSegments.slice(1)) {
      let i = 0;
      while (i < commonPrefix.length && i < dirs.length && commonPrefix[i] === dirs[i]) i++;
      commonPrefix = commonPrefix.slice(0, i);
      if (!commonPrefix.length) break;
    }
  }

  const relativePaths = new Map();
  const fileMap = new Map();
  const fileMapLower = new Map();

  fileArray.forEach((file, idx) => {
    const segments = segmentLists[idx];
    const relativeSegments = commonPrefix.length ? segments.slice(commonPrefix.length) : segments;
    const joined = relativeSegments.join('/');
    const canonical = (joined || file?.name || '').replace(/^[\\/]+/, '').replace(/\\/g, '/');
    if (!canonical) return;
    relativePaths.set(file, canonical);
    fileMap.set(canonical, file);
    fileMapLower.set(canonical.toLowerCase(), file);
    if (!canonical.includes('/') && file?.name) {
      fileMap.set(file.name, file);
      fileMapLower.set(file.name.toLowerCase(), file);
    }
  });

  const rootFromPrefix = commonPrefix.length ? commonPrefix[commonPrefix.length - 1] : null;
  const rootName = rootFromPrefix || deriveFallbackRootName(fileArray);

  return {
    files: fileArray,
    rootName,
    displayName: rootName || 'Ausgewählter Ordner',
    fileMap,
    fileMapLower,
    relativePaths,
    cachedLayout: null,
    cachedSettings: null
  };
}

function getFallbackFile(path) {
  if (!fallbackSelection || !path) return null;
  const normalized = path.replace(/^[\\/]+/, '').replace(/\\/g, '/');
  return fallbackSelection.fileMap.get(normalized) ||
    fallbackSelection.fileMapLower.get(normalized.toLowerCase()) || null;
}

function promptForDirectoryViaInput() {
  return new Promise(resolve => {
    if (!folderInput) {
      resolve(null);
      return;
    }
    if (typeof fallbackInputCleanup === 'function') {
      fallbackInputCleanup();
    }
    let resolved = false;
    const handleChange = event => {
      resolved = true;
      cleanup();
      const selection = prepareFallbackSelection(event.target.files);
      if (!selection.files.length) {
        resolve(null);
        return;
      }
      resolve(selection);
      setTimeout(() => { folderInput.value = ''; }, 0);
    };
    const handleFocus = () => {
      // Firefox fires the window focus event even when a folder was chosen.
      // Give the browser repeated chances to detect pending files before
      // concluding the dialog was cancelled.
      let attempts = 0;
      const check = () => {
        if (resolved) return;
        const pendingFiles = folderInput?.files;
        if (pendingFiles && pendingFiles.length) return;
        attempts += 1;
        if (attempts < 6) {
          setTimeout(check, 120);
          return;
        }
        cleanup();
        resolve(null);
      };
      setTimeout(check, 120);
    };
    function cleanup() {
      folderInput.removeEventListener('change', handleChange);
      window.removeEventListener('focus', handleFocus);
      fallbackInputCleanup = null;
    }
    fallbackInputCleanup = cleanup;
    folderInput.addEventListener('change', handleChange);
    window.addEventListener('focus', handleFocus);
    folderInput.value = '';
    folderInput.click();
  });
}

// Remember the selected root folder across sessions
const FS_HANDLE_KEY = 'rootDirHandle';
const FALLBACK_CACHE_KEY = 'fallbackSelectionCache';
const IDB_DB_NAME = 'modulesApp';
const IDB_DB_VERSION = 2;

function idbOpen() {
  return new Promise((res, rej) => {
    const req = indexedDB.open(IDB_DB_NAME, IDB_DB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains('fs-handles')) {
        db.createObjectStore('fs-handles');
      }
      if (!db.objectStoreNames.contains('fallback-cache')) {
        db.createObjectStore('fallback-cache');
      }
    };
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}
async function idbSet(key, val, store = 'fs-handles'){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction(store,'readwrite');
    tx.objectStore(store).put(val, key);
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function idbGet(key, store = 'fs-handles'){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction(store,'readonly');
    const req = tx.objectStore(store).get(key);
    req.onsuccess = () => res(req.result || null);
    req.onerror = () => rej(req.error);
  });
}
async function idbDel(key, store = 'fs-handles'){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction(store,'readwrite');
    tx.objectStore(store).delete(key);
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}

function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer || []);
  const chunk = 0x8000;
  for (let i = 0; i < bytes.length; i += chunk) {
    const slice = bytes.subarray(i, i + chunk);
    binary += String.fromCharCode(...slice);
  }
  return btoa(binary);
}

function base64ToUint8Array(base64) {
  const binary = atob(base64 || '');
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
  return bytes;
}

async function persistFallbackSelection(selection) {
  if (!selection || !Array.isArray(selection.files) || !selection.files.length) {
    try { await idbDel(FALLBACK_CACHE_KEY, 'fallback-cache'); } catch (e) {}
    return;
  }
  const files = [];
  for (const file of selection.files) {
    try {
      const buffer = await file.arrayBuffer();
      const relative = (selection.relativePaths && selection.relativePaths.get(file)) || normalizeRelativePath(file) || file.name;
      files.push({
        name: file.name,
        type: file.type || '',
        lastModified: file.lastModified || Date.now(),
        relativePath: relative,
        base64: arrayBufferToBase64(buffer)
      });
    } catch (error) {
      console.warn('Konnte Datei nicht für Fallback-Cache lesen', error);
    }
  }
  const cachedSettings = (() => {
    try { return selection.cachedSettings || localStorage.getItem('appSettings'); }
    catch { return selection.cachedSettings || null; }
  })();
  const cachedLayout = (() => {
    try { return selection.cachedLayout || localStorage.getItem('modulesLayout'); }
    catch { return selection.cachedLayout || null; }
  })();
  const payload = {
    ts: Date.now(),
    rootName: selection.rootName || selection.displayName || '',
    displayName: selection.displayName || selection.rootName || '',
    files,
    cachedSettings: cachedSettings || null,
    cachedLayout: cachedLayout || null
  };
  try {
    await idbSet(FALLBACK_CACHE_KEY, payload, 'fallback-cache');
  } catch (error) {
    console.warn('Konnte Fallback-Auswahl nicht speichern', error);
  }
}

async function updatePersistedFallbackCache(partial) {
  if (!partial || typeof partial !== 'object') return;
  try {
    const existing = await idbGet(FALLBACK_CACHE_KEY, 'fallback-cache');
    if (!existing) return;
    const updated = { ...existing, ...partial, ts: Date.now() };
    await idbSet(FALLBACK_CACHE_KEY, updated, 'fallback-cache');
  } catch (error) {
    console.warn('Konnte Fallback-Cache nicht aktualisieren', error);
  }
}

async function clearPersistedFallbackCache() {
  try { await idbDel(FALLBACK_CACHE_KEY, 'fallback-cache'); } catch (e) {}
}

async function rememberFallbackSettings(jsonText) {
  if (!fallbackSelection || typeof jsonText !== 'string') return;
  try { fallbackSelection.cachedSettings = jsonText; } catch (e) {}
  try { localStorage.setItem('appSettings', jsonText); } catch (e) {}
  try { await updatePersistedFallbackCache({ cachedSettings: jsonText }); }
  catch (error) { console.warn('Konnte zwischengespeicherte Einstellungen nicht aktualisieren', error); }
}

async function rememberFallbackLayout(jsonText) {
  if (!fallbackSelection || typeof jsonText !== 'string') return;
  try { fallbackSelection.cachedLayout = jsonText; } catch (e) {}
  try { localStorage.setItem('modulesLayout', jsonText); } catch (e) {}
  try { await updatePersistedFallbackCache({ cachedLayout: jsonText }); }
  catch (error) { console.warn('Konnte zwischengespeichertes Layout nicht aktualisieren', error); }
}

async function tryRestoreFallbackSelection(){
  if (supportsDirectoryPicker) return false;
  if (!rememberedRootMeta?.fallback) return false;
  try {
    const cached = await idbGet(FALLBACK_CACHE_KEY, 'fallback-cache');
    if (!cached || !Array.isArray(cached.files) || !cached.files.length) return false;
    const files = [];
    for (const entry of cached.files) {
      if (!entry?.base64) continue;
      try {
        const bytes = base64ToUint8Array(entry.base64);
        const file = new File([bytes], entry.name || 'datei', {
          type: entry.type || '',
          lastModified: entry.lastModified || Date.now()
        });
        const rel = entry.relativePath || entry.name || '';
        if (rel) {
          try { Object.defineProperty(file, 'webkitRelativePath', { value: rel, configurable: true }); } catch {}
          try { Object.defineProperty(file, 'relativePath', { value: rel, configurable: true }); } catch {}
          try { Object.defineProperty(file, 'path', { value: rel, configurable: true }); } catch {}
          try { Object.defineProperty(file, 'mozFullPath', { value: rel, configurable: true }); } catch {}
        }
        files.push(file);
      } catch (error) {
        console.warn('Konnte Fallback-Datei nicht rekonstruieren', error);
      }
    }
    if (!files.length) return false;
    const selection = prepareFallbackSelection(files);
    selection.cachedSettings = cached.cachedSettings || null;
    selection.cachedLayout = cached.cachedLayout || null;
    fallbackSelection = selection;
    rootDirHandle = null;
    modulesDirHandle = null;
    window.rootDirHandle = null;
    const displayName = rememberedRootMeta?.name || cached.displayName || selection.displayName;
    if (displayName) {
      rootBtn.textContent = displayName;
      rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
      rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
      try {
        localStorage.setItem('rememberRootMeta', JSON.stringify({
          name: displayName,
          ts: Date.now(),
          fallback: true
        }));
      } catch (e) {}
    }
    await loadModulesFromFileList(selection);
    await loadAppSettings();
    populateInputsFromSettings();
    await loadAndInitTabs();
    updateModuleDraggable();
    updateGridDraggable();
    updateGridAutoArrange();
    return true;
  } catch (error) {
    console.warn('Restore fallback selection failed:', error);
    return false;
  }
}
async function ensureRWPermission(handle){
  if (typeof handle?.queryPermission !== 'function') return true;
  const q = await handle.queryPermission({ mode: 'readwrite' });
  if (q === 'granted') return true;
  const r = await handle.requestPermission({ mode: 'readwrite' });
  return r === 'granted';
}
async function tryRestoreRootHandle(){
  if (!supportsDirectoryPicker) return false;
  try {
    const h = await idbGet(FS_HANDLE_KEY);
    if (!h) return false;
    const ok = await ensureRWPermission(h);
    if (!ok) return false;

    rootDirHandle = h;
    window.rootDirHandle = h;
    fallbackSelection = null;
    rootBtn.textContent = h.name;
    rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
    rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');

    await loadModulesFromRoot(h);
    await loadAppSettings();
    populateInputsFromSettings();
    await loadAndInitTabs();
    await clearPersistedFallbackCache();
    return true;
  } catch (e) {
    console.warn('Restore root handle failed:', e);
    return false;
  }
}


document.addEventListener('DOMContentLoaded', async () => {
  // Initialize sidebar collapsed state
  sidebarEl.classList.add('collapsed');
  // Trigger fade-in animation on initial load
  document.body.classList.add('fade-in');

  // Sidebar toggle
  sidebarToggle.addEventListener('click', () => {
    isSidebarOpen = !isSidebarOpen;
    sidebarEl.classList.toggle('collapsed', !isSidebarOpen);
    updateModuleDraggable();
    updateGridDraggable();
  });

  // Folder selection
  rootBtn.addEventListener('click', async () => {
    if (supportsDirectoryPicker) {
      try {
        fallbackSelection = null;
        rootDirHandle = await window.showDirectoryPicker();
        window.rootDirHandle = rootDirHandle;                      // expose
        rootBtn.textContent = rootDirHandle.name;
        await idbSet(FS_HANDLE_KEY, rootDirHandle);                // persist handle
        localStorage.setItem('rememberRootMeta', JSON.stringify({  // optional UI hint
          name: rootDirHandle.name, ts: Date.now(), fallback: false
        }));
        rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
        rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
        await clearPersistedFallbackCache();
        await loadModulesFromRoot(rootDirHandle);
        await loadAppSettings();
        populateInputsFromSettings();
        await loadAndInitTabs();
        // ensure grid state reflects current sidebar state
        updateModuleDraggable();
        updateGridDraggable();
      } catch (e) {
        console.warn(e);
        alert('Ordnerauswahl abgebrochen oder nicht erlaubt.');
      }
    } else {
      try {
        const selection = await promptForDirectoryViaInput();
        if (!selection) return;
        const { files, displayName } = selection;
        if (!files.length) return;
        fallbackSelection = selection;
        rootDirHandle = null;
        modulesDirHandle = null;
        window.rootDirHandle = null;                // not reusable
        await idbDel(FS_HANDLE_KEY);                // forget saved handle
        localStorage.setItem('rememberRootMeta', JSON.stringify({
          name: displayName,
          ts: Date.now(),
          fallback: true
        }));
        rootBtn.textContent = displayName;
        rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
        rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
        await persistFallbackSelection(fallbackSelection);
        await loadModulesFromFileList(selection);
        await loadAppSettings();
        populateInputsFromSettings();
        await loadAndInitTabs();
        updateModuleDraggable();
        updateGridDraggable();
      } catch (error) {
        console.warn(error);
        alert('Ordnerauswahl abgebrochen oder nicht erlaubt.');
      }
    }
  });

  // Add new tab
  addTabBtn.addEventListener('click', () => {
    const name = prompt('Name für neuen Tab:', 'Neuer Tab');
    if (!name) return;
    createTab(name);
    renderTabs();
    activateTab(tabs.length - 1);
    updateModuleDraggable();
    updateGridDraggable();
    saveLayout();
  });

  // Settings open
  settingsBtn.addEventListener('click', () => {
    originalSettings = JSON.parse(JSON.stringify(appSettings));
    populateInputsFromSettings();
    settingsModal.classList.remove('hidden');
  });
  // Settings cancel
  closeSettingsBtn.addEventListener('click', () => {
    settingsModal.classList.add('hidden');
    if (typeof originalSettings !== 'undefined') {
      appSettings = { ...originalSettings };
      applySettings();
      renderTabs();
    }
  });
  // Settings save
  saveSettingsBtn.addEventListener('click', async () => {
    readInputsIntoSettings();
    applySettings();
    await saveAppSettings();
    settingsModal.classList.add('hidden');
    renderTabs();
  });
  // Settings nav
  settingsNavButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      settingsNavButtons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const target = btn.dataset.section;
      document.querySelectorAll('.settings-section').forEach(sec => sec.classList.remove('active'));
      document.getElementById('section-' + target).classList.add('active');
    });
  });
  // Live preview for colours
  [inputAppBg,inputBorderColor,inputButtonBg,inputButtonText,inputTopBarBg,inputTabActiveBg,inputTabActiveText,inputTabInactiveBg,inputTabInactiveText,inputSidebarBg,inputSidebarText,inputGridHint,inputModuleBg,inputTextColor,inputModuleHeaderBg,inputModuleHeaderText,inputDangerBg,inputDangerText,inputModuleBorderColor,inputSidebarModuleBg,inputSidebarModuleText,inputSidebarModuleBorder].forEach(inp => {
    inp.addEventListener('input', () => {
      readInputsIntoSettings();
      applySettings();
      renderTabs();
    });
  });
  if (inputAutoArrange) {
    inputAutoArrange.addEventListener('change', () => {
      readInputsIntoSettings();
      applySettings();
    });
  }
  inputBorderRadius.addEventListener('input', () => {
    appSettings.moduleBorderRadius = ((parseFloat(inputBorderRadius.value)||0)/16) + 'rem';
    applySettings();
  });

  /* First tab on initial load */
  createTab('Standard');
  renderTabs();
  activateTab(0);
  updateModuleDraggable();
  updateGridDraggable();
  updateGridAutoArrange();

  // --- Try to restore AFTER wiring handlers ---
  let restored = false;
  if (supportsDirectoryPicker) {
    restored = await tryRestoreRootHandle();
    if (restored) {
      updateModuleDraggable();
      updateGridDraggable();
      updateGridAutoArrange();
    }
  } else {
    restored = await tryRestoreFallbackSelection();
  }
});

/** Populate inputs from appSettings */
function populateInputsFromSettings() {
  inputAppBg.value = toColor(appSettings.appBgColor, inputAppBg.value);
  inputBorderColor.value = toColor(appSettings.borderColor, inputBorderColor.value);
  inputButtonBg.value = toColor(appSettings.buttonBg, inputButtonBg.value);
  inputButtonText.value = toColor(appSettings.buttonText, inputButtonText.value);
  inputTopBarBg.value = toColor(appSettings.topBarBg, inputTopBarBg.value);
  inputTabActiveBg.value = toColor(appSettings.tabActiveBg, inputTabActiveBg.value);
  inputTabActiveText.value = toColor(appSettings.tabActiveText, inputTabActiveText.value);
  inputTabInactiveBg.value = toColor(appSettings.tabInactiveBg, inputTabInactiveBg.value);
  inputTabInactiveText.value = toColor(appSettings.tabInactiveText, inputTabInactiveText.value);
  inputSidebarBg.value = toColor(appSettings.sidebarBg, inputSidebarBg.value);
  inputSidebarText.value = toColor(appSettings.sidebarText, inputSidebarText.value);
  inputGridHint.value = toColor(appSettings.gridHint, inputGridHint.value);
  if (inputAutoArrange) inputAutoArrange.checked = !!appSettings.autoArrangeModules;
  inputModuleBg.value = toColor(appSettings.moduleBgColor, inputModuleBg.value);
  inputTextColor.value = toColor(appSettings.textColor, inputTextColor.value);
  inputBorderRadius.value = Math.round(parseFloat(appSettings.moduleBorderRadius) * 16 || 0);
  inputModuleHeaderBg.value = toColor(appSettings.moduleHeaderBg, inputModuleHeaderBg.value);
  inputModuleHeaderText.value = toColor(appSettings.moduleHeaderText, inputModuleHeaderText.value);
  inputDangerBg.value = toColor(appSettings.dangerBg, inputDangerBg.value);
  inputDangerText.value = toColor(appSettings.dangerText, inputDangerText.value);

  // New module border and sidebar module card settings
  if (inputModuleBorderColor) inputModuleBorderColor.value = toColor(appSettings.moduleBorderColor, inputModuleBorderColor.value);
  if (inputSidebarModuleBg) inputSidebarModuleBg.value = toColor(appSettings.sidebarModuleCardBg, inputSidebarModuleBg.value);
  if (inputSidebarModuleText) inputSidebarModuleText.value = toColor(appSettings.sidebarModuleCardText, inputSidebarModuleText.value);
  if (inputSidebarModuleBorder) inputSidebarModuleBorder.value = toColor(appSettings.sidebarModuleCardBorder, inputSidebarModuleBorder.value);
}

/** Read inputs into appSettings */
function readInputsIntoSettings() {
  appSettings.appBgColor = inputAppBg.value;
  appSettings.borderColor = inputBorderColor.value;
  appSettings.buttonBg = inputButtonBg.value;
  appSettings.buttonText = inputButtonText.value;
  appSettings.topBarBg = inputTopBarBg.value;
  appSettings.tabActiveBg = inputTabActiveBg.value;
  appSettings.tabActiveText = inputTabActiveText.value;
  appSettings.tabInactiveBg = inputTabInactiveBg.value;
  appSettings.tabInactiveText = inputTabInactiveText.value;
  appSettings.sidebarBg = inputSidebarBg.value;
  appSettings.sidebarText = inputSidebarText.value;
  appSettings.gridHint = inputGridHint.value;
  if (inputAutoArrange) appSettings.autoArrangeModules = inputAutoArrange.checked;
  appSettings.moduleBgColor = inputModuleBg.value;
  appSettings.textColor = inputTextColor.value;
  appSettings.moduleBorderRadius = ((parseFloat(inputBorderRadius.value)||0)/16) + 'rem';
  appSettings.moduleHeaderBg = inputModuleHeaderBg.value;
  appSettings.moduleHeaderText = inputModuleHeaderText.value;
  appSettings.dangerBg = inputDangerBg.value;
  appSettings.dangerText = inputDangerText.value;

  // New module border and sidebar module card settings
  appSettings.moduleBorderColor = inputModuleBorderColor.value;
  appSettings.sidebarModuleCardBg = inputSidebarModuleBg.value;
  appSettings.sidebarModuleCardText = inputSidebarModuleText.value;
  appSettings.sidebarModuleCardBorder = inputSidebarModuleBorder.value;
}

/** Convert rgba to hex for colour inputs */
function toColor(val, fallback) {
  if (!val) return fallback;
  if (/^#/.test(val)) return val;
  const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
  if (m) {
    const r = Number(m[1]).toString(16).padStart(2,'0');
    const g = Number(m[2]).toString(16).padStart(2,'0');
    const b = Number(m[3]).toString(16).padStart(2,'0');
    return '#' + r + g + b;
  }
  return fallback;
}

/** Apply CSS variables from appSettings */
function applySettings() {
  document.documentElement.style.setProperty('--app-bg', appSettings.appBgColor);
  document.documentElement.style.setProperty('--sidebar-bg', appSettings.sidebarBg);
  document.documentElement.style.setProperty('--sidebar-text', appSettings.sidebarText);
  document.documentElement.style.setProperty('--top-bar-bg', appSettings.topBarBg);
  document.documentElement.style.setProperty('--button-bg', appSettings.buttonBg);
  document.documentElement.style.setProperty('--button-text', appSettings.buttonText);
  document.documentElement.style.setProperty('--border-color', appSettings.borderColor);
  document.documentElement.style.setProperty('--module-bg', appSettings.moduleBgColor);
  document.documentElement.style.setProperty('--text-color', appSettings.textColor);
  document.documentElement.style.setProperty('--module-border-radius', appSettings.moduleBorderRadius);
  document.documentElement.style.setProperty('--module-header-bg', appSettings.moduleHeaderBg);
  document.documentElement.style.setProperty('--module-header-text', appSettings.moduleHeaderText);
  document.documentElement.style.setProperty('--danger-bg', appSettings.dangerBg);
  document.documentElement.style.setProperty('--danger-text', appSettings.dangerText);
  document.documentElement.style.setProperty('--tab-active-bg', appSettings.tabActiveBg);
  document.documentElement.style.setProperty('--tab-active-text', appSettings.tabActiveText);
  document.documentElement.style.setProperty('--tab-inactive-bg', appSettings.tabInactiveBg);
  document.documentElement.style.setProperty('--tab-inactive-text', appSettings.tabInactiveText);
  document.documentElement.style.setProperty('--grid-hint', appSettings.gridHint);

  // Apply module border and sidebar module card colours
  document.documentElement.style.setProperty('--module-border-color', appSettings.moduleBorderColor);
  document.documentElement.style.setProperty('--sidebar-module-card-bg', appSettings.sidebarModuleCardBg);
  document.documentElement.style.setProperty('--sidebar-module-card-text', appSettings.sidebarModuleCardText);
  document.documentElement.style.setProperty('--sidebar-module-card-border', appSettings.sidebarModuleCardBorder);

  updateGridAutoArrange();
}

/** Save settings to storage */
async function saveAppSettings() {
  if (rootDirHandle && supportsDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(settingsFileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(appSettings));
      await writable.close();
    } catch (e) { console.warn('Konnte Einstellungsdatei nicht speichern', e); }
  } else {
    let json = null;
    try {
      json = JSON.stringify(appSettings);
      localStorage.setItem('appSettings', json);
    } catch (e) { console.warn('Konnte Einstellungen nicht im localStorage speichern', e); }
    if (!json) {
      try { json = JSON.stringify(appSettings); } catch (e) {}
    }
    if (json) await rememberFallbackSettings(json);
  }
}

function applyLoadedSettings(loadedSettings) {
  if (!loadedSettings || typeof loadedSettings !== 'object') return;
  const { gridFloat, autoArrangeModules, ...rest } = loadedSettings;
  appSettings = { ...appSettings, ...rest };
  if (typeof autoArrangeModules === 'boolean') {
    appSettings.autoArrangeModules = autoArrangeModules;
  } else if (typeof gridFloat === 'boolean') {
    appSettings.autoArrangeModules = !gridFloat;
  }
}

/** Load settings from storage */
async function loadAppSettings() {
  let loaded = false;
  let jsonText = null;
  if (rootDirHandle && supportsDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(settingsFileName, { create: false });
      const file = await fileHandle.getFile();
      jsonText = await file.text();
      const parsed = JSON.parse(jsonText);
      applyLoadedSettings(parsed);
      loaded = true;
    } catch (e) {}
  } else if (fallbackSelection) {
    try {
      const file = getFallbackFile(settingsFileName);
      if (file) {
        jsonText = await file.text();
        applyLoadedSettings(JSON.parse(jsonText));
        loaded = true;
      }
    } catch (e) {}
    if (!loaded) {
      try {
        if (fallbackSelection.cachedSettings) {
          jsonText = fallbackSelection.cachedSettings;
          applyLoadedSettings(JSON.parse(jsonText));
          loaded = true;
        }
      } catch (e) {}
    }
  }
  if (!loaded) {
    try {
      const ls = localStorage.getItem('appSettings');
      if (ls) {
        jsonText = ls;
        applyLoadedSettings(JSON.parse(ls));
        loaded = true;
      }
    } catch (e) {}
  }
  if (jsonText && loaded) {
    if (fallbackSelection) {
      await rememberFallbackSettings(jsonText);
    } else {
      try { localStorage.setItem('appSettings', jsonText); } catch (e) {}
    }
  }
  applySettings();
}

/** Update card draggability */
function updateModuleDraggable() {
  listEl.querySelectorAll('.module-card[data-subdir]').forEach(card => {
    card.draggable = isSidebarOpen;
    card.style.webkitUserDrag = isSidebarOpen ? 'element' : 'none';
    card.style.cursor = isSidebarOpen ? 'grab' : 'default';
  });
}
function updateGridDraggable() {
  tabs.forEach(tab => {
    if (tab.grid) {
      // grid-wide static mode reflects sidebar state
      tab.grid.setStatic(!isSidebarOpen);
      tab.grid.engine.nodes.forEach(node => {
        tab.grid.movable(node.el, isSidebarOpen);
        tab.grid.resizable(node.el, isSidebarOpen);
        const dragHandle = node.el.querySelector('.drag-handle');
        if (dragHandle) dragHandle.style.cursor = isSidebarOpen ? 'move' : 'default';
        const delBtn = node.el.querySelector('.remove');
        if (delBtn) delBtn.style.display = isSidebarOpen ? '' : 'none';
        const resizeHandles = node.el.querySelectorAll('.ui-resizable-handle');
        resizeHandles.forEach(handle => {
          handle.style.display = isSidebarOpen ? '' : 'none';
          if (!isSidebarOpen) handle.style.cursor = 'default';
        });
      });
    }
  });
}

function updateGridAutoArrange() {
  const autoArrange = !!appSettings.autoArrangeModules;
  const shouldFloat = !autoArrange;
  tabs.forEach(tab => {
    const grid = tab.grid;
    if (!grid) return;
    if (typeof grid.float === 'function') {
      grid.float(shouldFloat);
    } else if (typeof grid.setFloat === 'function') {
      grid.setFloat(shouldFloat);
    } else {
      grid.opts = grid.opts || {};
      grid.opts.float = shouldFloat;
      if (grid.engine && Object.prototype.hasOwnProperty.call(grid.engine, 'float')) {
        grid.engine.float = shouldFloat;
      }
    }
  });
}

/** Load modules via FS API */
async function loadModulesFromRoot(rootHandle) {
  fallbackSelection = null;
  try {
    modulesDirHandle = await rootHandle.getDirectoryHandle('modules', { create: false });
  } catch {
    liveModuleTemplates = [];
    renderSidebar([]);
    alert('Kein "modules" Unterordner im gewählten Root gefunden.');
    return;
  }
  const { tree, modules } = await buildTreeFromHandle(modulesDirHandle);
  liveModuleTemplates = modules;
  renderSidebar(tree);

  // Apply a fade-in animation to grids container when modules load
  if (gridsContainer) {
    gridsContainer.classList.add('fade-in');
    setTimeout(() => gridsContainer.classList.remove('fade-in'), 600);
  }
}

/** Fallback load modules via file list */
async function loadModulesFromFileList(selection) {
  const { tree, modules } = await buildTreeFromFileList(selection);
  liveModuleTemplates = modules;
  renderSidebar(tree);

  // Apply fade-in to grids container when modules load via fallback
  if (gridsContainer) {
    gridsContainer.classList.add('fade-in');
    setTimeout(() => gridsContainer.classList.remove('fade-in'), 600);
  }
}

/** Render sidebar module cards */
function renderSidebar(tree) {
  listEl.innerHTML = '';
  if (!tree.length) {
    listEl.innerHTML = '<div class="text-gray-400">Keine Module gefunden.</div>';
    return;
  }
  tree.forEach(node => renderSidebarNode(node, listEl));
  updateModuleDraggable();
}

function renderSidebarNode(node, container) {
  if (node.type === 'folder') {
    const header = document.createElement('div');
    header.className = 'module-card rounded p-3 cursor-pointer shadow transition flex items-center';
    const nameSpan = document.createElement('span');
    nameSpan.className = 'font-semibold flex-1';
    nameSpan.textContent = node.name;
    const arrow = document.createElement('span');
    arrow.textContent = '▼';
    header.appendChild(nameSpan);
    header.appendChild(arrow);
    container.appendChild(header);
    const childrenContainer = document.createElement('div');
    childrenContainer.className = 'pl-4 flex flex-col gap-2 mt-2';
    childrenContainer.style.display = 'none';
    container.appendChild(childrenContainer);
    node.children.forEach(child => renderSidebarNode(child, childrenContainer));
    header.addEventListener('click', () => {
      const open = childrenContainer.style.display !== 'none';
      childrenContainer.style.display = open ? 'none' : '';
      arrow.textContent = open ? '▼' : '▲';
    });
  } else {
    const { template, subdir, attachments } = node;
    const card = document.createElement('div');
    card.className = 'module-card rounded p-3 cursor-grab shadow transition flex flex-col';
    card.dataset.subdir = subdir;
    const header = document.createElement('div');
    header.className = 'flex items-center gap-2';
    if (template.icon) {
      const iconSpan = document.createElement('span');
      iconSpan.className = 'text-xl';
      iconSpan.textContent = template.icon;
      header.appendChild(iconSpan);
    }
    const nameSpan = document.createElement('span');
    nameSpan.className = 'font-semibold flex-1';
    nameSpan.textContent = template.name || subdir;
    header.appendChild(nameSpan);
    card.appendChild(header);
    if (attachments?.length) {
      const att = document.createElement('div');
      att.className = 'sidebar-module-attachment mt-1';
      att.textContent = '📎 ' + attachments.join(', ');
      card.appendChild(att);
    }
    card.draggable = isSidebarOpen;
    card.addEventListener('dragstart', e => {
      if (!isSidebarOpen) {
        e.preventDefault(); return;
      }
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', subdir);
      e.dataTransfer.setData('application/x-module-subdir', subdir);
      card.classList.add('dragging');
    });
    card.addEventListener('dragend', () => card.classList.remove('dragging'));
    container.appendChild(card);
  }
}

async function buildTreeFromHandle(dirHandle, basePath = '') {
  const modules = [];
  async function scan(handle, relPath) {
    let moduleJson = null;
    const attachments = [];
    let hasJson = false, hasJs = false;
    const children = [];
    for await (const entry of handle.values()) {
      if (entry.kind === 'file') {
        if (entry.name.endsWith('.json')) {
          hasJson = true;
          const f = await entry.getFile();
          try { moduleJson = JSON.parse(await f.text()); } catch {}
        } else {
          if (entry.name.endsWith('.js')) hasJs = true;
          attachments.push(entry.name);
        }
      } else if (entry.kind === 'directory') {
        const child = await scan(entry, relPath ? `${relPath}/${entry.name}` : entry.name);
        if (child) children.push(child);
      }
    }
    if (hasJson && hasJs && moduleJson) {
      const node = { type: 'module', template: moduleJson, subdir: relPath, attachments, dirHandle: handle };
      modules.push(node);
      return node;
    }
    return { type: 'folder', name: handle.name, children };
  }
  const root = await scan(dirHandle, basePath);
  return { tree: root.children || [], modules };
}

async function buildTreeFromFileList(selection) {
  const files = Array.isArray(selection)
    ? selection
    : Array.from((selection && selection.files) || []);
  const relativePathMap = selection && selection.relativePaths instanceof Map ? selection.relativePaths : null;

  const root = { name: 'modules', files: [], children: {} };
  const entries = [];
  let hasExplicitModulesFolder = false;

  for (const file of Array.from(files || [])) {
    const normalized = relativePathMap ? relativePathMap.get(file) : normalizeRelativePath(file);
    const parts = normalized ? normalized.split('/').filter(Boolean) : [];
    if (parts.includes('modules')) hasExplicitModulesFolder = true;
    if (parts.length) {
      entries.push({ file, parts });
    } else if (file?.name) {
      entries.push({ file, parts: [file.name] });
    }
  }

  const modules = [];

  function insert(node, parts, file) {
    if (!parts.length) {
      node.files.push(file);
      return;
    }
    const [segment, ...rest] = parts;
    if (!rest.length) {
      node.files.push(file);
      return;
    }
    if (!node.children[segment]) {
      node.children[segment] = { name: segment, files: [], children: {} };
    }
    insert(node.children[segment], rest, file);
  }

  for (const entry of entries) {
    let relParts = entry.parts;
    if (hasExplicitModulesFolder) {
      const idx = relParts.indexOf('modules');
      if (idx === -1) continue;
      relParts = relParts.slice(idx + 1);
    }
    if (!relParts.length) continue;
    insert(root, relParts, entry.file);
  }

  async function finalize(node, relPath) {
    const hasJson = node.files.some(f => f.name.endsWith('.json'));
    const hasJs = node.files.some(f => f.name.endsWith('.js'));
    let moduleJson = null;
    const attachments = [];
    if (hasJson && hasJs) {
      for (const f of node.files) {
        if (f.name.endsWith('.json')) { try { moduleJson = JSON.parse(await f.text()); } catch {} }
        else attachments.push(f.name);
      }
      const subdir = relPath;
      const modNode = { type: 'module', template: moduleJson, subdir, attachments, fileList: node.files };
      modules.push(modNode);
      return modNode;
    }
    const children = [];
    for (const [name, child] of Object.entries(node.children)) {
      const childNode = await finalize(child, relPath ? `${relPath}/${name}` : name);
      if (childNode) children.push(childNode);
    }
    return { type: 'folder', name: node.name, children };
  }

  const tree = await finalize(root, '');
  return { tree: tree.children || [], modules };
}

/** Reset and recreate tabs using saved layout */
async function loadAndInitTabs() {
  resetTabs();
  let saved = await loadLayout();
  let migrated = false;

  if (saved && saved.length) {
    for (const tabData of saved) {
      if (!Array.isArray(tabData.modules)) continue;
      for (const mod of tabData.modules) {
        const name = mod.subdir || mod.name;
        const exists = name && liveModuleTemplates.find(t => t.subdir === name);
        if (!exists && name) {
          const base = name.split('/').pop();
          const found = liveModuleTemplates.find(t => t.subdir.split('/').pop() === base);
          if (found) {
            mod.subdir = found.subdir;
            delete mod.name;
            migrated = true;
          }
        }
      }
    }
  }

  // Seed used IDs and counter from saved layout
  usedInstanceIds = new Set();
  nextModuleInstanceId = 1;
  if (saved && saved.length) {
    for (const t of saved) {
      for (const m of (t.modules || [])) {
        if (m.id) {
          usedInstanceIds.add(m.id);
          const num = /^mod-(\d+)$/.exec(m.id)?.[1];
          if (num) nextModuleInstanceId = Math.max(nextModuleInstanceId, Number(num) + 1);
        }
      }
    }
  }

  if (saved && saved.length) {
    for (const tabData of saved) createTab(tabData.name, tabData.modules);
  } else {
    createTab('Standard');
  }
  renderTabs();
  activateTab(0);

  if (migrated) saveLayout();

  // ensure initial state reflects current sidebar state
  updateModuleDraggable();
  updateGridDraggable();
  updateGridAutoArrange();
}

/** Create a tab and grid */
function createTab(name, layoutModules = []) {
  const tabIndex = tabs.length;
  const tab = { name: name || ('Tab ' + (tabIndex + 1)), modules: [], grid: null, el: null };
  const gridEl = document.createElement('div');
  gridEl.className = 'grid-stack p-4';
  gridEl.style.minHeight = 'calc(100vh - 40px)';
  gridEl.dataset.tabIndex = tabIndex;
  gridsContainer.appendChild(gridEl);

  const gridInstance = GridStack.init({ cellHeight: 30, margin: 5, handle: '.grid-stack-item-content', column: 12, float: !appSettings.autoArrangeModules, minRow: 8 }, gridEl);

  // Reflect current sidebar state immediately (no drag/resize when closed)
  gridInstance.setStatic(!isSidebarOpen);

  tab.grid = gridInstance;
  tab.el = gridEl;
  tabs.push(tab);
  gridInstance.on('change', () => updateModulesPositions(tabIndex));

  gridEl.addEventListener('dragover', e => {
    if (!isSidebarOpen) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
    gridEl.classList.add('grid-drop-hint');
  });
  gridEl.addEventListener('dragleave', () => gridEl.classList.remove('grid-drop-hint'));
  gridEl.addEventListener('drop', async e => {
    if (!isSidebarOpen) return;
    e.preventDefault();
    gridEl.classList.remove('grid-drop-hint');
    let subdir = e.dataTransfer.getData('application/x-module-subdir');
    if (!subdir) subdir = e.dataTransfer.getData('text/plain');
    if (!subdir) return;
    const modObj = liveModuleTemplates.find(m => m.subdir === subdir);
    if (!modObj) return;
    const rect = gridEl.getBoundingClientRect();
    const cell = gridInstance.getCellFromPixel({ left: e.clientX - rect.left, top: e.clientY - rect.top });
    const tmpl = modObj.template;
    const w = parseInt(tmpl.w) || 6;
    const h = parseInt(tmpl.h) || 3;
    const pos = { x: cell.x, y: cell.y, w, h };
    // Generate unique instance id for this drop
    const instanceId = generateInstanceId();
    if (tmpl.script) {
      const jsFileName = findScriptFileName(tmpl, modObj);
      if (!jsFileName) { alert('Kein Modul-JS gefunden für: ' + (tmpl.name || modObj.subdir)); return; }
      await loadAndRunModuleScript(jsFileName, tmpl, modObj, pos, gridInstance, tabIndex, instanceId);
    } else if (tmpl.fields) {
      createUniversalModule(tmpl, pos, modObj, gridInstance, tabIndex, instanceId);
    } else {
      createSimpleModule(tmpl.name || modObj.subdir, pos, gridInstance, tabIndex, modObj.subdir, instanceId);
    }
  });

  if (layoutModules && layoutModules.length) {
    setTimeout(async () => {
      for (const m of layoutModules) {
        const modObj = liveModuleTemplates.find(t => t.subdir === m.subdir);
        const pos = { x: m.x || 0, y: m.y || 0, w: m.w || 6, h: m.h || 3 };
        // Use stored id if available; otherwise generate a new one
        const instanceId = m.id || generateInstanceId();
        if (modObj && modObj.template) {
          const tmpl = modObj.template;
          if (m.type === 'script' && tmpl.script) {
            const jsFileName = findScriptFileName(tmpl, modObj);
            if (jsFileName) await loadAndRunModuleScript(jsFileName, tmpl, modObj, pos, gridInstance, tabIndex, instanceId);
          } else if (m.type === 'fields' && tmpl.fields) {
            createUniversalModule(tmpl, pos, modObj, gridInstance, tabIndex, instanceId);
          } else {
            createSimpleModule(tmpl.name || modObj.subdir, pos, gridInstance, tabIndex, modObj.subdir, instanceId);
          }
        } else {
          createSimpleModule(m.subdir, pos, gridInstance, tabIndex, m.subdir, instanceId);
        }
      }
    }, 50);
  }
  return tab;
}

/** Render tabs */
function renderTabs() {
  tabsContainer.innerHTML = '';
  tabs.forEach((tab, idx) => {
    const item = document.createElement('div');
    item.className = 'tab-item flex items-center gap-1 px-3 py-1 rounded cursor-pointer';
    if (idx === activeTabIndex) item.classList.add('tab-active'); else item.classList.add('tab-inactive','hover:opacity-90');
    const label = document.createElement('span');
    label.className = 'truncate max-w-xs';
    label.textContent = tab.name;
    item.appendChild(label);
    item.addEventListener('click', () => activateTab(idx));
    item.addEventListener('contextmenu', e => openTabContextMenu(e, idx));
    tabsContainer.appendChild(item);
  });
}

/** Activate a tab */
function activateTab(idx) {
  if (idx < 0 || idx >= tabs.length) return;
  tabs.forEach((tab, i) => { if (tab.el) tab.el.style.display = (i === idx ? '' : 'none'); });
  activeTabIndex = idx;
  renderTabs();
}

/** Delete tab */
function deleteTab(idx) {
  if (tabs.length <= 1) { alert('Mindestens ein Tab muss bestehen.'); return; }
  const removed = tabs.splice(idx,1)[0];
  if (removed && removed.el && removed.el.parentNode) removed.el.parentNode.removeChild(removed.el);
  if (activeTabIndex >= idx) activeTabIndex = Math.max(0, activeTabIndex - 1);
  renderTabs();
  activateTab(activeTabIndex);
  saveLayout();
}

/** Rename tab */
function renameTab(idx) {
  const newName = prompt('Neuer Name für den Tab:', tabs[idx].name);
  if (newName) {
    tabs[idx].name = newName;
    renderTabs();
    saveLayout();
  }
}

/** Open context menu for a tab */
function openTabContextMenu(e, idx) {
  e.preventDefault();
  closeTabContextMenu();
  const menu = document.createElement('div');
  menu.className = 'tab-context-menu absolute bg-white border rounded shadow z-50 text-sm';
  menu.style.left = e.pageX + 'px';
  menu.style.top = e.pageY + 'px';

  const renameItem = document.createElement('div');
  renameItem.className = 'px-3 py-1 hover:bg-gray-100 cursor-pointer';
  renameItem.textContent = 'Namen bearbeiten';
  renameItem.addEventListener('click', () => {
    closeTabContextMenu();
    renameTab(idx);
  });
  menu.appendChild(renameItem);

  const deleteItem = document.createElement('div');
  deleteItem.className = 'px-3 py-1 hover:bg-gray-100 cursor-pointer';
  deleteItem.textContent = 'Tab löschen';
  deleteItem.addEventListener('click', () => {
    closeTabContextMenu();
    if (!confirm('Tab wirklich löschen?')) return;
    deleteTab(idx);
  });
  menu.appendChild(deleteItem);

  document.body.appendChild(menu);
  tabContextMenu = menu;
}

function closeTabContextMenu() {
  if (tabContextMenu) {
    tabContextMenu.remove();
    tabContextMenu = null;
  }
}

document.addEventListener('click', () => closeTabContextMenu());

/** Remove all tabs */
function resetTabs() {
  tabs.forEach(tab => { if (tab.el && tab.el.parentNode) tab.el.parentNode.removeChild(tab.el); });
  tabs = [];
  tabsContainer.innerHTML = '';
}

/** Update module positions after drag/resizing */
function updateModulesPositions(index) {
  const tab = tabs[index];
  if (!tab || !tab.grid) return;
  tab.modules = tab.grid.engine.nodes.map(node => {
    const subdir = node.el.dataset.subdir;
    const type = node.el.dataset.modType;
    let instanceId = node.el.dataset.instanceId;
    if (!instanceId) {
      instanceId = generateInstanceId();
      node.el.dataset.instanceId = instanceId;
    } else {
      usedInstanceIds.add(instanceId);
    }
    return { id: instanceId, subdir, type, x: node.x, y: node.y, w: node.w, h: node.h };
  });
  saveLayout();
}

/** Save layout */
async function saveLayout() {
  const layoutData = { tabs: tabs.map(({name, modules}) => ({ name, modules })) };
  if (rootDirHandle && supportsDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(layoutFileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(layoutData));
      await writable.close();
    } catch (e) { console.warn('Konnte Layout-Datei nicht speichern', e); }
  } else {
    let json = null;
    try {
      json = JSON.stringify(layoutData);
      localStorage.setItem('modulesLayout', json);
    } catch (e) { console.warn('Konnte Layout nicht im localStorage speichern', e); }
    if (!json) {
      try { json = JSON.stringify(layoutData); } catch (e) {}
    }
    if (json) await rememberFallbackLayout(json);
  }
}

/** Load layout */
async function loadLayout() {
  let layoutTabs = null;
  let layoutText = null;
  if (rootDirHandle && supportsDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(layoutFileName, { create: false });
      const file = await fileHandle.getFile();
      layoutText = await file.text();
      const obj = JSON.parse(layoutText);
      if (obj && Array.isArray(obj.tabs)) layoutTabs = obj.tabs;
    } catch (e) {}
  } else if (fallbackSelection) {
    try {
      const file = getFallbackFile(layoutFileName);
      if (file) {
        layoutText = await file.text();
        const obj = JSON.parse(layoutText);
        if (obj && Array.isArray(obj.tabs)) layoutTabs = obj.tabs;
      }
    } catch (e) {}
    if (!layoutTabs) {
      try {
        if (fallbackSelection.cachedLayout) {
          layoutText = fallbackSelection.cachedLayout;
          const obj = JSON.parse(layoutText);
          if (obj && Array.isArray(obj.tabs)) layoutTabs = obj.tabs;
        }
      } catch (e) {}
    }
  }
  if (!layoutTabs) {
    try {
      const ls = localStorage.getItem('modulesLayout');
      if (ls) {
        layoutText = ls;
        const obj = JSON.parse(ls);
        if (obj && Array.isArray(obj.tabs)) layoutTabs = obj.tabs;
      }
    } catch (e) {}
  }
  if (layoutTabs && layoutText) {
    if (fallbackSelection) {
      await rememberFallbackLayout(layoutText);
    } else {
      try { localStorage.setItem('modulesLayout', layoutText); } catch (e) {}
    }
  }
  return layoutTabs;
}

/** Determine script filename from module JSON */
function findScriptFileName(moduleJson, modObj) {
  const base = String(moduleJson.script).replace(/^render/, '');
  const candidates = (modObj.attachments || []).filter(n => n.endsWith('.js'));
  let jsFileName = candidates.find(n => n.replace(/\.js$/, '') === base);
  if (!jsFileName) jsFileName = candidates[0];
  return jsFileName;
}

/** Load and run script module */
async function loadAndRunModuleScript(jsFileName, moduleJson, modObj, gridPos, gridInstance, tabIndex, instanceIdArg) {
  let jsText = '';
  if (modObj.dirHandle) {
    const jsHandle = await modObj.dirHandle.getFileHandle(jsFileName);
    jsText = await (await jsHandle.getFile()).text();
  } else if (modObj.fileList) {
    const f = modObj.fileList.find(f => f.name === jsFileName);
    if (!f) { alert('JS-Datei nicht gefunden (Fallback).'); return; }
    jsText = await f.text();
  } else {
    alert('Keine Quelle für JS-Datei gefunden.');
    return;
  }
  try { eval(jsText); } catch (e) { console.error(e); alert('Fehler im Modul-JS.'); return; }
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  el.innerHTML = `<div class="grid-stack-item-content relative">
  <button class="remove gs-remove px-2 py-1 text-xs rounded">🗑</button>
  <div class="content"></div>
  </div>`;
  el.dataset.subdir = modObj.subdir;
  el.dataset.modType = 'script';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  const pos = gridPos || { x:0, y:0, w: moduleJson.w || 6, h: moduleJson.h || 3 };
  const widgetOptions = {
    ...pos,
    minW: moduleJson.minW || 1,
    minH: moduleJson.minH || 1
  };
  if (Number.isFinite(moduleJson.maxW)) widgetOptions.maxW = moduleJson.maxW;
  if (Number.isFinite(moduleJson.maxH)) widgetOptions.maxH = moduleJson.maxH;
  gridInstance.addWidget(el, widgetOptions);
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabIndex);
    updateGridDraggable();
  };
  if (typeof window[moduleJson.script] === 'function') {
    window[moduleJson.script](el.querySelector('.content'), { moduleJson, attachments: modObj.attachments || [], subdir: modObj.subdir });
  } else {
    alert('Exportierte Funktion nicht gefunden: ' + moduleJson.script);
  }
  // Apply fade-in animation to new module content
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabIndex);
  updateGridDraggable();
}

/** Create universal (fields) module */
function createUniversalModule(mod, pos, modObj, gridInstance, tabIndex, instanceIdArg) {
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  const defaultW = parseInt(mod.w) || 6;
  const defaultH = parseInt(mod.h) || 3;
  const finalPos = { ...pos };
  if (!pos || typeof pos.w === 'undefined') finalPos.w = defaultW;
  if (!pos || typeof pos.h === 'undefined') finalPos.h = defaultH;
  const bg = mod.color || appSettings.moduleBgColor;
  let html = `<div class="grid-stack-item-content" style="background:${bg}">`;
  html += `<div class="drag-handle"><span class="font-semibold">${mod.name || modObj.subdir}</span><button class="remove px-2 py-1 text-xs rounded">🗑</button></div>`;
  html += `<form class="unimod-form grid grid-cols-2 gap-3">`;
  (mod.fields || []).forEach(field => {
    const colSpan = field.width === 2 ? 'col-span-2' : 'col-span-1';
    html += `<label class="${colSpan} text-sm flex flex-col gap-1"><span class="font-medium">${field.label || field.key}</span>`;
    if (field.type === 'textarea') {
      html += `<textarea name="${field.key}" class="w-full text-black p-1 rounded"></textarea>`;
    } else if (field.type === 'select') {
      html += `<select name="${field.key}" class="w-full text-black p-1 rounded">` + (field.options || []).map(o => `<option>${o}</option>`).join('') + `</select>`;
    } else {
      html += `<input type="${field.type || 'text'}" name="${field.key}" class="w-full text-black p-1 rounded" />`;
    }
    html += `</label>`;
  });
  html += `</form>`;
  if (mod.actions?.length) {
    html += `<div class="mt-2 flex flex-wrap gap-2">` + mod.actions.map((a,i) => `<button type="button" class="action-btn bg-indigo-500 hover:bg-indigo-600 text-white px-3 py-1 rounded text-sm" data-i="${i}">${a.label}</button>`).join('') + `</div>`;
  }
  html += `</div>`;
  el.innerHTML = html;
  el.dataset.subdir = modObj.subdir;
  el.dataset.modType = 'fields';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  const widgetOptions = {
    ...(finalPos || { x:0,y:0,w:defaultW,h:defaultH }),
    minW: mod.minW || 1,
    minH: mod.minH || 1,
    maxW: mod.maxW || finalPos.w,
    maxH: mod.maxH || finalPos.h
  };
  gridInstance.addWidget(el, widgetOptions);
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabIndex);
    updateGridDraggable();
  };
  if (mod.actions?.length) {
    el.querySelectorAll('.action-btn').forEach(btn => {
      btn.onclick = () => {
        const i = Number(btn.dataset.i);
        const script = mod.actions[i].script;
        if (!script) return;
        runInlineScript(script, el.querySelector('form'), { modulename: mod.name || modObj.subdir });
      };
    });
  }
  // Apply fade-in animation to new universal module
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabIndex);
  updateGridDraggable();
}

/** Run script for universal module */
function runInlineScript(script, formEl, context) {
  const fields = {};
  Array.from(formEl.elements).forEach(el => { if (el.name) fields[el.name] = el; });
  const helpers = {
    exportAsCSV: fields => {
      const row = Object.values(fields).map(f => (f && f.value || '')).join(';');
      const blob = new Blob([row], { type:'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (context.modulename || 'modul') + '.csv';
      a.click();
    }
  };
  const fn = new Function('fields','context',...Object.keys(helpers), script);
  try { fn(fields, context, ...Object.values(helpers)); } catch (e) { console.error(e); alert('Script-Fehler.'); }
}

/** Create simple module */
function createSimpleModule(title, pos, gridInstance, tabIndex, subdir, instanceIdArg) {
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  const w = (pos && pos.w) || 4;
  const h = (pos && pos.h) || 2;
  el.innerHTML = `<div class="grid-stack-item-content relative">
  <button class="remove gs-remove px-2 py-1 text-xs rounded">🗑</button>
  <div class="text-sm opacity-80">Kein Script/Fields definiert.</div>
  </div>`;
  el.dataset.subdir = subdir || title;
  el.dataset.modType = 'simple';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  gridInstance.addWidget(el, pos || { x:0, y:0, w, h });
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabIndex);
    updateGridDraggable();
  };
  // Apply fade-in animation to new simple module
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabIndex);
  updateGridDraggable();
}
  </script>
</body>
</html>
