<!-- Version: 3.6.10 -->
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Shopguide V3</title>
  <meta id="viewport-meta" name="viewport" content="initial-scale=1.0" />
  <script>
    (function(meta){ if(!meta) return; var parts=['de','vice-width']; meta.setAttribute('content','width='+parts.join('')+', initial-scale=1.0'); })(document.getElementById('viewport-meta'));
  </script>
  <!-- Tailwind for easy styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- GridStack styles and scripts -->
  <link href="https://cdn.jsdelivr.net/npm/gridstack@9.2.2/dist/gridstack.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/gridstack@9.2.2/dist/gridstack-all.js"></script>
  <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
  <script src="https://code.jquery.com/ui/1.14.1/jquery-ui.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>

  <link rel="stylesheet" href="https://code.jquery.com/ui/1.14.1/themes/base/jquery-ui.css">
  <style>
    :root {
      /* General colours */
      --app-bg: #f3f4f6;
      --sidebar-bg: #f3f4f6;
      --sidebar-text: #1f2937;
      --top-bar-bg: #ffffff;
      --button-bg: #2563eb;
      --button-text: #ffffff;
      --border-color: #e5e7eb;
      /* Module colours */
      --module-bg: #005983;
      --text-color: #ffffff;
      --module-border-radius: 1.25rem;
      --module-header-bg: rgba(255,255,255,0.08);
      --module-header-text: #ffffff;
      /* Module border */
      --module-border-color: #e5e7eb;
      --danger-bg: #ef4444;
      --danger-text: #ffffff;
      /* Scrollbar styling */
      --scrollbar-thumb: rgba(15,23,42,0.35);
      --scrollbar-thumb-hover: rgba(15,23,42,0.55);
      --scrollbar-track: transparent;
      --scrollbar-thumb-inverse: rgba(255,255,255,0.5);
      --scrollbar-thumb-inverse-hover: rgba(255,255,255,0.7);
      /* Tabs colours */
      --tab-active-bg: #2563eb;
      --tab-active-text: #ffffff;
      --tab-inactive-bg: #e5e7eb;
      --tab-inactive-text: #1f2937;
      /* Grid hint */
      --grid-hint: #60a5fa;

      /* Sidebar module card colours */
      --sidebar-module-card-bg: #ffffff;
      --sidebar-module-card-text: #1f2937;
      --sidebar-module-card-border: #e5e7eb;

      /* Attachment text colour for module cards */
      --sidebar-module-card-attachment-color: #6B7280;

      /* Body text colour (used for general text; separate from sidebar text) */
      --body-text: #1f2937;
    }

    html, body { height: 100%; }
    body { margin: 0; background: var(--app-bg); color: var(--body-text); }
    /* Global modern scrollbar styling */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
    }
    *::-webkit-scrollbar {
      width: 0.55rem;
      height: 0.55rem;
    }
    *::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
    }
    *::-webkit-scrollbar-thumb {
      background-color: var(--scrollbar-thumb);
      border-radius: 9999px;
      border: 2px solid transparent;
      background-clip: padding-box;
    }
    *::-webkit-scrollbar-thumb:hover {
      background-color: var(--scrollbar-thumb-hover);
    }
    /* module contents */
    .grid-stack-item-content {
      background: var(--module-bg);
      border-radius: var(--module-border-radius);
      color: var(--text-color);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      min-height: 10px;
      /* apply border using module border colour */
      border: 1px solid var(--module-border-color);
      overflow: auto;
      scrollbar-color: var(--scrollbar-thumb-inverse) transparent;
    }
    .grid-stack-item-content::-webkit-scrollbar-thumb {
      background-color: var(--scrollbar-thumb-inverse);
    }
    .grid-stack-item-content::-webkit-scrollbar-thumb:hover {
      background-color: var(--scrollbar-thumb-inverse-hover);
    }
    .drag-handle {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:.5rem;
      cursor: move;
      background: var(--module-header-bg);
      color: var(--module-header-text);
      border-radius: calc(var(--module-border-radius) - 0.25rem);
      padding: .25rem .5rem;
    }
    .module-card.dragging { opacity: 0.5; }
    .grid-drop-hint { outline: 2px dashed var(--grid-hint); outline-offset: -6px; }
    .module-card {
      -webkit-user-drag: element;
      user-select: none;
      /* use CSS variables for sidebar module appearance */
      background-color: var(--sidebar-module-card-bg);
      color: var(--sidebar-module-card-text);
      border: 1px solid var(--sidebar-module-card-border);
    }
    /* Sidebar collapsed state */
    #sidebar.collapsed { width: 2.5rem !important; min-width: 2.5rem !important; padding-left: 0; padding-right: 0; }
    #sidebar.collapsed .list-content { display: none; }
    #sidebar.collapsed .collapse-icon { transform: rotate(180deg); }
    #sidebar.collapsed .module-card { pointer-events: none; }
    #sidebar.collapsed #module-list { pointer-events: none; }
    #module-search {
      background-color: var(--sidebar-module-card-bg);
      color: var(--sidebar-module-card-text);
    }
    #save-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }
    /* Topbar, sidebar and buttons use variables */
    #top-bar { background-color: var(--top-bar-bg) !important; border-bottom: 1px solid var(--border-color) !important; }
    #sidebar { background-color: var(--sidebar-bg) !important; border-right: 1px solid var(--border-color) !important; color: var(--sidebar-text); overflow-y: auto; }
    #select-root { background-color: var(--button-bg) !important; color: var(--button-text) !important; }
    button.remove { background-color: var(--danger-bg) !important; color: var(--danger-text) !important; }
    /* Tabs */
    .tab-item { user-select: none; }
    .tab-active { background: var(--tab-active-bg); color: var(--tab-active-text); }
    .tab-inactive { background: var(--tab-inactive-bg); color: var(--tab-inactive-text); }
    /* Settings Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 50;
    }
    .modal {
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-radius: 0.75rem;
      padding: 1.5rem;
      width: 95%;
      max-width: 1200px;  /* vorher 860px */
      max-height: 90vh;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      color: var(--body-text);
    }
    .settings-content {
      overflow-y: auto;
      flex: 1;
    }
    .updates-table-container {
      max-height: 50vh;
      overflow-y: auto;
    }
    .update-settings-row {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 0.75rem 1.25rem;
    }
    .update-settings-row .update-folder-info {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem 0.75rem;
      flex: 1 1 320px;
    }
    .update-controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem 1.25rem;
      flex: 1 1 320px;
    }
    .update-toggle {
      position: relative;
      display: inline-flex;
      align-items: center;
      cursor: pointer;
    }
    .update-toggle input {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      white-space: nowrap;
      border: 0;
    }
    .update-toggle-track {
      width: 2.75rem;
      height: 1.5rem;
      background-color: #d1d5db;
      border-radius: 9999px;
      transition: background-color 0.2s ease;
    }
    .update-toggle-thumb {
      position: absolute;
      left: 0.25rem;
      top: 0.25rem;
      width: 1rem;
      height: 1rem;
      border-radius: 9999px;
      background-color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      transition: transform 0.2s ease;
    }
    .update-toggle-stack {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem 1.25rem;
      flex: 1 1 auto;
      min-width: 260px;
    }
    .update-toggle-group {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    .update-toggle-label {
      font-weight: 500;
      color: #374151;
    }
    .update-all-container {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      flex: 0 0 auto;
      margin-left: auto;
    }
    .update-all-container.hidden {
      display: none;
    }
    .update-toggle input:checked + .update-toggle-track {
      background-color: #2563eb;
    }
    .update-toggle input:checked + .update-toggle-track + .update-toggle-thumb {
      transform: translateX(1.25rem);
    }
    .version-overview-grid {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 5rem 5rem 8rem;
      column-gap: 1.5rem;
      row-gap: 0.5rem;
      align-items: center;
    }
    .version-overview-header {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
    }
    .version-overview-name {
      font-weight: 500;
      color: #374151;
    }
    .version-overview-value {
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: #4b5563;
    }
    .version-overview-action {
      display: flex;
      justify-content: flex-end;
      align-items: center;
    }
    .version-overview-action .version-overview-button {
      background-color: #ffffff;
      border: 1px solid #d1d5db;
      color: #374151;
      font-size: 0.75rem;
      padding: 0.25rem 0.75rem;
      border-radius: 0.375rem;
      transition: background-color 0.2s ease;
    }
    .version-overview-action .version-overview-button:hover {
      background-color: #f3f4f6;
    }
    .version-overview-empty {
      grid-column: 1 / -1;
      color: #6b7280;
      font-style: italic;
    }
    .settings-nav button {
      border-radius: .5rem;
      padding: .5rem .75rem;
    }
    .settings-nav button.active { background: #e5e7eb; }
    .settings-section { display: none; }
    .settings-section.active { display: block; }
    .field-grid {
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: .75rem;
    }
    @media (max-width: 640px){ .field-grid { grid-template-columns: 1fr; } }
    .form-field label { font-size:.875rem; font-weight:600; }

    .module-layer-manager {
      background: #f9fafb;
      border: 1px solid var(--border-color);
      border-radius: 0.75rem;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }
    .module-layer-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .module-layer-title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0;
    }
    .module-layer-subtitle {
      font-size: 0.8125rem;
      color: #4b5563;
      margin: 0.25rem 0 0;
    }
    .module-layer-add {
      background: #2563eb;
      color: #ffffff;
      border: none;
      border-radius: 0.5rem;
      padding: 0.5rem 0.9rem;
      font-weight: 600;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .module-layer-add:hover:not(:disabled) {
      background: #1d4ed8;
      transform: translateY(-1px);
    }
    .module-layer-add:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .module-color-layer {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem 1.25rem;
      padding: 1.1rem;
      background: #ffffff;
      border: 1px solid var(--border-color);
      border-radius: 0.75rem;
      box-shadow: 0 1px 2px rgba(15,23,42,0.08);
    }
    .module-color-preview {
      flex: 0 0 320px;
      max-width: 420px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .module-preview-card {
      width: 100%;
      border-radius: 1rem;
      padding: 1.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.16);
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .module-layer-badge {
      align-self: flex-start;
      padding: 0.3rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.72rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      background: rgba(255,255,255,0.85);
      color: #1f2937;
      border: 1px solid transparent;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .module-preview-topbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
    }
    .module-preview-layout {
      display: grid;
      gap: 0.85rem;
      grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.2fr) minmax(0, 1fr);
      align-items: stretch;
    }
    .module-preview-stack {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .module-preview-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.8rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      background: rgba(255,255,255,0.15);
      color: inherit;
      border: 1px solid transparent;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .module-preview-cluster {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      padding: 0.75rem;
      border-radius: 0.9rem;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .module-preview-cluster--dual {
      gap: 0.65rem;
    }
    .module-preview-bubble {
      align-self: flex-start;
      padding: 0.4rem 0.85rem;
      border-radius: 9999px;
      font-weight: 600;
      font-size: 0.78rem;
      letter-spacing: 0.03em;
      background: rgba(255,255,255,0.12);
      color: inherit;
      border: 1px solid transparent;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .module-preview-field {
      border-radius: 0.75rem;
      padding: 0.55rem 0.8rem;
      font-size: 0.76rem;
      line-height: 1.35;
      background: rgba(255,255,255,0.1);
      color: inherit;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08);
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .module-preview-surface {
      border-radius: 0.9rem;
      border: 1px solid rgba(255,255,255,0.14);
      padding: 0.9rem;
      background: rgba(255,255,255,0.08);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-weight: 500;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }
    .module-preview-surface > span {
      display: block;
    }
    .module-preview-surface--main {
      min-height: 132px;
      font-size: 0.82rem;
      line-height: 1.45;
      justify-content: center;
    }
    .module-preview-surface--meta {
      min-height: 132px;
      font-size: 0.78rem;
      line-height: 1.4;
    }
    .module-preview-surface-line {
      font-size: 0.72rem;
      font-weight: 500;
      opacity: 0.9;
    }
    .module-preview-field-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
    }
    .module-preview-field--mini {
      text-align: center;
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.03em;
    }
    @media (max-width: 1024px) {
      .module-preview-layout {
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        grid-auto-rows: 1fr;
      }
      .module-preview-stack {
        grid-column: 1 / span 2;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 0.6rem;
      }
      .module-preview-stack .module-preview-cluster {
        flex: 1 1 200px;
      }
    }
    @media (max-width: 720px) {
      .module-preview-layout {
        grid-template-columns: 1fr;
      }
      .module-preview-stack {
        grid-column: auto;
        flex-direction: column;
      }
      .module-preview-surface--main,
      .module-preview-surface--meta {
        min-height: auto;
      }
      .module-color-preview {
        flex: 1 1 100%;
        max-width: none;
      }
    }
    .module-layer-controls {
      flex: 1 1 260px;
      min-width: 220px;
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
    }
    .module-layer-name-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .module-layer-name-field label {
      font-size: 0.8125rem;
      font-weight: 600;
      color: #1f2937;
    }
    .module-layer-groups {
      display: grid;
      gap: 0.75rem;
    }
    .module-layer-group {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      padding: 0.75rem;
      border-radius: 0.75rem;
      background: #f9fafb;
      border: 1px solid var(--border-color);
    }
    .module-layer-group-title {
      font-size: 0.8125rem;
      font-weight: 600;
      color: #111827;
    }
    .module-layer-group-grid {
      display: grid;
      gap: 0.5rem;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
    }
    .module-layer-color {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: #4b5563;
    }
    .module-layer-color input[type="color"] {
      width: 100%;
      height: 2.25rem;
      padding: 0.15rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border-color);
      cursor: pointer;
    }
    .module-layer-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .module-layer-actions button {
      border: 1px solid var(--border-color);
      background: #f3f4f6;
      border-radius: 0.5rem;
      padding: 0.4rem 0.85rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: #1f2937;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .module-layer-actions button:hover:not(:disabled) {
      background: #e5e7eb;
    }
    .module-layer-actions button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .module-layer-hint {
      font-size: 0.75rem;
      color: #6b7280;
    }
    @media (max-width: 768px) {
      .module-color-preview {
        flex: 1 1 100%;
        max-width: none;
      }
      .module-preview-card {
        max-width: 320px;
        margin: 0 auto;
      }
    }

    /* Simple fade-in animation for startup and loading */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .fade-in {
      animation: fadeIn 0.5s ease-out;
    }

    /* Attachment text style in sidebar module cards */
    #module-list .sidebar-module-attachment {
      color: var(--sidebar-module-card-attachment-color);
      font-size: 0.75rem;
    }

    /* Ensure module names in the sidebar wrap rather than truncate */
    #module-list .module-card .font-semibold {
      word-break: break-word;
      white-space: normal;
    }
    .gs-remove {
      position: absolute;
      top: .35rem;
      right: .35rem;
    }

    .changelog-overlay {
      position: fixed;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      background: rgba(0,0,0,0.45);
      z-index: 60;
    }

    .changelog-overlay.open {
      display: flex;
    }

    .changelog-modal {
      position: relative;
      width: min(720px, 100%);
      max-height: 85vh;
      background: #ffffff;
      color: var(--body-text);
      border-radius: 0.75rem;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .changelog-header {
      padding: 1rem 1.25rem 0.75rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .changelog-controls {
      padding: 0.75rem 1.25rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      background: #f9fafb;
    }

    .changelog-controls.hidden {
      display: none;
    }

    .changelog-controls label {
      font-size: 0.85rem;
      color: #4b5563;
    }

    .changelog-select {
      flex: 1 1 220px;
      min-width: 180px;
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid #d1d5db;
      background: #ffffff;
      color: inherit;
    }

    .changelog-controls button {
      background: #2563eb;
      color: #ffffff;
      border: none;
      border-radius: 0.5rem;
      padding: 0.35rem 0.85rem;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background-color 0.15s ease;
    }

    .changelog-controls button:hover {
      background: #1d4ed8;
    }

    .changelog-controls button:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }

    .changelog-title {
      font-size: 1.15rem;
      font-weight: 600;
    }

    .changelog-subtitle {
      font-size: 0.85rem;
      color: #6b7280;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .changelog-body {
      padding: 1rem 1.25rem;
      overflow-y: auto;
    }

    .changelog-section + .changelog-section {
      margin-top: 1.5rem;
    }

    .changelog-section h3 {
      margin: 0 0 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      color: var(--body-text);
    }

    .changelog-pre {
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
      font-size: 0.875rem;
      line-height: 1.4;
      font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 0.75rem;
      color: #1f2937;
    }

    .changelog-empty {
      font-size: 0.9rem;
      color: #6b7280;
    }

    .changelog-loading {
      font-size: 0.9rem;
      color: #374151;
    }

    .changelog-error {
      color: var(--danger-bg);
      font-weight: 500;
      font-size: 0.95rem;
    }

    .changelog-close {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      border: none;
      background: transparent;
      font-size: 1.5rem;
      line-height: 1;
      color: #6b7280;
      cursor: pointer;
    }

    .changelog-close:hover {
      color: #111827;
    }
  </style>
  <style id="custom-styles"></style>
</head>
<body>
  <!-- Top bar with tabs and buttons -->
  <header id="top-bar" class="flex items-center gap-1 px-3 py-2 shadow" style="height:40px">
    <div id="tabs-container" class="flex items-center gap-1 flex-wrap"></div>
    <button id="add-tab" title="Neuen Tab erstellen" class="text-xl px-2 py-1 leading-none hover:opacity-80">➕</button>
    <div class="ml-auto flex items-center gap-2">
      <div id="history-menu" class="relative">
        <button
          id="history-menu-toggle"
          type="button"
          class="flex items-center justify-center w-9 h-9 rounded-full border border-gray-300 bg-white text-gray-600 shadow-sm hover:text-gray-900 hover:bg-gray-100 transition focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-haspopup="true"
          aria-expanded="false"
          aria-controls="history-menu-dropdown"
          title="Verlauf"
        >
          <span class="sr-only">Verlauf öffnen</span>
          <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M12 8v4l2.5 2.5" />
            <path d="M21 12a9 9 0 11-9-9" />
            <path d="M7 3L3 7" />
            <path d="M3 7h4" />
          </svg>
        </button>
        <div
          id="history-menu-dropdown"
          class="absolute right-0 mt-2 w-48 bg-white border border-gray-200 rounded-xl shadow-lg py-2 hidden z-50"
          role="menu"
          aria-labelledby="history-menu-toggle"
        >
          <button id="undo-action" type="button" role="menuitem" class="history-menu-item flex items-center gap-2 w-full text-left text-sm px-3 py-2 text-gray-700 hover:bg-gray-100 transition" disabled>
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <path d="M9 15L3 9l6-6" />
              <path d="M3 9h12a6 6 0 010 12h-3" />
            </svg>
            <span>Rückgängig</span>
          </button>
          <button id="redo-action" type="button" role="menuitem" class="history-menu-item flex items-center gap-2 w-full text-left text-sm px-3 py-2 text-gray-700 hover:bg-gray-100 transition" disabled>
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <path d="M15 9l6 6-6 6" />
              <path d="M21 15H9a6 6 0 010-12h3" />
            </svg>
            <span>Wiederholen</span>
          </button>
        </div>
      </div>
      <button id="update-status" class="text-sm px-3 py-1 rounded hidden">Update prüfen</button>
      <button id="select-root" class="text-sm px-3 py-1 rounded">Ordner wählen</button>
      <button id="open-settings" title="Einstellungen" class="bg-gray-300 hover:bg-gray-400 text-gray-800 text-sm px-3 py-1 rounded">⚙️</button>
      <span id="save-indicator" class="bg-green-500" title="Gespeichert"></span>
    </div>
  </header>
  <div class="flex" style="height: calc(100% - 40px);">
    <aside id="sidebar" class="w-72 min-h-full p-3 relative transition-all duration-300 ease-in-out">
      <button id="sidebar-toggle" class="absolute top-2 right-2 text-xl collapse-icon" title="Liste ein-/ausblenden">⬅️</button>
      <h2 class="font-semibold mb-2 list-content">Module</h2>
      <div class="list-content mb-3">
        <div class="flex items-center gap-2">
          <input id="module-search" type="text" placeholder="Module suchen…" class="w-full text-sm border border-gray-300 rounded px-2 py-1" />
          <button id="module-search-clear" type="button" class="text-lg px-2 py-1 hidden" title="Suche löschen">❌</button>
        </div>
      </div>
      <div id="module-list" class="list-content flex flex-col gap-2 text-sm">
        <div class="text-gray-400">Wähle oben einen Ordner…</div>
      </div>
    </aside>
    <main class="flex-1 min-h-full overflow-auto">
      <div id="grids" class="relative w-full h-full"></div>
    </main>
  </div>
  <input type="file" id="folder-input" webkitdirectory directory multiple hidden />
  <!-- Settings Modal -->
  <div id="settings-modal" class="modal-overlay hidden">
    <div class="modal">
      <div class="flex items-center justify-between mb-4">
        <h2 class="text-lg font-semibold">Einstellungen</h2>
        <button
          id="close-settings"
          type="button"
          class="flex h-9 w-9 items-center justify-center rounded-full text-gray-400 transition hover:bg-gray-100 hover:text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-label="Einstellungen schließen"
        >
          <svg class="w-4 h-4" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M4 4l8 8M12 4l-8 8" />
          </svg>
        </button>
      </div>
      <div class="settings-nav flex gap-2 mb-3">
        <button data-section="general" class="active">Allgemein</button>
        <button data-section="topbar">Topbar</button>
        <button data-section="sidebar">Sidebar</button>
        <button data-section="modules">Module</button>
        <button data-section="updates">Updates</button>
      </div>
      <div class="settings-content mt-1 pr-1">
        <!-- Allgemein section -->
        <div id="section-general" class="settings-section active">
          <div class="field-grid">
            <div class="form-field">
              <label>App Hintergrundfarbe</label>
              <input type="color" id="setting-app-bg" value="#f3f4f6" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Border Farbe</label>
            <input type="color" id="setting-border-color" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Primäre Buttonfarbe</label>
            <input type="color" id="setting-button-bg" value="#2563eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Primäre Buttontextfarbe</label>
            <input type="color" id="setting-button-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field col-span-2">
            <div class="flex items-center justify-between gap-4">
              <div>
                <label for="setting-grid-auto-arrange">Automatisches Nachrücken</label>
                <p class="text-xs text-gray-500">Module rücken Lücken automatisch nach oben, wenn diese Option aktiv ist.</p>
              </div>
              <label for="setting-grid-auto-arrange" class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="setting-grid-auto-arrange" class="sr-only peer">
                <div class="w-11 h-6 bg-gray-300 rounded-full transition peer-focus:ring-2 peer-focus:ring-blue-300 peer-checked:bg-blue-600"></div>
                <span class="absolute left-1 top-1 h-4 w-4 rounded-full bg-white transition-transform peer-checked:translate-x-5"></span>
              </label>
            </div>
          </div>
        </div>
      </div>
        <!-- Topbar section -->
        <div id="section-topbar" class="settings-section">
          <div class="field-grid">
            <div class="form-field">
              <label>Topbar Hintergrundfarbe</label>
              <input type="color" id="setting-topbar-bg" value="#ffffff" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Aktiver Tab Hintergrund</label>
            <input type="color" id="setting-tab-active-bg" value="#2563eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Aktiver Tab Text</label>
            <input type="color" id="setting-tab-active-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Inaktiver Tab Hintergrund</label>
            <input type="color" id="setting-tab-inactive-bg" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Inaktiver Tab Text</label>
            <input type="color" id="setting-tab-inactive-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
        <!-- Sidebar section -->
        <div id="section-sidebar" class="settings-section">
          <div class="field-grid">
            <div class="form-field">
              <label>Sidebar Hintergrundfarbe</label>
              <input type="color" id="setting-sidebar-bg" value="#f3f4f6" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Sidebar Textfarbe</label>
            <input type="color" id="setting-sidebar-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Drag &amp; Drop Hinweisfarbe</label>
            <input type="color" id="setting-grid-hint" value="#60a5fa" class="w-full border rounded p-1">
          </div>
          <!-- New sidebar module card settings -->
          <div class="form-field">
            <label>Sidebar Modul Hintergrundfarbe</label>
            <input type="color" id="setting-sidebar-module-bg" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Sidebar Modul Textfarbe</label>
            <input type="color" id="setting-sidebar-module-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Sidebar Modul Rahmenfarbe</label>
            <input type="color" id="setting-sidebar-module-border" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
        <!-- Modules section -->
        <div id="section-modules" class="settings-section">
          <div class="space-y-6">
            <div class="field-grid">
              <div class="form-field">
                <label>Modul Hintergrundfarbe</label>
                <input type="color" id="setting-module-bg" value="#005983" class="w-full border rounded p-1">
              </div>
              <div class="form-field">
                <label>Modul Textfarbe</label>
                <input type="color" id="setting-text-color" value="#ffffff" class="w-full border rounded p-1">
              </div>
              <div class="form-field">
                <label>Modul Rundung (px)</label>
                <input type="number" id="setting-border-radius" value="20" class="w-full border rounded p-1" min="0">
              </div>
              <div class="form-field">
                <label>Modul Kopfzeile Hintergrund</label>
                <input type="color" id="setting-module-header-bg" value="#0a0a0a" class="w-full border rounded p-1">
              </div>
              <div class="form-field">
                <label>Modul Kopfzeile Textfarbe</label>
                <input type="color" id="setting-module-header-text" value="#ffffff" class="w-full border rounded p-1">
              </div>
              <div class="form-field">
                <label>Löschen-Button Hintergrundfarbe</label>
                <input type="color" id="setting-danger-bg" value="#ef4444" class="w-full border rounded p-1">
              </div>
              <div class="form-field">
                <label>Löschen-Button Textfarbe</label>
                <input type="color" id="setting-danger-text" value="#ffffff" class="w-full border rounded p-1">
              </div>
              <div class="form-field">
                <label>Modul Rahmenfarbe</label>
                <input type="color" id="setting-module-border-color" value="#e5e7eb" class="w-full border rounded p-1">
              </div>
            </div>
            <div class="module-layer-manager">
              <div class="module-layer-header">
                <div>
                  <h3 class="module-layer-title">Farb-Layer für Module</h3>
                  <p class="module-layer-subtitle">Definiere kombinierbare Farbsets für Modulflächen, Überschrift-Bubbles und Unterelemente.</p>
                </div>
                <button id="add-module-color-layer" type="button" class="module-layer-add">Layer hinzufügen</button>
              </div>
              <div id="module-color-layers" class="module-color-layers space-y-3"></div>
              <p class="module-layer-hint">Bis zu 8 Layer möglich. Die Farbkombinationen kannst du später in Modulen über ein Dropdown auswählen.</p>
            </div>
          </div>
        </div>
        <div id="section-updates" class="settings-section">
          <div class="space-y-4">
            <div class="text-sm space-y-2">
              <div class="update-settings-row">
                <div class="update-folder-info">
                  <span class="font-medium">Update-Ordner:</span>
                  <span id="update-folder-name" class="px-2 py-1 bg-gray-100 rounded">Keiner gewählt</span>
                  <button id="select-update-folder" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded">Ordner wählen</button>
                  <button id="clear-update-folder" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded">Zurücksetzen</button>
                  <span id="update-check-status" class="text-gray-500"></span>
                </div>
                <div class="update-controls">
                  <div class="update-toggle-stack">
                    <div class="update-toggle-group">
                      <span class="update-toggle-label text-sm text-gray-700 select-none">Update-Hinweis anzeigen</span>
                      <label class="update-toggle" title="Update-Hinweis im Hauptfenster anzeigen">
                        <span class="sr-only">Update-Hinweis im Hauptfenster anzeigen</span>
                        <input type="checkbox" id="setting-show-update-button">
                        <span class="update-toggle-track"></span>
                        <span class="update-toggle-thumb"></span>
                      </label>
                    </div>
                    <div class="update-toggle-group">
                      <span class="update-toggle-label text-sm text-gray-700 select-none">Automatisch nach Updates suchen</span>
                      <label class="update-toggle" title="Automatische Update-Prüfung alle 5 Sekunden durchführen">
                        <span class="sr-only">Automatische Update-Prüfung aktivieren</span>
                        <input type="checkbox" id="setting-update-auto-poll">
                        <span class="update-toggle-track"></span>
                        <span class="update-toggle-thumb"></span>
                      </label>
                    </div>
                    <div class="update-toggle-group">
                      <span class="update-toggle-label text-sm text-gray-700 select-none">Downgrade-Hinweis ausblenden</span>
                      <label class="update-toggle" title="Downgrade-Benachrichtigung im Hauptfenster ausblenden">
                        <span class="sr-only">Downgrade-Hinweis im Hauptfenster ausblenden</span>
                        <input type="checkbox" id="setting-hide-downgrade-button">
                        <span class="update-toggle-track"></span>
                        <span class="update-toggle-thumb"></span>
                      </label>
                    </div>
                  </div>
                  <div id="update-all-container" class="update-all-container hidden">
                    <button id="update-all" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded">Alle aktualisieren</button>
                  </div>
                </div>
              </div>
            </div>
            <div id="updates-empty-state" class="text-sm text-gray-500">Keine Updates erforderlich.</div>
            <div class="updates-table-container overflow-x-auto">
              <table class="min-w-full text-sm border border-gray-200 rounded" id="updates-table">
                <thead class="bg-gray-100">
                  <tr>
                    <th class="text-left px-3 py-2">Datei</th>
                    <th class="text-left px-3 py-2">Version</th>
                    <th class="text-right px-3 py-2">Aktion</th>
                  </tr>
                </thead>
                <tbody id="updates-table-body"></tbody>
              </table>
            </div>
            <div id="downgrade-section" class="border border-gray-200 rounded hidden">
              <button id="downgrade-toggle" type="button" class="w-full flex items-center justify-between px-3 py-2 text-sm font-semibold text-left">
                <span id="downgrade-heading">Downgrades (0)</span>
                <span id="downgrade-toggle-icon" class="text-xs">▼</span>
              </button>
              <div id="downgrade-content" class="hidden border-t border-gray-200">
                <table class="min-w-full text-sm">
                  <thead class="bg-yellow-200 text-yellow-900">
                    <tr>
                      <th class="text-left px-3 py-2">Datei</th>
                      <th class="text-left px-3 py-2">Version</th>
                      <th class="text-right px-3 py-2">Aktion</th>
                    </tr>
                  </thead>
                  <tbody id="downgrade-table-body"></tbody>
                </table>
              </div>
            </div>
            <div id="update-version-overview" class="border border-gray-200 rounded p-3 text-sm space-y-3">
              <div class="flex flex-wrap items-center justify-between gap-2">
                <div class="font-semibold text-gray-700">Versionsübersicht</div>
                <button id="show-latest-changelog" type="button" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-sm">
                  Neuester Changelog
                </button>
              </div>
              <div id="update-version-rows" class="version-overview-grid"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="changelog-modal" class="changelog-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="changelog-modal">
      <button id="close-changelog" class="changelog-close" type="button" aria-label="Changelog schließen">×</button>
      <div class="changelog-header">
        <div id="changelog-title" class="changelog-title">Changelog</div>
        <div id="changelog-subtitle" class="changelog-subtitle"></div>
      </div>
      <div id="changelog-controls" class="changelog-controls hidden">
        <label for="changelog-version-select">Version auswählen:</label>
        <select id="changelog-version-select" class="changelog-select"></select>
        <button id="changelog-show-full" type="button">Ganzen Changelog anzeigen</button>
      </div>
      <div id="changelog-body" class="changelog-body">
        <div class="changelog-loading">Lade Changelog…</div>
      </div>
    </div>
  </div>
  <script>
const MAX_MODULE_COLOR_LAYERS = 8;

function generateLayerId() {
  return 'layer-' + Math.random().toString(36).slice(2, 10);
}

function hexToRgba(color, alpha = 1) {
  if (typeof color !== 'string') return '';
  const hex = color.trim();
  const match = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.exec(hex);
  if (!match) return '';
  const normalized = match[1].length === 3
    ? match[1].split('').map(ch => ch + ch).join('')
    : match[1];
  const intVal = parseInt(normalized, 16);
  const r = (intVal >> 16) & 255;
  const g = (intVal >> 8) & 255;
  const b = intVal & 255;
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function createColorLayer(
  name,
  moduleBg,
  moduleText,
  moduleBorder,
  headerBg,
  headerText,
  headerBorder,
  subBg,
  subText,
  subBorder
) {
  return {
    id: generateLayerId(),
    name,
    moduleBg,
    moduleText,
    moduleBorder,
    headerBg,
    headerText,
    headerBorder,
    subBg,
    subText,
    subBorder
  };
}

function getDefaultModuleColorLayers() {
  return [
    createColorLayer('Layer 1', '#005983', '#ffffff', '#0f6ab4', '#0f6ab4', '#ffffff', '#0a487a', '#07365b', '#ffffff', '#052b47'),
    createColorLayer('Layer 2', '#1d4ed8', '#ffffff', '#3b82f6', '#2563eb', '#ffffff', '#1d4ed8', '#1e3a8a', '#ffffff', '#172554'),
    createColorLayer('Layer 3', '#047857', '#ffffff', '#10b981', '#059669', '#ffffff', '#047857', '#064e3b', '#ffffff', '#022c22'),
    createColorLayer('Layer 4', '#7c3aed', '#ffffff', '#a855f7', '#8b5cf6', '#ffffff', '#6d28d9', '#5b21b6', '#ffffff', '#3c0d99')
  ];
}

function normalizeModuleColorLayers(layers) {
  const source = Array.isArray(layers) && layers.length ? layers : getDefaultModuleColorLayers();
  return source
    .slice(0, MAX_MODULE_COLOR_LAYERS)
    .map((layer, index) => ({
      id: typeof layer.id === 'string' && layer.id.trim() ? layer.id : generateLayerId(),
      name: typeof layer.name === 'string' ? layer.name : `Layer ${index + 1}`,
      moduleBg: typeof layer.moduleBg === 'string' && layer.moduleBg ? layer.moduleBg : '#005983',
      moduleText: typeof layer.moduleText === 'string' && layer.moduleText ? layer.moduleText : '#ffffff',
      moduleBorder: typeof layer.moduleBorder === 'string' && layer.moduleBorder ? layer.moduleBorder : (typeof layer.moduleText === 'string' && layer.moduleText ? layer.moduleText : '#ffffff'),
      headerBg: typeof layer.headerBg === 'string' && layer.headerBg ? layer.headerBg : (typeof layer.moduleBg === 'string' && layer.moduleBg ? layer.moduleBg : '#2563eb'),
      headerText: typeof layer.headerText === 'string' && layer.headerText ? layer.headerText : '#ffffff',
      headerBorder: typeof layer.headerBorder === 'string' && layer.headerBorder ? layer.headerBorder : (typeof layer.headerBg === 'string' && layer.headerBg ? layer.headerBg : '#2563eb'),
      subBg: typeof layer.subBg === 'string' && layer.subBg ? layer.subBg : (typeof layer.moduleBg === 'string' && layer.moduleBg ? layer.moduleBg : '#1f2937'),
      subText: typeof layer.subText === 'string' && layer.subText ? layer.subText : '#ffffff',
      subBorder: typeof layer.subBorder === 'string' && layer.subBorder ? layer.subBorder : (typeof layer.subBg === 'string' && layer.subBg ? layer.subBg : '#1f2937')
    }));
}

/*
 * Global settings object; defaults correspond to CSS variables defined above.
 * New properties for border colour and sidebar text are included.
 */
let appSettings = {
  appBgColor: '#f3f4f6',
  sidebarBg: '#f3f4f6',
  sidebarText: '#1f2937',
  topBarBg: '#ffffff',
  buttonBg: '#2563eb',
  buttonText: '#ffffff',
  borderColor: '#e5e7eb',
  autoArrangeModules: true,
  moduleBgColor: '#005983',
  textColor: '#ffffff',
  moduleBorderRadius: '1.25rem',
  moduleHeaderBg: 'rgba(255,255,255,0.08)',
  moduleHeaderText: '#ffffff',
  dangerBg: '#ef4444',
  dangerText: '#ffffff',
  tabActiveBg: '#2563eb',
  tabActiveText: '#ffffff',
  tabInactiveBg: '#e5e7eb',
  tabInactiveText: '#1f2937',
  gridHint: '#60a5fa',
  moduleBorderColor: '#e5e7eb',
  sidebarModuleCardBg: '#ffffff',
  sidebarModuleCardText: '#1f2937',
  sidebarModuleCardBorder: '#e5e7eb',
  showUpdateStatusButton: true,
  autoUpdatePolling: false,
  hideDowngradeStatusButton: false,
  moduleColorLayers: normalizeModuleColorLayers([])
};


const layoutFileName = 'layout.json';
const settingsFileName = 'settings.json';
const HTML_FILE_NAME = 'ShopguideV3.html';
const HTML_CHANGELOG_FILE = 'ShopguideChangelog.txt';
const ACTIVE_TAB_STORAGE_KEY = 'modulesLayoutActiveTab';
let rootDirHandle = null;
let updateDirHandle = null;
let modulesDirHandle = null;
let liveModuleTemplates = [];
let tabs = [];
let activeTabIndex = 0;
let tabContextMenu = null;
let tabsSortable = null;
// Start with sidebar closed by default
let isSidebarOpen = false;
let pendingUpdates = [];
let updateCheckInProgress = false;
let currentUpgradeItems = [];
let currentDowngradeItems = [];
let updateStatusHasStableAppearance = false;
let updateStatusShouldRemainHidden = false;
let settingsSaveTimeoutId = null;
let historyMenuOpen = false;
let lastUpdateError = false;
let updatePollingIntervalId = null;
let versionOverview = {
  html: {
    type: 'html',
    displayName: HTML_FILE_NAME,
    name: HTML_FILE_NAME,
    localVersion: null,
    updateVersion: null,
    currentVersion: null,
    newVersion: null,
    localFileName: HTML_FILE_NAME,
    updateFileName: null,
    updateDirHandle: null,
    localDirHandle: null,
    changelogHandle: null,
    changelogFileName: HTML_CHANGELOG_FILE,
    changelogPath: HTML_CHANGELOG_FILE,
    changelogRelativePath: null
  },
  modules: []
};

if (typeof window !== 'undefined') {
  window.rootDirHandle = null;
  window.updateDirHandle = null;
}

function setGlobalHandle(type, handle) {
  if (typeof window === 'undefined') return;
  const prop = type === 'root' ? 'rootDirHandle' : 'updateDirHandle';
  window[prop] = handle || null;
  try {
    window.dispatchEvent(new CustomEvent(`shopguide:${type}-handle-changed`, {
      detail: { hasHandle: !!handle }
    }));
  } catch (err) {
    console.warn(`Konnte ${type}-Handle-Ereignis nicht senden`, err);
  }
}
let rerunUpdateCheckWhenUnlocked = false;
let changelogRequestToken = 0;
let lastChangelogTrigger = null;
let htmlUpdateChangelogHandle = null;
let htmlUpdateChangelogFileName = null;
let cachedHtmlChangelogSections = null;
let htmlChangelogSourceLabel = null;
let currentGlobalChangelogMode = 'single';
let currentGlobalChangelogIndex = 0;
let currentChangelogContext = 'none';
let moduleChangelogSections = null;
let moduleChangelogFilteredSections = null;
let moduleChangelogNotice = null;
let moduleChangelogShowFull = false;
let sidebarTreeData = [];
let sidebarSearchTerm = '';
let undoStack = [];
let redoStack = [];
let layoutRecordingSuppressCount = 0;
let saveIndicatorPending = 0;
let downgradeCollapsed = true;
let historyInProgress = false;

/* ==== UNIQUE IDs ==== */
let usedInstanceIds = new Set();
let nextModuleInstanceId = 1;
function generateInstanceId() {
  if (window.crypto?.randomUUID) {
    let id;
    do { id = 'mod-' + crypto.randomUUID(); }
    while (usedInstanceIds.has(id));
    usedInstanceIds.add(id);
    return id;
  }
  let id;
  do { id = 'mod-' + (nextModuleInstanceId++); }
  while (usedInstanceIds.has(id));
  usedInstanceIds.add(id);
  return id;
}

// Cache DOM elements
const moduleSearchInput = document.getElementById('module-search');
const moduleSearchClearBtn = document.getElementById('module-search-clear');
const listEl = document.getElementById('module-list');
const gridsContainer = document.getElementById('grids');
const tabsContainer = document.getElementById('tabs-container');
const addTabBtn = document.getElementById('add-tab');
const sidebarEl = document.getElementById('sidebar');
const sidebarToggle = document.getElementById('sidebar-toggle');
const undoBtn = document.getElementById('undo-action');
const redoBtn = document.getElementById('redo-action');
const historyMenu = document.getElementById('history-menu');
const historyMenuToggle = document.getElementById('history-menu-toggle');
const historyMenuDropdown = document.getElementById('history-menu-dropdown');
const updateStatusBtn = document.getElementById('update-status');
const rootBtn = document.getElementById('select-root');
const settingsBtn = document.getElementById('open-settings');
const settingsModal = document.getElementById('settings-modal');
const closeSettingsBtn = document.getElementById('close-settings');
const updateFolderNameEl = document.getElementById('update-folder-name');
const selectUpdateFolderBtn = document.getElementById('select-update-folder');
const clearUpdateFolderBtn = document.getElementById('clear-update-folder');
const updatesTableBody = document.getElementById('updates-table-body');
const updatesEmptyState = document.getElementById('updates-empty-state');
const updateCheckStatus = document.getElementById('update-check-status');
const versionOverviewContainer = document.getElementById('update-version-overview');
const versionOverviewRowsEl = document.getElementById('update-version-rows');
const changelogOverlay = document.getElementById('changelog-modal');
const changelogTitleEl = document.getElementById('changelog-title');
const changelogSubtitleEl = document.getElementById('changelog-subtitle');
const changelogBodyEl = document.getElementById('changelog-body');
const closeChangelogBtn = document.getElementById('close-changelog');
const showLatestChangelogBtn = document.getElementById('show-latest-changelog');
const changelogControlsEl = document.getElementById('changelog-controls');
const changelogVersionSelect = document.getElementById('changelog-version-select');
const changelogShowFullBtn = document.getElementById('changelog-show-full');
const changelogVersionLabel = changelogControlsEl?.querySelector('label[for="changelog-version-select"]') || null;
const updateAllContainer = document.getElementById('update-all-container');
const updateAllBtn = document.getElementById('update-all');
const saveIndicator = document.getElementById('save-indicator');
const downgradeSection = document.getElementById('downgrade-section');
const downgradeToggle = document.getElementById('downgrade-toggle');
const downgradeContent = document.getElementById('downgrade-content');
const downgradeTableBody = document.getElementById('downgrade-table-body');
const downgradeHeading = document.getElementById('downgrade-heading');
const downgradeToggleIcon = document.getElementById('downgrade-toggle-icon');
// Settings inputs
const inputAppBg = document.getElementById('setting-app-bg');
const inputBorderColor = document.getElementById('setting-border-color');
const inputButtonBg = document.getElementById('setting-button-bg');
const inputButtonText = document.getElementById('setting-button-text');
const inputTopBarBg = document.getElementById('setting-topbar-bg');
const inputTabActiveBg = document.getElementById('setting-tab-active-bg');
const inputTabActiveText = document.getElementById('setting-tab-active-text');
const inputTabInactiveBg = document.getElementById('setting-tab-inactive-bg');
const inputTabInactiveText = document.getElementById('setting-tab-inactive-text');
const inputSidebarBg = document.getElementById('setting-sidebar-bg');
const inputSidebarText = document.getElementById('setting-sidebar-text');
const inputGridHint = document.getElementById('setting-grid-hint');
const inputAutoArrange = document.getElementById('setting-grid-auto-arrange');
const inputModuleBg = document.getElementById('setting-module-bg');
const inputTextColor = document.getElementById('setting-text-color');
const inputBorderRadius = document.getElementById('setting-border-radius');
const inputModuleHeaderBg = document.getElementById('setting-module-header-bg');
const inputModuleHeaderText = document.getElementById('setting-module-header-text');
const inputDangerBg = document.getElementById('setting-danger-bg');
const inputDangerText = document.getElementById('setting-danger-text');

// New module border and sidebar module card inputs
const inputModuleBorderColor = document.getElementById('setting-module-border-color');
const inputSidebarModuleBg = document.getElementById('setting-sidebar-module-bg');
const inputSidebarModuleText = document.getElementById('setting-sidebar-module-text');
const inputSidebarModuleBorder = document.getElementById('setting-sidebar-module-border');
const moduleColorLayersContainer = document.getElementById('module-color-layers');
const addModuleColorLayerBtn = document.getElementById('add-module-color-layer');
const inputShowUpdateButton = document.getElementById('setting-show-update-button');
const inputUpdateAutoPoll = document.getElementById('setting-update-auto-poll');
const inputHideDowngradeButton = document.getElementById('setting-hide-downgrade-button');

// Navigation buttons for settings
const settingsNavButtons = document.querySelectorAll('.settings-nav button');

// Remember the selected root folder across sessions
const FS_HANDLE_KEY = 'rootDirHandle';
const ROOT_HANDLE_NAME_KEY = 'rootDirDisplayName';
const UPDATE_HANDLE_KEY = 'updateDirHandle';
const UPDATE_HANDLE_NAME_KEY = 'updateDirDisplayName';
const DOWNGRADE_COLLAPSE_KEY = 'downgradeSectionCollapsed';
const MAX_HISTORY_ENTRIES = 50;
const UPDATE_POLL_INTERVAL_MS = 5 * 1000;
const UPDATE_STATUS_BASE_CLASSES = 'text-sm px-3 py-1 rounded transition-colors duration-200 font-medium border border-transparent';
const IGNORED_DOWNGRADES_STORAGE_KEY = 'ignoredDowngradeVersions';
const MAX_IGNORED_DOWNGRADE_VERSIONS = 20;

let pendingRootPermission = false;
let pendingUpdatePermission = false;
let ignoredDowngradeEntries = loadIgnoredDowngrades();

const storedRootFolderName = (() => {
  try {
    return localStorage.getItem(ROOT_HANDLE_NAME_KEY);
  } catch (e) {
    console.warn('Konnte Arbeitsordnernamen nicht aus dem localStorage lesen', e);
    return null;
  }
})();

const storedDowngradeCollapsed = (() => {
  try {
    return localStorage.getItem(DOWNGRADE_COLLAPSE_KEY);
  } catch (e) {
    return null;
  }
})();
if (storedDowngradeCollapsed === '0') {
  downgradeCollapsed = false;
} else if (storedDowngradeCollapsed === '1') {
  downgradeCollapsed = true;
}
if (storedRootFolderName && rootBtn) {
  rootBtn.textContent = storedRootFolderName;
  rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
}

const storedUpdateFolderName = (() => {
  try {
    return localStorage.getItem(UPDATE_HANDLE_NAME_KEY);
  } catch (e) {
    console.warn('Konnte Update-Ordnernamen nicht aus dem localStorage lesen', e);
    return null;
  }
})();
if (storedUpdateFolderName && updateFolderNameEl) {
  updateFolderNameEl.textContent = storedUpdateFolderName;
}

function idbOpen() {
  return new Promise((res, rej) => {
    const req = indexedDB.open('modulesApp', 1);
    req.onupgradeneeded = () => req.result.createObjectStore('fs-handles');
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}
async function idbSet(key, val){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction('fs-handles','readwrite');
    tx.objectStore('fs-handles').put(val, key);
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction('fs-handles','readonly');
    const req = tx.objectStore('fs-handles').get(key);
    req.onsuccess = () => res(req.result || null);
    req.onerror = () => rej(req.error);
  });
}
async function idbDel(key){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction('fs-handles','readwrite');
    tx.objectStore('fs-handles').delete(key);
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function ensureRWPermission(handle, opts = {}){
  if (typeof handle?.queryPermission !== 'function') return true;
  const mode = opts.mode || 'readwrite';
  const q = await handle.queryPermission({ mode });
  if (q === 'granted') return true;
  if (opts.request === false) return false;
  try {
    const r = await handle.requestPermission({ mode });
    return r === 'granted';
  } catch (err) {
    console.warn('requestPermission failed', err);
    return false;
  }
}
async function tryRestoreRootHandle(){
  if (!('showDirectoryPicker' in window)) return false;
  try {
    const h = await idbGet(FS_HANDLE_KEY);
    if (!h) return false;
    let ok = await ensureRWPermission(h, { mode: 'readwrite', request: false });
    if (!ok) {
      try {
        ok = await ensureRWPermission(h, { mode: 'readwrite' });
      } catch (permErr) {
        console.warn('requestPermission für Arbeitsordner fehlgeschlagen:', permErr);
      }
    }

    rootDirHandle = h;
    setGlobalHandle('root', rootDirHandle);
    const displayName = storedRootFolderName || h.name;
    rootBtn.textContent = displayName;
    try { localStorage.setItem(ROOT_HANDLE_NAME_KEY, h.name); } catch (e) {
      console.warn('Konnte Arbeitsordnernamen nicht speichern', e);
    }

    if (!ok) {
      pendingRootPermission = true;
      rootBtn.classList.remove('bg-gray-300','hover:bg-gray-400','text-gray-800');
      rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
      rootBtn.classList.add('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
      rootBtn.title = 'Bitte Zugriff auf den gespeicherten Arbeitsordner erlauben oder einen neuen wählen.';
      setUpdateStatusButton();
      renderUpdateList();
      return false;
    }

    pendingRootPermission = false;
    rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
    rootBtn.classList.remove('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
    rootBtn.title = '';
    rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');

    await loadModulesFromRoot(h);
    await loadAppSettings();
    applySettings();
    await loadAndInitTabs();
    return true;
  } catch (e) {
    console.warn('Restore root handle failed:', e);
    return false;
  }
}

async function tryRestoreUpdateHandle(){
  if (!('showDirectoryPicker' in window)) return false;
  try {
    const h = await idbGet(UPDATE_HANDLE_KEY);
    if (!h) return false;
    let ok = await ensureRWPermission(h, { request: false, mode: 'read' });
    if (!ok) {
      try {
        ok = await ensureRWPermission(h, { mode: 'read' });
      } catch (permErr) {
        console.warn('requestPermission für Update-Ordner fehlgeschlagen:', permErr);
      }
    }
    updateDirHandle = h;
    setGlobalHandle('update', updateDirHandle);
    if (updateFolderNameEl) updateFolderNameEl.textContent = h.name;
    try { localStorage.setItem(UPDATE_HANDLE_NAME_KEY, h.name); } catch (e) {
      console.warn('Konnte Update-Ordnernamen nicht speichern', e);
    }
    if (!ok) {
      pendingUpdatePermission = true;
      if (updateCheckStatus) {
        updateCheckStatus.textContent = 'Bitte Zugriff auf den Update-Ordner erlauben.';
      }
      setUpdateStatusButton();
      renderUpdateList();
      return false;
    }
    pendingUpdatePermission = false;
    return true;
  } catch (e) {
    console.warn('Restore update handle failed:', e);
    return false;
  }
}

function formatVersionDisplay(val) {
  if (val === null || typeof val === 'undefined') return '–';
  if (typeof val === 'string' && val.trim() === '') return '–';
  return String(val);
}

function normalizeVersionValue(value) {
  if (value === null || typeof value === 'undefined') return null;
  const str = String(value).trim();
  if (!str) return null;
  if (/^unreleased$/i.test(str)) return null;
  return str.replace(/^[vV]\s*/, '').trim();
}

function compareVersions(a, b) {
  const normA = normalizeVersionValue(a);
  const normB = normalizeVersionValue(b);
  if (normA === null && normB === null) return 0;
  if (normA === null) return -1;
  if (normB === null) return 1;

  const partsA = normA.split(/[^0-9A-Za-z]+/).filter(Boolean);
  const partsB = normB.split(/[^0-9A-Za-z]+/).filter(Boolean);
  const len = Math.max(partsA.length, partsB.length);

  for (let i = 0; i < len; i++) {
    const segA = partsA[i] ?? '0';
    const segB = partsB[i] ?? '0';
    const numA = Number(segA);
    const numB = Number(segB);

    const bothNumeric = !Number.isNaN(numA) && !Number.isNaN(numB);
    if (bothNumeric) {
      if (numA > numB) return 1;
      if (numA < numB) return -1;
      continue;
    }

    const cmp = segA.localeCompare(segB, undefined, { numeric: true, sensitivity: 'base' });
    if (cmp > 0) return 1;
    if (cmp < 0) return -1;
  }

  return 0;
}

function loadIgnoredDowngrades() {
  const map = new Map();
  try {
    const raw = localStorage.getItem(IGNORED_DOWNGRADES_STORAGE_KEY);
    if (!raw) return map;
    const parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object') {
      Object.entries(parsed).forEach(([identity, value]) => {
        if (!identity) return;
        const versions = Array.isArray(value)
          ? value
          : (value && Array.isArray(value.versions) ? value.versions : []);
        if (!versions.length) return;
        const normalized = versions
          .map(entry => {
            if (typeof entry === 'string') return entry.trim() || '__null__';
            if (entry === null || typeof entry === 'undefined') return '__null__';
            return String(entry).trim() || '__null__';
          })
          .filter((entry, index, arr) => entry && arr.indexOf(entry) === index);
        if (normalized.length) {
          map.set(identity, normalized.slice(-MAX_IGNORED_DOWNGRADE_VERSIONS));
        }
      });
    }
  } catch (e) {
    console.warn('Konnte Liste ignorierter Downgrades nicht laden', e);
  }
  return map;
}

function persistIgnoredDowngrades() {
  try {
    const plain = {};
    ignoredDowngradeEntries.forEach((versions, identity) => {
      if (!Array.isArray(versions) || !versions.length) return;
      plain[identity] = versions.slice(-MAX_IGNORED_DOWNGRADE_VERSIONS);
    });
    localStorage.setItem(IGNORED_DOWNGRADES_STORAGE_KEY, JSON.stringify(plain));
  } catch (e) {
    console.warn('Konnte ignorierte Downgrades nicht speichern', e);
  }
}

function getDowngradeIdentity(item) {
  if (!item || typeof item !== 'object') return null;
  if (item.type === 'module') {
    if (item.moduleId) return `module:${item.moduleId}`;
    if (item.targetRelPath) return `module-target:${item.targetRelPath}`;
    if (item.sourceRelPath) return `module-source:${item.sourceRelPath}`;
  } else if (item.type === 'html') {
    const target = item.targetPath || item.path || item.displayName || HTML_FILE_NAME;
    return `html:${target}`;
  }
  if (item.path) return `path:${item.path}`;
  if (item.targetPath) return `target:${item.targetPath}`;
  if (item.displayName) return `name:${item.displayName}`;
  return null;
}

function getDowngradeVersionKey(version) {
  const normalized = normalizeVersionValue(version);
  return normalized === null ? '__null__' : String(normalized);
}

function isDowngradeIgnored(item) {
  const identity = getDowngradeIdentity(item);
  if (!identity) return false;
  const versions = ignoredDowngradeEntries.get(identity);
  if (!Array.isArray(versions) || !versions.length) return false;
  const versionKey = getDowngradeVersionKey(item?.newVersion);
  return versions.includes(versionKey);
}

function markDowngradeIgnored(item) {
  const identity = getDowngradeIdentity(item);
  if (!identity) return;
  const versionKey = getDowngradeVersionKey(item?.newVersion);
  let versions = ignoredDowngradeEntries.get(identity) || [];
  if (!Array.isArray(versions)) versions = [];
  if (!versions.includes(versionKey)) {
    versions = versions.concat(versionKey).slice(-MAX_IGNORED_DOWNGRADE_VERSIONS);
    ignoredDowngradeEntries.set(identity, versions);
    persistIgnoredDowngrades();
  }
}

function beginSuppressLayoutRecording() {
  layoutRecordingSuppressCount++;
}

function endSuppressLayoutRecording() {
  if (layoutRecordingSuppressCount > 0) {
    layoutRecordingSuppressCount--;
  }
}

function isLayoutRecordingSuppressed() {
  return layoutRecordingSuppressCount > 0;
}

function cloneModuleEntry(entry) {
  return { ...entry };
}

function captureLayoutSnapshot() {
  return {
    activeTabIndex,
    tabs: tabs.map(tab => ({
      name: tab.name,
      modules: Array.isArray(tab.modules) ? tab.modules.map(cloneModuleEntry) : []
    }))
  };
}

function layoutsEqual(a, b) {
  try {
    return JSON.stringify(a) === JSON.stringify(b);
  } catch (e) {
    return false;
  }
}

function updateUndoRedoButtons() {
  if (undoBtn) {
    undoBtn.disabled = !undoStack.length;
    undoBtn.classList.toggle('opacity-60', !undoStack.length);
    undoBtn.classList.toggle('cursor-not-allowed', !undoStack.length);
  }
  if (redoBtn) {
    redoBtn.disabled = !redoStack.length;
    redoBtn.classList.toggle('opacity-60', !redoStack.length);
    redoBtn.classList.toggle('cursor-not-allowed', !redoStack.length);
  }
  if (historyMenuToggle) {
    const hasActions = undoStack.length || redoStack.length;
    historyMenuToggle.disabled = !hasActions;
    historyMenuToggle.classList.toggle('opacity-60', !hasActions);
    historyMenuToggle.classList.toggle('text-gray-600', !!hasActions);
    historyMenuToggle.classList.toggle('text-gray-400', !hasActions);
    historyMenuToggle.setAttribute('aria-disabled', hasActions ? 'false' : 'true');
    historyMenuToggle.title = hasActions ? 'Verlauf' : 'Keine Verlaufsschritte verfügbar';
    if (!hasActions) {
      closeHistoryMenu();
    }
  }
}

function pushUndoState(snapshot) {
  if (!snapshot) return;
  undoStack.push(JSON.parse(JSON.stringify(snapshot)));
  if (undoStack.length > MAX_HISTORY_ENTRIES) {
    undoStack.shift();
  }
  redoStack = [];
  updateUndoRedoButtons();
}

async function restoreLayoutFromSnapshot(snapshot) {
  if (!snapshot || !Array.isArray(snapshot.tabs)) return;
  beginSuppressLayoutRecording();
  try {
    resetTabs();
    snapshot.tabs.forEach(tabData => {
      createTab(tabData.name, tabData.modules || []);
    });
    const readiness = tabs.map(tab => tab?.readyPromise || Promise.resolve());
    await Promise.all(readiness);
    if (!tabs.length) {
      createTab('Standard');
    }
    let targetIndex = typeof snapshot.activeTabIndex === 'number' ? snapshot.activeTabIndex : 0;
    if (targetIndex < 0 || targetIndex >= tabs.length) {
      targetIndex = Math.min(Math.max(targetIndex, 0), Math.max(0, tabs.length - 1));
    }
    activateTab(targetIndex);
    updateModuleDraggable();
    updateGridDraggable();
    updateGridAutoArrange();
  } finally {
    endSuppressLayoutRecording();
  }
  await saveLayout();
}

function parseChangelogSections(text) {
  if (!text) return [];
  const normalized = text.replace(/\r\n/g, '\n');
  const lines = normalized.split('\n');
  const sections = [];
  let current = null;

  for (const line of lines) {
    const headingMatch = line.match(/^##(?!#)\s*(?:\[(.+?)\]|([^\s]+))(.*)$/);
    if (headingMatch) {
      if (current) {
        sections.push({
          version: current.version,
          rawVersion: current.rawVersion,
          heading: current.heading,
          content: current.lines.join('\n').trim()
        });
      }
      const versionCandidate = (headingMatch[1] || headingMatch[2] || '').trim();
      const headingText = line.replace(/^##\s*/, '').trim();
      current = {
        rawVersion: versionCandidate,
        version: normalizeVersionValue(versionCandidate) || null,
        heading: headingText,
        lines: []
      };
    } else if (current) {
      current.lines.push(line);
    }
  }

  if (current) {
    sections.push({
      version: current.version,
      rawVersion: current.rawVersion,
      heading: current.heading,
      content: current.lines.join('\n').trim()
    });
  }

  return sections;
}

function filterChangelogSections(sections, currentVersion, targetVersion) {
  const current = normalizeVersionValue(currentVersion);
  const target = normalizeVersionValue(targetVersion);

  return sections.filter(section => {
    if (!section.version) return false;
    if (target && compareVersions(section.version, target) === 1) return false;
    if (current && compareVersions(section.version, current) <= 0) return false;
    return true;
  });
}

function appendChangelogSections(targetEl, sections) {
  if (!targetEl || !Array.isArray(sections)) return;
  sections.forEach(section => {
    const sectionEl = document.createElement('section');
    sectionEl.className = 'changelog-section';

    const headingEl = document.createElement('h3');
    headingEl.textContent = section.heading || (section.rawVersion ? `Version ${section.rawVersion}` : 'Changelog-Eintrag');
    sectionEl.appendChild(headingEl);

    const pre = document.createElement('pre');
    pre.className = 'changelog-pre';
    pre.textContent = section.content || 'Keine Details vorhanden.';
    sectionEl.appendChild(pre);

    targetEl.appendChild(sectionEl);
  });
}

function escapeRegExp(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function formatChangelogOptionLabel(section, index) {
  const heading = (section?.heading || '').trim();
  const rawVersion = (section?.rawVersion || '').trim();
  if (rawVersion && heading) {
    const pattern = new RegExp(`^\\s*\\[?${escapeRegExp(rawVersion)}\\]?\\s*[-–—:\\s]*`, 'i');
    const rest = heading.replace(pattern, '').trim();
    if (rest) {
      return `${rawVersion} – ${rest}`;
    }
  }
  if (rawVersion) {
    return rawVersion;
  }
  if (heading) {
    return heading;
  }
  return `Eintrag ${index + 1}`;
}

function populateChangelogVersionSelect(sections, selectedIndex = 0) {
  if (!changelogVersionSelect) return;
  changelogVersionSelect.innerHTML = '';
  if (!Array.isArray(sections) || !sections.length) {
    changelogVersionSelect.disabled = true;
    if (changelogShowFullBtn) changelogShowFullBtn.disabled = true;
    return;
  }

  sections.forEach((section, index) => {
    const option = document.createElement('option');
    option.value = String(index);
    option.textContent = formatChangelogOptionLabel(section, index);
    changelogVersionSelect.appendChild(option);
  });

  const safeIndex = Math.max(0, Math.min(sections.length - 1, selectedIndex));
  changelogVersionSelect.value = String(safeIndex);
  changelogVersionSelect.disabled = sections.length <= 1;
  if (changelogShowFullBtn) {
    changelogShowFullBtn.disabled = sections.length === 0;
  }
}

function updateGlobalChangelogSubtitle(mode, section = null, total = 0) {
  if (!changelogSubtitleEl) return;
  const parts = [];
  if (htmlChangelogSourceLabel) {
    parts.push(`Quelle: ${htmlChangelogSourceLabel}`);
  }

  if (mode === 'all') {
    parts.push(total ? `${total} Einträge` : 'Gesamter Verlauf');
  } else if (section) {
    if (section.rawVersion) {
      parts.push(`Version: ${section.rawVersion}`);
    } else if (section.heading) {
      parts.push(section.heading);
    }
  }

  changelogSubtitleEl.textContent = parts.join(' • ');
}

function displayGlobalChangelogSections(sections, mode = 'single', index = 0) {
  if (!changelogBodyEl) return;
  changelogBodyEl.innerHTML = '';
  if (!Array.isArray(sections) || !sections.length) {
    changelogBodyEl.innerHTML = '<div class="changelog-empty">Keine Changelog-Daten verfügbar.</div>';
    updateGlobalChangelogSubtitle('all', null, 0);
    return;
  }

  if (mode === 'all') {
    appendChangelogSections(changelogBodyEl, sections);
    updateGlobalChangelogSubtitle('all', null, sections.length);
  } else {
    const safeIndex = Math.max(0, Math.min(sections.length - 1, index));
    appendChangelogSections(changelogBodyEl, [sections[safeIndex]]);
    updateGlobalChangelogSubtitle('single', sections[safeIndex], sections.length);
  }
  changelogBodyEl.scrollTop = 0;
}

async function loadHtmlChangelogSections({ forceReload = false } = {}) {
  if (!forceReload && Array.isArray(cachedHtmlChangelogSections)) {
    return cachedHtmlChangelogSections;
  }

  let text = null;
  if (htmlUpdateChangelogHandle) {
    try {
      const file = await htmlUpdateChangelogHandle.getFile();
      text = await file.text();
      htmlChangelogSourceLabel = htmlUpdateChangelogFileName || HTML_CHANGELOG_FILE;
    } catch (err) {
      console.warn('HTML-Changelog konnte nicht gelesen werden', err);
    }
  }

  if (!text) {
    try {
      const response = await fetch(HTML_CHANGELOG_FILE, { cache: 'no-store' });
      if (response.ok) {
        text = await response.text();
        htmlChangelogSourceLabel = HTML_CHANGELOG_FILE;
      }
    } catch (err) {
      console.warn('Fallback-Changelog konnte nicht geladen werden', err);
    }
  }

  if (!text) {
    cachedHtmlChangelogSections = null;
    return null;
  }

  cachedHtmlChangelogSections = parseChangelogSections(text);
  return cachedHtmlChangelogSections;
}

function resetGlobalChangelogState() {
  currentGlobalChangelogMode = 'single';
  currentGlobalChangelogIndex = 0;
  if (changelogVersionSelect) {
    changelogVersionSelect.innerHTML = '';
    changelogVersionSelect.value = '';
    changelogVersionSelect.disabled = false;
  }
  if (changelogShowFullBtn) {
    changelogShowFullBtn.disabled = false;
    changelogShowFullBtn.textContent = 'Ganzen Changelog anzeigen';
  }
}

function resetModuleChangelogState() {
  moduleChangelogSections = null;
  moduleChangelogFilteredSections = null;
  moduleChangelogNotice = null;
  moduleChangelogShowFull = false;
}

function hideChangelogVersionControls() {
  if (changelogVersionLabel) changelogVersionLabel.classList.add('hidden');
  if (changelogVersionSelect) {
    changelogVersionSelect.classList.add('hidden');
    changelogVersionSelect.disabled = true;
  }
}

function showChangelogVersionControls() {
  if (changelogVersionLabel) changelogVersionLabel.classList.remove('hidden');
  if (changelogVersionSelect) {
    changelogVersionSelect.classList.remove('hidden');
    changelogVersionSelect.disabled = false;
  }
}

function updateModuleChangelogButtonState() {
  if (!changelogShowFullBtn) return;
  const hasSections = Array.isArray(moduleChangelogSections) && moduleChangelogSections.length > 0;
  changelogShowFullBtn.disabled = !hasSections;
  changelogShowFullBtn.textContent = moduleChangelogShowFull
    ? 'Nur neueste Version anzeigen'
    : 'Ganzen Changelog anzeigen';
}

function displayModuleChangelogSections(mode = 'filtered') {
  if (!changelogBodyEl) return;
  const sectionsToShow = mode === 'all' ? moduleChangelogSections : moduleChangelogFilteredSections;
  changelogBodyEl.innerHTML = '';

  if (mode !== 'all' && moduleChangelogNotice) {
    const notice = document.createElement('div');
    notice.className = 'changelog-empty';
    notice.textContent = moduleChangelogNotice;
    changelogBodyEl.appendChild(notice);
  }

  if (!Array.isArray(sectionsToShow) || !sectionsToShow.length) {
    const empty = document.createElement('div');
    empty.className = 'changelog-empty';
    empty.textContent = 'Keine Einträge für den Changelog verfügbar.';
    changelogBodyEl.appendChild(empty);
  } else {
    appendChangelogSections(changelogBodyEl, sectionsToShow);
  }

  changelogBodyEl.scrollTop = 0;
  moduleChangelogShowFull = mode === 'all';
  updateModuleChangelogButtonState();
}

async function openGlobalChangelogModal(initialMode = 'latest') {
  if (!changelogOverlay || !changelogBodyEl) return;

  currentChangelogContext = 'global';
  resetModuleChangelogState();
  showChangelogVersionControls();
  resetGlobalChangelogState();
  lastChangelogTrigger = document.activeElement instanceof HTMLElement ? document.activeElement : null;

  if (changelogTitleEl) {
    changelogTitleEl.textContent = 'Changelog – Shopguide';
  }
  if (changelogSubtitleEl) {
    changelogSubtitleEl.textContent = '';
  }

  if (changelogControlsEl) {
    changelogControlsEl.classList.remove('hidden');
  }
  if (changelogVersionSelect) {
    changelogVersionSelect.innerHTML = '';
  }
  if (changelogShowFullBtn) {
    changelogShowFullBtn.classList.remove('hidden');
  }

  changelogBodyEl.innerHTML = '<div class="changelog-loading">Lade Changelog…</div>';
  changelogOverlay.classList.add('open');
  changelogOverlay.setAttribute('aria-hidden', 'false');

  const requestId = ++changelogRequestToken;

  if (closeChangelogBtn && typeof closeChangelogBtn.focus === 'function') {
    closeChangelogBtn.focus();
  }

  try {
    const sections = await loadHtmlChangelogSections();
    if (requestId !== changelogRequestToken) return;

    if (!sections || !sections.length) {
      changelogBodyEl.innerHTML = '<div class="changelog-empty">Keine Changelog-Daten verfügbar.</div>';
      if (changelogControlsEl) changelogControlsEl.classList.add('hidden');
      updateGlobalChangelogSubtitle('all', null, 0);
      return;
    }

    populateChangelogVersionSelect(sections, 0);
    currentGlobalChangelogIndex = 0;

    if (initialMode === 'all') {
      currentGlobalChangelogMode = 'all';
      displayGlobalChangelogSections(sections, 'all');
    } else {
      currentGlobalChangelogMode = 'single';
      displayGlobalChangelogSections(sections, 'single', 0);
    }
  } catch (err) {
    console.error('Allgemeiner Changelog konnte nicht geladen werden', err);
    if (requestId !== changelogRequestToken) return;
    changelogBodyEl.innerHTML = '<div class="changelog-error">Der Changelog konnte nicht geladen werden.</div>';
    if (changelogControlsEl) changelogControlsEl.classList.add('hidden');
    if (changelogSubtitleEl) changelogSubtitleEl.textContent = '';
  }
}

async function findChangelogFile(dirHandle, relPath = '') {
  if (!dirHandle?.values) return null;
  const entries = [];

  try {
    for await (const entry of dirHandle.values()) {
      entries.push(entry);
    }
  } catch (err) {
    console.warn('Changelog-Dateien konnten nicht gelesen werden', err);
    return null;
  }

  const files = entries
    .filter(entry => entry.kind === 'file')
    .sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));

  for (const file of files) {
    if (file.name.toLowerCase().includes('changelog')) {
      return {
        handle: file,
        name: file.name,
        path: relPath ? `${relPath}/${file.name}` : file.name
      };
    }
  }

  for (const entry of entries) {
    if (entry.kind === 'directory') {
      const childRel = relPath ? `${relPath}/${entry.name}` : entry.name;
      const found = await findChangelogFile(entry, childRel);
      if (found) return found;
    }
  }

  return null;
}

function buildModuleChangelogDisplayPath(baseModulePath, relativeFilePath) {
  if (!relativeFilePath) return null;
  const cleanBase = (baseModulePath || '').replace(/^[\\/]+|[\\/]+$/g, '');
  const cleanFile = relativeFilePath.replace(/^[\\/]+/, '');
  const parts = ['modules'];
  if (cleanBase) parts.push(cleanBase);
  if (cleanFile) parts.push(cleanFile);
  return parts.join('/');
}

async function ensureChangelogHandle(item) {
  if (!item) return null;
  if (item.changelogHandle) return item.changelogHandle;
  if (item.type === 'html') {
    const fileName = item.changelogFileName || HTML_CHANGELOG_FILE;
    if (!fileName) return null;

    const handles = [];
    if (item.updateDirHandle) handles.push(item.updateDirHandle);
    if (updateDirHandle) handles.push(updateDirHandle);
    if (item.localDirHandle) handles.push(item.localDirHandle);
    if (rootDirHandle) handles.push(rootDirHandle);

    const uniqueHandles = [];
    const seenHandles = new Set();
    handles.forEach(handle => {
      if (handle && !seenHandles.has(handle)) {
        seenHandles.add(handle);
        uniqueHandles.push(handle);
      }
    });

    for (const dirHandle of uniqueHandles) {
      if (!dirHandle?.getFileHandle) continue;
      try {
        const handle = await dirHandle.getFileHandle(fileName, { create: false });
        item.changelogHandle = handle;
        item.changelogFileName = fileName;
        if (!item.changelogPath) item.changelogPath = fileName;
        item.changelogRelativePath = null;
        if (!item.updateDirHandle && dirHandle === updateDirHandle) {
          item.updateDirHandle = dirHandle;
        }
        if (!item.localDirHandle && dirHandle === rootDirHandle) {
          item.localDirHandle = dirHandle;
        }
        return handle;
      } catch (err) {
        if (err?.name !== 'NotFoundError') {
          console.warn('HTML-Changelog konnte nicht gelesen werden', err);
        }
      }
    }
    return null;
  }
  if (!item.updateDirHandle && !item.localDirHandle) return null;

  const targets = [];
  if (item.updateDirHandle) {
    targets.push({
      handle: item.updateDirHandle,
      basePath: item.sourceRelPath || item.updateRelPath || item.targetRelPath || ''
    });
  }
  if (item.localDirHandle) {
    const localBase = item.targetRelPath || item.localRelPath || item.sourceRelPath || '';
    targets.push({
      handle: item.localDirHandle,
      basePath: localBase
    });
  }

  for (const target of targets) {
    if (!target?.handle) continue;
    try {
      const info = await findChangelogFile(target.handle);
      if (info?.handle) {
        const relativePath = (info.path || info.name || '').replace(/^[\\/]+/, '');
        const moduleBasePath = target.basePath || item.sourceRelPath || item.targetRelPath || '';
        item.changelogHandle = info.handle;
        item.changelogFileName = info.name;
        item.changelogRelativePath = relativePath || null;
        item.changelogPath = relativePath
          ? buildModuleChangelogDisplayPath(moduleBasePath, relativePath)
          : item.changelogPath || null;
        return item.changelogHandle;
      }
    } catch (err) {
      console.warn('Changelog-Suche fehlgeschlagen', err);
    }
  }

  return null;
}

function updateChangelogSubtitle(item) {
  if (!changelogSubtitleEl) return;
  if (!item) {
    changelogSubtitleEl.textContent = '';
    return;
  }

  const parts = [];
  parts.push(`Versionen: ${formatVersionDisplay(item.currentVersion)} → ${formatVersionDisplay(item.newVersion)}`);
  const moduleBasePath = item.sourceRelPath || item.targetRelPath || '';
  const displayPath = item.changelogPath
    || (item.changelogRelativePath ? buildModuleChangelogDisplayPath(moduleBasePath, item.changelogRelativePath) : null);
  if (displayPath) {
    parts.push(`Datei: ${displayPath}`);
  } else if (item.changelogFileName) {
    parts.push(`Datei: ${item.changelogFileName}`);
  }
  changelogSubtitleEl.textContent = parts.join(' • ');
}

function closeChangelogModal() {
  if (!changelogOverlay) return;
  changelogOverlay.classList.remove('open');
  changelogOverlay.setAttribute('aria-hidden', 'true');
  changelogRequestToken++;
  if (changelogBodyEl) changelogBodyEl.innerHTML = '';
  if (changelogControlsEl) changelogControlsEl.classList.add('hidden');
  resetGlobalChangelogState();
  resetModuleChangelogState();
  currentChangelogContext = 'none';
  showChangelogVersionControls();
  if (lastChangelogTrigger && typeof lastChangelogTrigger.focus === 'function') {
    try { lastChangelogTrigger.focus(); } catch {}
  }
  lastChangelogTrigger = null;
}

async function openChangelogModal(item) {
  if (!item || !changelogOverlay || !changelogBodyEl) return;

  currentChangelogContext = 'module';
  resetGlobalChangelogState();
  resetModuleChangelogState();
  hideChangelogVersionControls();
  if (changelogControlsEl) changelogControlsEl.classList.add('hidden');
  if (changelogShowFullBtn) {
    changelogShowFullBtn.classList.remove('hidden');
    changelogShowFullBtn.disabled = true;
    changelogShowFullBtn.textContent = 'Ganzen Changelog anzeigen';
  }

  lastChangelogTrigger = document.activeElement instanceof HTMLElement ? document.activeElement : null;

  if (changelogTitleEl) {
    const title = item.displayName ? `Changelog – ${item.displayName}` : 'Changelog';
    changelogTitleEl.textContent = title;
  }

  updateChangelogSubtitle(item);

  changelogBodyEl.innerHTML = '<div class="changelog-loading">Lade Changelog…</div>';
  changelogOverlay.classList.add('open');
  changelogOverlay.setAttribute('aria-hidden', 'false');

  const requestId = ++changelogRequestToken;

  if (closeChangelogBtn && typeof closeChangelogBtn.focus === 'function') {
    closeChangelogBtn.focus();
  }

  try {
    const handle = await ensureChangelogHandle(item);
    if (requestId !== changelogRequestToken) return;

    updateChangelogSubtitle(item);

    if (!handle) {
      changelogBodyEl.innerHTML = '<div class="changelog-empty">Keine Changelog-Datei gefunden.</div>';
      return;
    }

    const file = await handle.getFile();
    const text = await file.text();
    if (requestId !== changelogRequestToken) return;

    const sections = parseChangelogSections(text);
    if (requestId !== changelogRequestToken) return;

    moduleChangelogSections = sections;
    moduleChangelogFilteredSections = [];
    moduleChangelogNotice = null;
    moduleChangelogShowFull = false;

    changelogBodyEl.innerHTML = '';

    if (!sections.length) {
      const empty = document.createElement('div');
      empty.className = 'changelog-empty';
      empty.textContent = 'Die Changelog-Datei enthält keine Einträge.';
      changelogBodyEl.appendChild(empty);
      updateModuleChangelogButtonState();
      return;
    }

    let relevantSections = filterChangelogSections(sections, item.currentVersion, item.newVersion);
    if (!Array.isArray(relevantSections)) relevantSections = [];

    if (!relevantSections.length) {
      const normalizedTargetVersion = normalizeVersionValue(item.newVersion);
      const matchingSection = normalizedTargetVersion
        ? sections.find(sec => sec.version === normalizedTargetVersion)
        : null;

      if (matchingSection) {
        relevantSections = [matchingSection];
      } else {
        moduleChangelogNotice = 'Keine Einträge für den Versionsbereich gefunden. Vollständiger Changelog wird angezeigt.';
        relevantSections = sections;
      }
    }

    moduleChangelogFilteredSections = relevantSections;

    if (changelogControlsEl) {
      changelogControlsEl.classList.remove('hidden');
    }
    hideChangelogVersionControls();
    if (changelogShowFullBtn) {
      changelogShowFullBtn.classList.remove('hidden');
    }

    displayModuleChangelogSections('filtered');
  } catch (err) {
    console.error('Changelog konnte nicht geladen werden', err);
    if (requestId !== changelogRequestToken) return;
    changelogBodyEl.innerHTML = '<div class="changelog-error">Der Changelog konnte nicht gelesen werden.</div>';
  }
}

if (closeChangelogBtn) {
  closeChangelogBtn.addEventListener('click', closeChangelogModal);
}
if (changelogOverlay) {
  changelogOverlay.addEventListener('click', event => {
    if (event.target === changelogOverlay) {
      closeChangelogModal();
    }
  });
}
document.addEventListener('keydown', event => {
  if (event.key !== 'Escape') return;
  let handled = false;

  if (historyMenuOpen) {
    handled = closeHistoryMenu() || handled;
  }

  if (settingsModal && !settingsModal.classList.contains('hidden')) {
    handled = hideSettingsModal() || handled;
  }

  if (changelogOverlay?.classList.contains('open')) {
    closeChangelogModal();
    handled = true;
  }

  if (handled) {
    event.preventDefault();
    event.stopPropagation();
  }
});

if (showLatestChangelogBtn) {
  showLatestChangelogBtn.addEventListener('click', () => {
    openGlobalChangelogModal('latest');
  });
}

if (changelogVersionSelect) {
  changelogVersionSelect.addEventListener('change', () => {
    if (!Array.isArray(cachedHtmlChangelogSections) || !cachedHtmlChangelogSections.length) return;
    const index = Number(changelogVersionSelect.value);
    if (Number.isNaN(index)) return;
    currentGlobalChangelogIndex = Math.max(0, Math.min(cachedHtmlChangelogSections.length - 1, index));
    currentGlobalChangelogMode = 'single';
    displayGlobalChangelogSections(cachedHtmlChangelogSections, 'single', currentGlobalChangelogIndex);
  });
}

if (changelogShowFullBtn) {
  changelogShowFullBtn.addEventListener('click', () => {
    if (currentChangelogContext === 'module') {
      if (!Array.isArray(moduleChangelogSections) || !moduleChangelogSections.length) return;
      const nextMode = moduleChangelogShowFull ? 'filtered' : 'all';
      displayModuleChangelogSections(nextMode);
      return;
    }

    if (!Array.isArray(cachedHtmlChangelogSections) || !cachedHtmlChangelogSections.length) return;
    currentGlobalChangelogMode = 'all';
    displayGlobalChangelogSections(cachedHtmlChangelogSections, 'all');
  });
}

function setUpdateStatusButton(state) {
  if (!updateStatusBtn) return;

  if (state === 'checking') {
    if (appSettings.showUpdateStatusButton === false || updateStatusShouldRemainHidden) {
      return;
    }
    updateStatusBtn.classList.remove('hidden');
    updateStatusBtn.removeAttribute('aria-hidden');
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('cursor-wait');
    updateStatusBtn.setAttribute('aria-busy', 'true');
    if (!updateStatusHasStableAppearance) {
      updateStatusBtn.className = UPDATE_STATUS_BASE_CLASSES;
      updateStatusBtn.textContent = 'Prüfe…';
      updateStatusBtn.title = '';
      updateStatusBtn.classList.add('bg-gray-300','text-gray-700');
    }
    return;
  }

  updateStatusBtn.removeAttribute('aria-busy');
  updateStatusBtn.classList.remove('cursor-wait');
  updateStatusBtn.disabled = false;
  updateStatusBtn.title = '';
  updateStatusBtn.className = UPDATE_STATUS_BASE_CLASSES;

  updateStatusHasStableAppearance = true;
  updateStatusShouldRemainHidden = false;

  if (appSettings.showUpdateStatusButton === false) {
    updateStatusShouldRemainHidden = true;
    updateStatusHasStableAppearance = false;
    updateStatusBtn.classList.add('hidden');
    updateStatusBtn.setAttribute('aria-hidden', 'true');
    updateStatusBtn.disabled = true;
    updateStatusBtn.textContent = '';
    return;
  }

  updateStatusBtn.classList.remove('hidden');
  updateStatusBtn.removeAttribute('aria-hidden');

  if (pendingRootPermission) {
    updateStatusBtn.textContent = 'Arbeitsordner entsperren';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-yellow-500','text-gray-900','cursor-not-allowed');
    return;
  }

  if (pendingUpdatePermission) {
    updateStatusBtn.textContent = 'Update-Ordner entsperren';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-yellow-500','text-gray-900','cursor-not-allowed');
    return;
  }

  if (!rootDirHandle) {
    updateStatusBtn.textContent = 'Kein Arbeitsordner';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-gray-300','text-gray-700','cursor-not-allowed');
    return;
  }

  if (!updateDirHandle) {
    updateStatusBtn.textContent = 'Kein Update-Ordner';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-gray-300','text-gray-700','cursor-not-allowed');
    return;
  }

  if (lastUpdateError) {
    updateStatusBtn.textContent = 'Prüfung fehlgeschlagen';
    updateStatusBtn.classList.add('bg-yellow-500','hover:bg-yellow-600','text-white');
    return;
  }

  let upgradeCount = currentUpgradeItems.length;
  let downgradeCount = currentDowngradeItems.length;

  if (!upgradeCount && !downgradeCount && pendingUpdates.length) {
    pendingUpdates.forEach(item => {
      const comparison = compareVersions(item.currentVersion, item.newVersion);
      if (comparison === 1) {
        if (!isDowngradeIgnored(item)) downgradeCount += 1;
      } else {
        upgradeCount += 1;
      }
    });
  }

  if (upgradeCount) {
    updateStatusBtn.textContent = 'Update available!';
    if (downgradeCount) {
      updateStatusBtn.title = `${upgradeCount} Upgrade${upgradeCount === 1 ? '' : 's'} und ${downgradeCount} Downgrade${downgradeCount === 1 ? '' : 's'} verfügbar.`;
    } else if (upgradeCount > 1) {
      updateStatusBtn.title = `${upgradeCount} Updates verfügbar.`;
    }
    updateStatusBtn.classList.add('bg-red-600','hover:bg-red-700','text-white');
    return;
  }

  if (downgradeCount) {
    if (appSettings.hideDowngradeStatusButton) {
      updateStatusShouldRemainHidden = true;
      updateStatusHasStableAppearance = false;
      updateStatusBtn.classList.add('hidden');
      updateStatusBtn.setAttribute('aria-hidden', 'true');
      updateStatusBtn.disabled = true;
      updateStatusBtn.textContent = '';
      updateStatusBtn.title = '';
      return;
    }
    updateStatusBtn.textContent = 'Nur Downgrades verfügbar';
    updateStatusBtn.title = downgradeCount === 1 ? 'Ein Downgrade verfügbar.' : `${downgradeCount} Downgrades verfügbar.`;
    updateStatusBtn.classList.add('bg-yellow-400','hover:bg-yellow-500','text-gray-900','border-yellow-500');
    return;
  }

  updateStatusBtn.textContent = 'Up to date!';
  updateStatusBtn.classList.add('bg-green-600','hover:bg-green-700','text-white');
}

function renderUpdateList() {
  if (!updatesTableBody || !updatesEmptyState) return;
  updatesTableBody.innerHTML = '';
  if (downgradeTableBody) downgradeTableBody.innerHTML = '';
  currentUpgradeItems = [];
  currentDowngradeItems = [];
  if (downgradeSection) downgradeSection.classList.add('hidden');
  if (updateAllContainer) updateAllContainer.classList.add('hidden');
  if (updateAllBtn) {
    updateAllBtn.disabled = true;
    updateAllBtn.textContent = 'Alle aktualisieren';
    updateAllBtn.classList.remove('opacity-60','cursor-wait','cursor-not-allowed');
  }
  if (pendingRootPermission) {
    updatesEmptyState.textContent = 'Bitte erlauben Sie den Zugriff auf den Arbeitsordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    setUpdateStatusButton();
    return;
  }
  if (pendingUpdatePermission) {
    updatesEmptyState.textContent = 'Bitte erlauben Sie den Zugriff auf den Update-Ordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    setUpdateStatusButton();
    return;
  }
  if (!rootDirHandle) {
    updatesEmptyState.textContent = 'Bitte wählen Sie einen Arbeitsordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    renderVersionOverview();
    setUpdateStatusButton();
    return;
  }

  if (!updateDirHandle) {
    updatesEmptyState.textContent = 'Bitte wählen Sie einen Update-Ordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    renderVersionOverview();
    setUpdateStatusButton();
    return;
  }

  if (!pendingUpdates.length) {
    updatesEmptyState.textContent = 'Keine Updates erforderlich.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus && !lastUpdateError) updateCheckStatus.textContent = 'Keine Updates erforderlich.';
    renderVersionOverview();
    setUpdateStatusButton();
    return;
  }

  const upgrades = [];
  const downgrades = [];
  pendingUpdates.forEach(item => {
    const comparison = compareVersions(item.currentVersion, item.newVersion);
    if (comparison === 1) {
      if (!isDowngradeIgnored(item)) {
        downgrades.push(item);
      }
    } else {
      upgrades.push(item);
    }
  });

  currentUpgradeItems = upgrades;
  currentDowngradeItems = downgrades;

  const upgradeCount = upgrades.length;
  const downgradeCount = downgrades.length;

  if (updateCheckStatus && !lastUpdateError) {
    if (upgradeCount && downgradeCount) {
      updateCheckStatus.textContent = `${upgradeCount} Upgrade${upgradeCount === 1 ? '' : 's'} und ${downgradeCount} Downgrade${downgradeCount === 1 ? '' : 's'} gefunden.`;
    } else if (upgradeCount) {
      updateCheckStatus.textContent = `${upgradeCount} Upgrade${upgradeCount === 1 ? '' : 's'} verfügbar.`;
    } else {
      updateCheckStatus.textContent = `${downgradeCount} Downgrade${downgradeCount === 1 ? '' : 's'} gefunden.`;
    }
  }

  if (upgradeCount) {
    updatesEmptyState.classList.add('hidden');
  } else {
    updatesEmptyState.textContent = downgradeCount
      ? 'Keine Upgrades erforderlich. Downgrades siehe unten.'
      : 'Keine Updates erforderlich.';
    updatesEmptyState.classList.remove('hidden');
  }

  if (updateAllContainer) updateAllContainer.classList.toggle('hidden', !upgradeCount);
  if (updateAllBtn) {
    updateAllBtn.disabled = !upgradeCount;
    updateAllBtn.textContent = 'Alle aktualisieren';
  }

  upgrades.forEach((item, index) => {
    const tr = document.createElement('tr');
    tr.className = index % 2 ? 'bg-white' : 'bg-gray-50';

    const tdPath = document.createElement('td');
    tdPath.className = 'px-3 py-2 align-top';
    tdPath.textContent = item.displayName || item.path;

    const tdVersion = document.createElement('td');
    tdVersion.className = 'px-3 py-2 align-top whitespace-nowrap';
    tdVersion.textContent = `${formatVersionDisplay(item.currentVersion)} → ${formatVersionDisplay(item.newVersion)}`;

    const tdAction = document.createElement('td');
    tdAction.className = 'px-3 py-2 align-top';
    const actionWrapper = document.createElement('div');
    actionWrapper.className = 'flex justify-end flex-wrap gap-2';

    if (item.type === 'module' || item.type === 'html') {
      const changelogBtn = document.createElement('button');
      changelogBtn.type = 'button';
      changelogBtn.className = 'bg-white border border-gray-300 text-gray-800 px-3 py-1 rounded hover:bg-gray-100';
      changelogBtn.textContent = 'Changelog';
      changelogBtn.addEventListener('click', () => {
        openChangelogModal(item);
      });
      actionWrapper.appendChild(changelogBtn);
    }

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded';
    btn.textContent = 'sync';
    btn.addEventListener('click', async () => {
      btn.disabled = true;
      btn.classList.add('opacity-60','cursor-wait');
      try {
        await applySingleUpdate(item);
      } catch (err) {
        console.error('Fehler beim Aktualisieren', err);
        alert('Die Datei konnte nicht aktualisiert werden.');
      } finally {
        btn.disabled = false;
        btn.classList.remove('opacity-60','cursor-wait');
      }
    });
    actionWrapper.appendChild(btn);

    tdAction.appendChild(actionWrapper);

    tr.appendChild(tdPath);
    tr.appendChild(tdVersion);
    tr.appendChild(tdAction);
    updatesTableBody.appendChild(tr);
  });

  if (downgradeSection) {
    if (downgradeCount) {
      downgradeSection.classList.remove('hidden');
      if (downgradeHeading) downgradeHeading.textContent = `Downgrades (${downgradeCount})`;
      downgrades.forEach(item => {
        const tr = document.createElement('tr');
        tr.className = 'bg-yellow-100';

        const tdPath = document.createElement('td');
        tdPath.className = 'px-3 py-2 align-top';
        tdPath.textContent = item.displayName || item.path;

        const tdVersion = document.createElement('td');
        tdVersion.className = 'px-3 py-2 align-top whitespace-nowrap';
        tdVersion.textContent = `${formatVersionDisplay(item.currentVersion)} → ${formatVersionDisplay(item.newVersion)}`;

        const tdAction = document.createElement('td');
        tdAction.className = 'px-3 py-2 align-top';
        const actionWrapper = document.createElement('div');
        actionWrapper.className = 'flex justify-end flex-wrap gap-2';

        if (item.type === 'module' || item.type === 'html') {
          const changelogBtn = document.createElement('button');
          changelogBtn.type = 'button';
          changelogBtn.className = 'bg-white border border-yellow-300 text-yellow-900 px-3 py-1 rounded hover:bg-yellow-200';
          changelogBtn.textContent = 'Changelog';
          changelogBtn.addEventListener('click', () => {
            openChangelogModal(item);
          });
          actionWrapper.appendChild(changelogBtn);
        }

        const ignoreBtn = document.createElement('button');
        ignoreBtn.type = 'button';
        ignoreBtn.className = 'bg-white border border-yellow-300 text-yellow-900 px-3 py-1 rounded hover:bg-yellow-200';
        ignoreBtn.textContent = 'Ignorieren';
        ignoreBtn.addEventListener('click', () => {
          markDowngradeIgnored(item);
          renderUpdateList();
        });
        actionWrapper.appendChild(ignoreBtn);

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'bg-yellow-500 hover:bg-yellow-600 text-yellow-900 px-3 py-1 rounded';
        btn.textContent = 'sync';
        btn.addEventListener('click', async () => {
          if (!confirm('Diese Version ist älter. Trotzdem synchronisieren?')) return;
          btn.disabled = true;
          btn.classList.add('opacity-60','cursor-wait');
          try {
            await applySingleUpdate(item);
          } catch (err) {
            console.error('Fehler beim Aktualisieren', err);
            alert('Die Datei konnte nicht aktualisiert werden.');
          } finally {
            btn.disabled = false;
            btn.classList.remove('opacity-60','cursor-wait');
          }
        });
        actionWrapper.appendChild(btn);

        tdAction.appendChild(actionWrapper);

        tr.appendChild(tdPath);
        tr.appendChild(tdVersion);
        tr.appendChild(tdAction);
        downgradeTableBody?.appendChild(tr);
      });
      updateDowngradeCollapseUI();
    } else {
      downgradeSection.classList.add('hidden');
      if (downgradeHeading) downgradeHeading.textContent = 'Downgrades (0)';
    }
  }

  renderVersionOverview();
  setUpdateStatusButton();
}

function updateDowngradeCollapseUI() {
  if (!downgradeContent || !downgradeToggleIcon) return;
  downgradeContent.classList.toggle('hidden', downgradeCollapsed);
  downgradeToggleIcon.textContent = downgradeCollapsed ? '▼' : '▲';
}

function prepareHtmlChangelogItem(info) {
  if (!info) return null;
  const prepared = info;
  prepared.type = 'html';
  if (!prepared.displayName) {
    prepared.displayName = info.updateFileName || info.localFileName || HTML_FILE_NAME;
  }
  if (!prepared.name) {
    prepared.name = prepared.displayName;
  }
  const resolvedCurrent = (typeof info.localVersion === 'undefined')
    ? (prepared.currentVersion ?? null)
    : (info.localVersion ?? null);
  prepared.currentVersion = resolvedCurrent;
  const hasUpdateVersion = typeof info.updateVersion !== 'undefined' && info.updateVersion !== null;
  const resolvedTarget = hasUpdateVersion ? info.updateVersion : resolvedCurrent;
  prepared.newVersion = resolvedTarget;
  if (!prepared.sourcePath) {
    prepared.sourcePath = info.updateFileName || info.localFileName || HTML_FILE_NAME;
  }
  if (!prepared.targetPath) {
    prepared.targetPath = info.localFileName || HTML_FILE_NAME;
  }
  if (!prepared.updateDirHandle && updateDirHandle) {
    prepared.updateDirHandle = updateDirHandle;
  }
  if (!prepared.localDirHandle && rootDirHandle) {
    prepared.localDirHandle = rootDirHandle;
  }
  if (!prepared.changelogHandle && htmlUpdateChangelogHandle) {
    prepared.changelogHandle = htmlUpdateChangelogHandle;
    if (!prepared.changelogFileName) {
      prepared.changelogFileName = htmlUpdateChangelogFileName || HTML_CHANGELOG_FILE;
    }
  }
  if (!prepared.changelogFileName) {
    prepared.changelogFileName = HTML_CHANGELOG_FILE;
  }
  if (!prepared.changelogPath) {
    prepared.changelogPath = prepared.changelogFileName;
  }
  prepared.changelogRelativePath = null;
  return prepared;
}

function prepareModuleChangelogItem(mod) {
  if (!mod) return null;
  const prepared = mod;
  if (!prepared.type) prepared.type = 'module';
  if (!prepared.displayName) prepared.displayName = prepared.name || prepared.moduleId || 'Modul';
  prepared.currentVersion = typeof prepared.localVersion === 'undefined' ? null : prepared.localVersion;
  prepared.newVersion = typeof prepared.updateVersion === 'undefined' || prepared.updateVersion === null
    ? (prepared.localVersion ?? null)
    : prepared.updateVersion;
  if (!prepared.sourceRelPath) {
    prepared.sourceRelPath = prepared.updateRelPath || prepared.localRelPath || null;
  }
  if (!prepared.targetRelPath) {
    prepared.targetRelPath = prepared.localRelPath || prepared.updateRelPath || null;
  }
  return prepared;
}

function createHtmlOverviewChangelogButton(htmlInfo) {
  if (!htmlInfo) return null;
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'version-overview-button';
  const label = htmlInfo.displayName || htmlInfo.updateFileName || htmlInfo.localFileName || HTML_FILE_NAME;
  btn.textContent = 'Changelog';
  btn.title = `Changelog für ${label} anzeigen`;
  btn.addEventListener('click', () => {
    const item = prepareHtmlChangelogItem(htmlInfo);
    if (!item) return;
    openChangelogModal(item);
  });
  return btn;
}

function createModuleOverviewChangelogButton(mod) {
  if (!mod) return null;
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'version-overview-button';
  btn.textContent = 'Changelog';
  btn.title = `Changelog für ${mod.name || mod.moduleId || 'Modul'} anzeigen`;
  btn.addEventListener('click', () => {
    const item = prepareModuleChangelogItem(mod);
    if (!item) return;
    openChangelogModal(item);
  });
  return btn;
}

function renderVersionOverview() {
  if (!versionOverviewContainer || !versionOverviewRowsEl) return;
  const htmlInfo = versionOverview?.html || { localVersion: null, updateVersion: null };
  const modulesInfo = Array.isArray(versionOverview?.modules) ? versionOverview.modules : [];

  versionOverviewRowsEl.innerHTML = '';

  const headerName = document.createElement('div');
  headerName.className = 'version-overview-header';
  headerName.textContent = 'Datei';
  const headerLocal = document.createElement('div');
  headerLocal.className = 'version-overview-header text-right';
  headerLocal.textContent = 'Aktuell';
  const headerUpdate = document.createElement('div');
  headerUpdate.className = 'version-overview-header text-right';
  headerUpdate.textContent = 'Update';
  const headerActions = document.createElement('div');
  headerActions.className = 'version-overview-header text-right';
  headerActions.textContent = 'Changelog';
  versionOverviewRowsEl.append(headerName, headerLocal, headerUpdate, headerActions);

  const addRow = (label, localValue, updateValue, actionElement = null) => {
    const nameEl = document.createElement('div');
    nameEl.className = 'version-overview-name';
    nameEl.textContent = label;

    const localEl = document.createElement('div');
    localEl.className = 'version-overview-value';
    localEl.textContent = localValue;

    const updateEl = document.createElement('div');
    updateEl.className = 'version-overview-value';
    updateEl.textContent = updateValue;

    const actionEl = document.createElement('div');
    actionEl.className = 'version-overview-action';
    if (actionElement) {
      actionEl.appendChild(actionElement);
    }

    versionOverviewRowsEl.append(nameEl, localEl, updateEl, actionEl);
  };

  const htmlLabel = htmlInfo.updateFileName || htmlInfo.localFileName || HTML_FILE_NAME;
  const htmlButton = createHtmlOverviewChangelogButton(htmlInfo);
  addRow(
    `HTML (${htmlLabel})`,
    formatVersionDisplay(htmlInfo.localVersion),
    formatVersionDisplay(htmlInfo.updateVersion),
    htmlButton
  );

  if (!modulesInfo.length) {
    const emptyEl = document.createElement('div');
    emptyEl.className = 'version-overview-empty';
    emptyEl.textContent = 'Keine Module gefunden.';
    versionOverviewRowsEl.appendChild(emptyEl);
    return;
  }

  modulesInfo.forEach(mod => {
    const actionButton = createModuleOverviewChangelogButton(mod);
    addRow(
      mod.name,
      formatVersionDisplay(mod.localVersion),
      formatVersionDisplay(mod.updateVersion),
      actionButton
    );
  });
}

async function readHtmlVersion(rootHandle) {
  if (!rootHandle) return null;

  const readFromHandle = async (fileHandle, fileName) => {
    const file = await fileHandle.getFile();
    const text = await file.text();
    const match = text.match(/<!--\s*Version:\s*([^>]+?)\s*-->/i);
    const version = match ? match[1].trim() : null;
    return { version, fileHandle, fileName };
  };

  try {
    const fileHandle = await rootHandle.getFileHandle(HTML_FILE_NAME, { create: false });
    return await readFromHandle(fileHandle, HTML_FILE_NAME);
  } catch (e) {
    if (e?.name !== 'NotFoundError') {
      console.warn('HTML-Version konnte nicht gelesen werden', e);
      return null;
    }
  }

  const htmlCandidates = [];
  try {
    for await (const entry of rootHandle.values()) {
      if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.html')) {
        htmlCandidates.push(entry.name);
        if (htmlCandidates.length > 1) break;
      }
    }
  } catch (err) {
    console.warn('HTML-Dateien konnten nicht ermittelt werden', err);
    return null;
  }

  if (htmlCandidates.length === 1) {
    const fallbackName = htmlCandidates[0];
    try {
      const fileHandle = await rootHandle.getFileHandle(fallbackName, { create: false });
      return await readFromHandle(fileHandle, fallbackName);
    } catch (err) {
      console.warn('Fallback-HTML-Version konnte nicht gelesen werden', err);
      return null;
    }
  }

  return null;
}

async function gatherModulesMetadata(rootHandle) {
  const modules = new Map();
  if (!rootHandle) return { modules };
  let modulesRoot;
  try {
    modulesRoot = await rootHandle.getDirectoryHandle('modules', { create: false });
  } catch {
    return { modules };
  }

  async function walk(dirHandle, relPath) {
    const entries = [];
    for await (const entry of dirHandle.values()) entries.push(entry);

    let moduleData = null;
    for (const entry of entries) {
      if (entry.kind === 'file' && entry.name.endsWith('.json')) {
        try {
          const file = await entry.getFile();
          const parsed = JSON.parse(await file.text());
          if (parsed && typeof parsed === 'object') {
            const moduleId = parsed.moduleId || parsed.id || parsed.name || relPath;
            if (moduleId) {
              moduleData = {
                moduleId,
                version: parsed.version ?? null,
                name: parsed.name || moduleId,
                relPath,
                dirHandle,
                raw: parsed
              };
              break;
            }
          }
        } catch (e) {
          console.warn('Modul-Metadaten konnten nicht gelesen werden', e);
        }
      }
    }

    if (moduleData) {
      const versionValue = moduleData.version;
      modules.set(moduleData.moduleId, {
        moduleId: moduleData.moduleId,
        version: versionValue === null || typeof versionValue === 'undefined' ? null : String(versionValue),
        name: moduleData.name,
        relPath,
        dirHandle
      });
    }

    for (const entry of entries) {
      if (entry.kind === 'directory') {
        const childRel = relPath ? `${relPath}/${entry.name}` : entry.name;
        await walk(entry, childRel);
      }
    }
  }

  await walk(modulesRoot, '');
  return { modules };
}

async function collectVersionDiffs(updateHandle, localHandle) {
  const overview = {
    html: {
      localVersion: null,
      updateVersion: null,
      localFileName: HTML_FILE_NAME,
      updateFileName: null
    },
    modules: []
  };
  const diffs = [];

  let localHtml = null;
  let updateHtml = null;
  let htmlChangelogHandle = null;
  try { localHtml = await readHtmlVersion(localHandle); } catch {}
  try { updateHtml = await readHtmlVersion(updateHandle); } catch {}

  if (updateHandle?.getFileHandle) {
    try {
      htmlChangelogHandle = await updateHandle.getFileHandle(HTML_CHANGELOG_FILE, { create: false });
    } catch (err) {
      if (err?.name !== 'NotFoundError') {
        console.warn('HTML-Changelog konnte nicht gelesen werden', err);
      }
    }
  }

  if (localHtml) {
    overview.html.localVersion = localHtml.version || null;
    overview.html.localFileName = localHtml.fileName || HTML_FILE_NAME;
  }
  if (updateHtml) {
    overview.html.updateVersion = updateHtml.version || null;
    overview.html.updateFileName = updateHtml.fileName || null;
  }

  const htmlDisplayName = updateHtml?.fileName || overview.html.updateFileName || overview.html.localFileName || HTML_FILE_NAME;
  Object.assign(overview.html, {
    type: 'html',
    name: htmlDisplayName,
    displayName: htmlDisplayName,
    currentVersion: overview.html.localVersion ?? null,
    newVersion: (typeof overview.html.updateVersion !== 'undefined' && overview.html.updateVersion !== null)
      ? overview.html.updateVersion
      : (overview.html.localVersion ?? null),
    sourcePath: updateHtml?.fileName || overview.html.updateFileName || overview.html.localFileName || HTML_FILE_NAME,
    targetPath: localHtml?.fileName || overview.html.localFileName || HTML_FILE_NAME,
    updateDirHandle: updateHandle || null,
    localDirHandle: localHandle || null,
    changelogHandle: htmlChangelogHandle || null,
    changelogFileName: HTML_CHANGELOG_FILE,
    changelogPath: HTML_CHANGELOG_FILE,
    changelogRelativePath: null
  });

  if (updateHtml && (updateHtml.version || !localHtml)) {
    const localVersion = localHtml?.version || null;
    if (localVersion !== updateHtml.version) {
      const sourceFileName = updateHtml.fileName || HTML_FILE_NAME;
      diffs.push({
        type: 'html',
        path: sourceFileName,
        displayName: sourceFileName,
        currentVersion: localVersion,
        newVersion: updateHtml.version || null,
        sourcePath: sourceFileName,
        targetPath: localHtml?.fileName || HTML_FILE_NAME,
        updateDirHandle: updateHandle || null,
        changelogHandle: htmlChangelogHandle || null,
        changelogFileName: htmlChangelogHandle ? HTML_CHANGELOG_FILE : null,
        changelogPath: htmlChangelogHandle ? HTML_CHANGELOG_FILE : null,
        changelogRelativePath: null
      });
    }
  }

  const localModules = await gatherModulesMetadata(localHandle);
  const updateModules = await gatherModulesMetadata(updateHandle);
  const moduleIds = new Set([
    ...Array.from(localModules.modules.keys()),
    ...Array.from(updateModules.modules.keys())
  ]);

  const modulesList = [];
  for (const moduleId of moduleIds) {
    const localMeta = localModules.modules.get(moduleId) || null;
    const updateMeta = updateModules.modules.get(moduleId) || null;
    const name = updateMeta?.name || localMeta?.name || moduleId;
    const localVersion = localMeta?.version || null;
    const updateVersion = updateMeta?.version || null;
    const moduleEntry = {
      type: 'module',
      moduleId,
      name,
      displayName: name,
      localVersion,
      updateVersion,
      currentVersion: localVersion,
      newVersion: updateVersion ?? localVersion,
      updateRelPath: updateMeta?.relPath || null,
      localRelPath: localMeta?.relPath || null,
      sourceRelPath: updateMeta?.relPath || null,
      targetRelPath: localMeta?.relPath || updateMeta?.relPath || null,
      updateDirHandle: updateMeta?.dirHandle || null,
      localDirHandle: localMeta?.dirHandle || null,
      changelogHandle: null,
      changelogFileName: null,
      changelogPath: null,
      changelogRelativePath: null
    };
    modulesList.push(moduleEntry);

    if (updateMeta && (localVersion !== updateVersion)) {
      const changelogInfo = updateMeta?.dirHandle ? await findChangelogFile(updateMeta.dirHandle) : null;
      const changelogRelativePath = (changelogInfo?.path || changelogInfo?.name || '').replace(/^[\\/]+/, '');
      const changelogDisplayPath = changelogInfo && changelogRelativePath
        ? buildModuleChangelogDisplayPath(updateMeta?.relPath || '', changelogRelativePath)
        : null;
      if (changelogInfo?.handle) {
        moduleEntry.changelogHandle = changelogInfo.handle;
        moduleEntry.changelogFileName = changelogInfo.name || null;
        moduleEntry.changelogRelativePath = changelogRelativePath || null;
        moduleEntry.changelogPath = changelogDisplayPath;
      }
      diffs.push({
        type: 'module',
        moduleId,
        path: updateMeta.relPath ? `modules/${updateMeta.relPath}` : `modules/${moduleId}`,
        displayName: name,
        currentVersion: localVersion,
        newVersion: updateVersion,
        sourceRelPath: updateMeta.relPath,
        targetRelPath: localMeta?.relPath || updateMeta.relPath,
        updateDirHandle: updateMeta.dirHandle,
        localDirHandle: localMeta?.dirHandle || null,
        changelogHandle: changelogInfo?.handle || null,
        changelogFileName: changelogInfo?.name || null,
        changelogPath: changelogDisplayPath,
        changelogRelativePath: changelogRelativePath || null
      });
    }
  }

  modulesList.sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));
  overview.modules = modulesList;

  diffs.sort((a, b) => {
    const nameA = (a.displayName || a.path || '').toLowerCase();
    const nameB = (b.displayName || b.path || '').toLowerCase();
    return nameA.localeCompare(nameB, 'de', { sensitivity: 'base' });
  });

  return {
    diffs,
    overview,
    htmlChangelogHandle: htmlChangelogHandle || null,
    htmlChangelogFileName: htmlChangelogHandle ? HTML_CHANGELOG_FILE : null
  };
}

async function ensureDirectoryChain(root, parts, { create = true } = {}) {
  let current = root;
  for (const part of parts) {
    if (!part) continue;
    current = await current.getDirectoryHandle(part, { create });
  }
  return current;
}

async function applySingleUpdate(item, { skipRecheck = false } = {}) {
  if (!rootDirHandle) return;
  if (!item) return;

  try {
    if (item.type === 'html') {
      if (!updateDirHandle) throw new Error('Kein Update-Ordner vorhanden.');
      const sourceFileName = item.sourcePath || HTML_FILE_NAME;
      const updateFileHandle = await updateDirHandle.getFileHandle(sourceFileName, { create: false });
      const updateFile = await updateFileHandle.getFile();
      const targetFileHandle = await rootDirHandle.getFileHandle(sourceFileName, { create: true });
      const writable = await targetFileHandle.createWritable();
      await writable.write(await updateFile.arrayBuffer());
      await writable.close();
      await removeOtherHtmlFiles(rootDirHandle, sourceFileName);
    } else if (item.type === 'module') {
      if (!updateDirHandle) throw new Error('Kein Update-Ordner vorhanden.');
      const sourceSegments = ['modules', ...(item.sourceRelPath ? item.sourceRelPath.split('/') : [])];
      const targetSegments = ['modules', ...(item.targetRelPath ? item.targetRelPath.split('/') : [])];
      const sourceDir = await ensureDirectoryChain(updateDirHandle, sourceSegments, { create: false });
      const targetDir = await ensureDirectoryChain(rootDirHandle, targetSegments, { create: true });
      await syncDirectoryContents(sourceDir, targetDir);
    } else if (item.sourcePath) {
      if (!updateDirHandle) throw new Error('Kein Update-Ordner vorhanden.');
      const segments = item.sourcePath.split('/');
      const fileName = segments.pop();
      const sourceDir = await ensureDirectoryChain(updateDirHandle, segments, { create: false });
      const updateFileHandle = await sourceDir.getFileHandle(fileName, { create: false });
      const targetDir = await ensureDirectoryChain(rootDirHandle, segments, { create: true });
      const targetFileHandle = await targetDir.getFileHandle(fileName, { create: true });
      const updateFile = await updateFileHandle.getFile();
      const writable = await targetFileHandle.createWritable();
      await writable.write(await updateFile.arrayBuffer());
      await writable.close();
    }
  } catch (err) {
    console.error('Fehler beim Synchronisieren', err);
    throw err;
  }

  if (!skipRecheck) {
    await runUpdateCheck();
  }
}

async function syncDirectoryContents(sourceDir, targetDir) {
  const sourceEntries = new Map();
  for await (const entry of sourceDir.values()) {
    sourceEntries.set(entry.name, entry);
  }

  const targetEntries = [];
  for await (const entry of targetDir.values()) {
    targetEntries.push(entry);
  }

  for (const entry of targetEntries) {
    if (!sourceEntries.has(entry.name)) {
      try {
        await targetDir.removeEntry(entry.name, { recursive: true });
      } catch (err) {
        if (err?.name !== 'NotFoundError') {
          console.warn('Eintrag konnte nicht entfernt werden', err);
        }
      }
    }
  }

  for (const [name, entry] of sourceEntries.entries()) {
    if (entry.kind === 'file') {
      const file = await entry.getFile();
      const targetFileHandle = await targetDir.getFileHandle(name, { create: true });
      const writable = await targetFileHandle.createWritable();
      await writable.write(await file.arrayBuffer());
      await writable.close();
    } else if (entry.kind === 'directory') {
      const subTarget = await targetDir.getDirectoryHandle(name, { create: true });
      await syncDirectoryContents(entry, subTarget);
    }
  }
}

async function removeOtherHtmlFiles(rootHandle, keepFileName) {
  if (!rootHandle) return;
  const toRemove = [];
  for await (const entry of rootHandle.values()) {
    if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.html') && entry.name !== keepFileName) {
      toRemove.push(entry.name);
    }
  }

  for (const name of toRemove) {
    try {
      await rootHandle.removeEntry(name);
    } catch (err) {
      if (err?.name !== 'NotFoundError') {
        console.warn(`Konnte HTML-Datei ${name} nicht entfernen`, err);
      }
    }
  }
}

async function runUpdateCheck() {
  if (updateCheckInProgress) {
    rerunUpdateCheckWhenUnlocked = true;
    return;
  }
  lastUpdateError = false;

  if (pendingRootPermission || pendingUpdatePermission) {
    rerunUpdateCheckWhenUnlocked = true;
    renderUpdateList();
    setUpdateStatusButton();
    return;
  }

  if (!rootDirHandle && !updateDirHandle) {
    versionOverview = {
      html: {
        localVersion: null,
        updateVersion: null,
        localFileName: HTML_FILE_NAME,
        updateFileName: null
      },
      modules: []
    };
    htmlUpdateChangelogHandle = null;
    htmlUpdateChangelogFileName = null;
    cachedHtmlChangelogSections = null;
    htmlChangelogSourceLabel = null;
    pendingUpdates = [];
    rerunUpdateCheckWhenUnlocked = false;
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    renderUpdateList();
    return;
  }

  if (rootDirHandle && updateDirHandle) {
    updateCheckInProgress = true;
    rerunUpdateCheckWhenUnlocked = false;
    setUpdateStatusButton('checking');
    if (updateCheckStatus) updateCheckStatus.textContent = 'Prüfung läuft…';
  } else {
    rerunUpdateCheckWhenUnlocked = false;
  }

  try {
    const result = await collectVersionDiffs(updateDirHandle, rootDirHandle);
    versionOverview = result.overview;
    pendingUpdates = rootDirHandle && updateDirHandle ? result.diffs : [];
    htmlUpdateChangelogHandle = result.htmlChangelogHandle || null;
    htmlUpdateChangelogFileName = result.htmlChangelogFileName || null;
    cachedHtmlChangelogSections = null;
    htmlChangelogSourceLabel = null;
    lastUpdateError = false;
    if (updateCheckStatus && rootDirHandle && updateDirHandle) {
      if (!pendingUpdates.length) {
        updateCheckStatus.textContent = 'Letzte Prüfung abgeschlossen.';
      } else {
        updateCheckStatus.textContent = `${pendingUpdates.length} Update${pendingUpdates.length === 1 ? '' : 's'} verfügbar.`;
      }
    }
    if (updateCheckStatus && (!rootDirHandle || !updateDirHandle)) {
      updateCheckStatus.textContent = '';
    }
  } catch (err) {
    console.error('Update-Prüfung fehlgeschlagen', err);
    pendingUpdates = [];
    htmlUpdateChangelogHandle = null;
    htmlUpdateChangelogFileName = null;
    cachedHtmlChangelogSections = null;
    htmlChangelogSourceLabel = null;
    lastUpdateError = true;
    if (updateCheckStatus && rootDirHandle && updateDirHandle) {
      updateCheckStatus.textContent = 'Fehler bei der Prüfung.';
    }
    try {
      const fallback = await collectVersionDiffs(null, rootDirHandle);
      versionOverview = fallback.overview;
      htmlUpdateChangelogHandle = fallback.htmlChangelogHandle || null;
      htmlUpdateChangelogFileName = fallback.htmlChangelogFileName || null;
    } catch {}
  } finally {
    updateCheckInProgress = false;
    renderUpdateList();
    if (rerunUpdateCheckWhenUnlocked && !pendingRootPermission && !pendingUpdatePermission) {
      rerunUpdateCheckWhenUnlocked = false;
      await runUpdateCheck();
    }
  }
}

function stopAutomaticUpdatePolling() {
  if (updatePollingIntervalId !== null) {
    window.clearInterval(updatePollingIntervalId);
    updatePollingIntervalId = null;
  }
}

async function triggerAutomaticUpdateCheck() {
  if (!appSettings.autoUpdatePolling) return;
  if (typeof document !== 'undefined' && document.hidden) return;
  try {
    await runUpdateCheck();
  } catch (err) {
    console.error('Automatische Update-Prüfung fehlgeschlagen', err);
  }
}

function startAutomaticUpdatePolling({ immediate = false } = {}) {
  stopAutomaticUpdatePolling();
  if (!appSettings.autoUpdatePolling) return;

  if (immediate) {
    void triggerAutomaticUpdateCheck();
  }

  updatePollingIntervalId = window.setInterval(() => {
    if (!appSettings.autoUpdatePolling) {
      stopAutomaticUpdatePolling();
      return;
    }
    void triggerAutomaticUpdateCheck();
  }, UPDATE_POLL_INTERVAL_MS);
}

function updateAutoPollingState(options = {}) {
  if (appSettings.autoUpdatePolling) {
    startAutomaticUpdatePolling(options);
  } else {
    stopAutomaticUpdatePolling();
  }
}

function activateSettingsSection(section) {
  document.querySelectorAll('.settings-nav button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.section === section);
  });
  document.querySelectorAll('.settings-section').forEach(sec => {
    sec.classList.toggle('active', sec.id === `section-${section}`);
  });
}

function openSettings(section = 'general') {
  if (!settingsModal) return;
  populateInputsFromSettings();
  activateSettingsSection(section);
  closeHistoryMenu();
  settingsModal.classList.remove('hidden');
}

function renderModuleColorLayers(layers = appSettings.moduleColorLayers) {
  if (!moduleColorLayersContainer) return;
  const normalized = normalizeModuleColorLayers(layers);
  appSettings.moduleColorLayers = normalized;
  moduleColorLayersContainer.innerHTML = '';
  normalized.forEach((layer, index) => {
    const layerEl = createModuleColorLayerElement(layer, index);
    moduleColorLayersContainer.appendChild(layerEl);
  });
  updateModuleColorLayerAddState();
  updateModuleColorLayerRemoveStates();
}

function createModuleColorLayerElement(layer, index) {
  const wrapper = document.createElement('div');
  wrapper.className = 'module-color-layer';
  wrapper.dataset.index = String(index);
  wrapper.dataset.id = layer.id;
  wrapper.innerHTML = `
    <div class="module-color-preview">
      <div class="module-preview-card" data-layer="module">
        <span class="module-layer-badge"></span>
        <div class="module-preview-topbar">
          <span class="module-preview-pill module-preview-pill--title" data-layer="header" data-layer-part="accent">Modulübersicht</span>
          <span class="module-preview-pill module-preview-pill--meta" data-layer="sub" data-layer-part="accent">Status aktiv</span>
          <span class="module-preview-pill module-preview-pill--meta" data-layer="sub" data-layer-part="accent">08 Karten</span>
        </div>
        <div class="module-preview-layout">
          <div class="module-preview-stack">
            <div class="module-preview-cluster" data-layer="header" data-layer-part="cluster">
              <span class="module-preview-bubble module-preview-bubble--primary" data-layer="header" data-layer-part="accent">Cluster A</span>
              <div class="module-preview-field" data-layer="header" data-layer-part="panel">Beschreibung für Cluster A</div>
            </div>
            <div class="module-preview-cluster" data-layer="sub" data-layer-part="cluster">
              <span class="module-preview-bubble module-preview-bubble--alt" data-layer="sub" data-layer-part="accent">Cluster B</span>
              <div class="module-preview-field" data-layer="sub" data-layer-part="panel">Beschreibung für Cluster B</div>
            </div>
            <div class="module-preview-cluster module-preview-cluster--dual" data-layer="sub" data-layer-part="cluster">
              <span class="module-preview-bubble module-preview-bubble--alt" data-layer="sub" data-layer-part="accent">Details</span>
              <div class="module-preview-field-row">
                <div class="module-preview-field module-preview-field--mini" data-layer="sub" data-layer-part="panel">Label</div>
                <div class="module-preview-field module-preview-field--mini" data-layer="sub" data-layer-part="panel">Wert</div>
              </div>
            </div>
          </div>
          <div class="module-preview-surface module-preview-surface--main" data-layer="sub" data-layer-part="panel">
            <span>Modulinhalte</span>
            <span class="module-preview-surface-line">Platz für Tabellen, Listen &amp; Widgets</span>
          </div>
          <div class="module-preview-surface module-preview-surface--meta" data-layer="header" data-layer-part="panel">
            <span>Kontextbereich</span>
            <span class="module-preview-surface-line">Filter, Aktionen oder Hinweise</span>
          </div>
        </div>
      </div>
    </div>
    <div class="module-layer-controls">
      <div class="module-layer-name-field">
        <label>Layer Name</label>
        <input type="text" class="module-layer-name border rounded px-2 py-1 text-sm w-full" maxlength="40">
      </div>
      <div class="module-layer-groups">
        <div class="module-layer-group" data-group="module">
          <div class="module-layer-group-title">Hauptmodul</div>
          <div class="module-layer-group-grid">
            <label class="module-layer-color">
              <span>Hintergrund</span>
              <input type="color" data-field="moduleBg" class="border rounded">
            </label>
            <label class="module-layer-color">
              <span>Text</span>
              <input type="color" data-field="moduleText" class="border rounded">
            </label>
            <label class="module-layer-color">
              <span>Rahmen</span>
              <input type="color" data-field="moduleBorder" class="border rounded">
            </label>
          </div>
        </div>
        <div class="module-layer-group" data-group="header">
          <div class="module-layer-group-title">Überschrift Layer</div>
          <div class="module-layer-group-grid">
            <label class="module-layer-color">
              <span>Hintergrund</span>
              <input type="color" data-field="headerBg" class="border rounded">
            </label>
            <label class="module-layer-color">
              <span>Text</span>
              <input type="color" data-field="headerText" class="border rounded">
            </label>
            <label class="module-layer-color">
              <span>Rahmen</span>
              <input type="color" data-field="headerBorder" class="border rounded">
            </label>
          </div>
        </div>
        <div class="module-layer-group" data-group="sub">
          <div class="module-layer-group-title">Unter-Layer</div>
          <div class="module-layer-group-grid">
            <label class="module-layer-color">
              <span>Hintergrund</span>
              <input type="color" data-field="subBg" class="border rounded">
            </label>
            <label class="module-layer-color">
              <span>Text</span>
              <input type="color" data-field="subText" class="border rounded">
            </label>
            <label class="module-layer-color">
              <span>Rahmen</span>
              <input type="color" data-field="subBorder" class="border rounded">
            </label>
          </div>
        </div>
      </div>
      <div class="module-layer-actions">
        <button type="button" class="module-layer-duplicate">Duplizieren</button>
        <button type="button" class="module-layer-remove">Entfernen</button>
      </div>
    </div>
  `;
  const badge = wrapper.querySelector('.module-layer-badge');
  if (badge) badge.textContent = `Layer ${index + 1}`;
  const nameInput = wrapper.querySelector('.module-layer-name');
  if (nameInput) nameInput.value = layer.name || '';
  const moduleBgInput = wrapper.querySelector('input[data-field="moduleBg"]');
  const moduleTextInput = wrapper.querySelector('input[data-field="moduleText"]');
  const moduleBorderInput = wrapper.querySelector('input[data-field="moduleBorder"]');
  const headerBgInput = wrapper.querySelector('input[data-field="headerBg"]');
  const headerTextInput = wrapper.querySelector('input[data-field="headerText"]');
  const headerBorderInput = wrapper.querySelector('input[data-field="headerBorder"]');
  const subBgInput = wrapper.querySelector('input[data-field="subBg"]');
  const subTextInput = wrapper.querySelector('input[data-field="subText"]');
  const subBorderInput = wrapper.querySelector('input[data-field="subBorder"]');
  if (moduleBgInput) moduleBgInput.value = layer.moduleBg;
  if (moduleTextInput) moduleTextInput.value = layer.moduleText;
  if (moduleBorderInput) moduleBorderInput.value = layer.moduleBorder;
  if (headerBgInput) headerBgInput.value = layer.headerBg;
  if (headerTextInput) headerTextInput.value = layer.headerText;
  if (headerBorderInput) headerBorderInput.value = layer.headerBorder;
  if (subBgInput) subBgInput.value = layer.subBg;
  if (subTextInput) subTextInput.value = layer.subText;
  if (subBorderInput) subBorderInput.value = layer.subBorder;
  applyModuleColorLayerPreview(wrapper, layer);
  return wrapper;
}

function applyModuleColorLayerPreview(layerEl, layer) {
  if (!layerEl || !layer) return;
  const ensureColor = (value, fallback) => (typeof value === 'string' && value.trim() ? value : fallback);
  const moduleBg = ensureColor(layer.moduleBg, '#005983');
  const moduleText = ensureColor(layer.moduleText, '#ffffff');
  const moduleBorder = ensureColor(layer.moduleBorder, moduleText);
  const headerBg = ensureColor(layer.headerBg, moduleBg);
  const headerText = ensureColor(layer.headerText, moduleText);
  const headerBorder = ensureColor(layer.headerBorder, headerBg);
  const subBg = ensureColor(layer.subBg, moduleBg);
  const subText = ensureColor(layer.subText, moduleText);
  const subBorder = ensureColor(layer.subBorder, subBg);

  const card = layerEl.querySelector('.module-preview-card');
  if (card) {
    card.style.backgroundColor = moduleBg;
    card.style.color = moduleText;
    card.style.borderColor = moduleBorder;
    const outerShadow = hexToRgba(moduleBorder, 0.28) || 'rgba(17,24,39,0.18)';
    const innerOutline = hexToRgba(moduleText, 0.14) || 'rgba(255,255,255,0.12)';
    card.style.boxShadow = `0 12px 24px ${outerShadow}, inset 0 0 0 1px ${innerOutline}`;
  }
  const badge = layerEl.querySelector('.module-layer-badge');
  if (badge) {
    badge.style.backgroundColor = moduleText;
    badge.style.color = moduleBg;
    badge.style.borderColor = moduleBorder;
  }

  const applyToPart = (group, part, background, color, borderColor) => {
    const nodes = layerEl.querySelectorAll(`[data-layer="${group}"][data-layer-part="${part}"]`);
    nodes.forEach(node => {
      if (background !== undefined) node.style.backgroundColor = background;
      if (color !== undefined) node.style.color = color;
      if (borderColor !== undefined) node.style.borderColor = borderColor;
    });
  };

  const headerClusterBg = hexToRgba(headerBg, 0.18) || headerBg;
  const headerPanelBg = hexToRgba(headerBg, 0.26) || headerBg;
  applyToPart('header', 'cluster', headerClusterBg, headerText, headerBorder);
  applyToPart('header', 'panel', headerPanelBg, headerText, headerBorder);
  applyToPart('header', 'accent', headerBg, headerText, headerBorder);

  const subClusterBg = hexToRgba(subBg, 0.18) || subBg;
  const subPanelBg = hexToRgba(subBg, 0.26) || subBg;
  applyToPart('sub', 'cluster', subClusterBg, subText, subBorder);
  applyToPart('sub', 'panel', subPanelBg, subText, subBorder);
  applyToPart('sub', 'accent', subBg, subText, subBorder);

  const neutralFields = layerEl.querySelectorAll('.module-preview-field:not([data-layer])');
  const neutralBg = hexToRgba(moduleText, 0.12) || 'rgba(255,255,255,0.12)';
  const neutralBorder = hexToRgba(moduleBorder, 0.22) || moduleBorder;
  neutralFields.forEach(field => {
    field.style.backgroundColor = neutralBg;
    field.style.borderColor = neutralBorder;
    field.style.color = moduleText;
  });
}

function updateModuleColorLayerAddState() {
  if (!addModuleColorLayerBtn) return;
  const atLimit = Array.isArray(appSettings.moduleColorLayers) && appSettings.moduleColorLayers.length >= MAX_MODULE_COLOR_LAYERS;
  addModuleColorLayerBtn.disabled = atLimit;
}

function updateModuleColorLayerRemoveStates() {
  if (!moduleColorLayersContainer) return;
  const allowRemove = Array.isArray(appSettings.moduleColorLayers) && appSettings.moduleColorLayers.length > 1;
  moduleColorLayersContainer.querySelectorAll('.module-layer-remove').forEach(btn => {
    btn.disabled = !allowRemove;
  });
}

function collectModuleColorLayersFromDom() {
  if (!moduleColorLayersContainer) return [];
  const layers = [];
  moduleColorLayersContainer.querySelectorAll('.module-color-layer').forEach((layerEl, index) => {
    let id = typeof layerEl.dataset.id === 'string' && layerEl.dataset.id.trim() ? layerEl.dataset.id : '';
    if (!id) {
      id = generateLayerId();
      layerEl.dataset.id = id;
    }
    const nameInput = layerEl.querySelector('.module-layer-name');
    const getColor = field => {
      const input = layerEl.querySelector(`input[data-field="${field}"]`);
      return input ? input.value : '';
    };
    layers.push({
      id,
      name: nameInput ? nameInput.value : `Layer ${index + 1}`,
      moduleBg: getColor('moduleBg'),
      moduleText: getColor('moduleText'),
      moduleBorder: getColor('moduleBorder'),
      headerBg: getColor('headerBg'),
      headerText: getColor('headerText'),
      headerBorder: getColor('headerBorder'),
      subBg: getColor('subBg'),
      subText: getColor('subText'),
      subBorder: getColor('subBorder')
    });
  });
  return layers;
}

function handleModuleColorLayerInput(event) {
  if (!(event.target instanceof HTMLInputElement)) return;
  const layerEl = event.target.closest('.module-color-layer');
  if (!layerEl) return;
  appSettings.moduleColorLayers = collectModuleColorLayersFromDom();
  const index = Number(layerEl.dataset.index || '0');
  const layer = appSettings.moduleColorLayers[index];
  applyModuleColorLayerPreview(layerEl, layer);
  scheduleSettingsSave();
}

function handleModuleColorLayerClick(event) {
  const removeBtn = event.target.closest('.module-layer-remove');
  const duplicateBtn = event.target.closest('.module-layer-duplicate');
  if (removeBtn) {
    const layerEl = removeBtn.closest('.module-color-layer');
    if (!layerEl) return;
    if (!Array.isArray(appSettings.moduleColorLayers) || appSettings.moduleColorLayers.length <= 1) {
      return;
    }
    const index = Number(layerEl.dataset.index || '0');
    appSettings.moduleColorLayers.splice(index, 1);
    renderModuleColorLayers(appSettings.moduleColorLayers);
    scheduleSettingsSave();
    return;
  }
  if (duplicateBtn) {
    const layerEl = duplicateBtn.closest('.module-color-layer');
    if (!layerEl) return;
    if (!Array.isArray(appSettings.moduleColorLayers)) {
      appSettings.moduleColorLayers = [];
    }
    if (appSettings.moduleColorLayers.length >= MAX_MODULE_COLOR_LAYERS) {
      updateModuleColorLayerAddState();
      return;
    }
    const index = Number(layerEl.dataset.index || '0');
    const sourceLayer = appSettings.moduleColorLayers[index];
    const clone = {
      ...sourceLayer,
      id: generateLayerId(),
      name: `${sourceLayer.name || `Layer ${index + 1}`}-Kopie`
    };
    appSettings.moduleColorLayers.splice(index + 1, 0, clone);
    renderModuleColorLayers(appSettings.moduleColorLayers);
    scheduleSettingsSave();
  }
}

function scheduleSettingsSave() {
  if (settingsSaveTimeoutId !== null) {
    clearTimeout(settingsSaveTimeoutId);
  }
  settingsSaveTimeoutId = window.setTimeout(() => {
    settingsSaveTimeoutId = null;
    saveAppSettings();
  }, 400);
}

function flushSettingsSave() {
  if (settingsSaveTimeoutId !== null) {
    clearTimeout(settingsSaveTimeoutId);
    settingsSaveTimeoutId = null;
  }
  saveAppSettings();
}

function openHistoryMenu() {
  if (!historyMenuDropdown || !historyMenuToggle) return;
  historyMenuDropdown.classList.remove('hidden');
  historyMenuToggle.setAttribute('aria-expanded', 'true');
  historyMenuOpen = true;
}

function closeHistoryMenu() {
  if (!historyMenuDropdown || !historyMenuToggle) {
    historyMenuOpen = false;
    return false;
  }
  if (!historyMenuDropdown.classList.contains('hidden')) {
    historyMenuDropdown.classList.add('hidden');
  }
  historyMenuToggle.setAttribute('aria-expanded', 'false');
  historyMenuOpen = false;
  return true;
}

function toggleHistoryMenu() {
  if (historyMenuOpen) {
    closeHistoryMenu();
  } else {
    openHistoryMenu();
  }
}

function hideSettingsModal() {
  if (!settingsModal || settingsModal.classList.contains('hidden')) return false;
  settingsModal.classList.add('hidden');
  flushSettingsSave();
  return true;
}


document.addEventListener('DOMContentLoaded', async () => {
  // Initialize sidebar collapsed state
  sidebarEl.classList.add('collapsed');
  // Trigger fade-in animation on initial load
  document.body.classList.add('fade-in');

  setUpdateStatusButton();
  renderUpdateList();
  updateUndoRedoButtons();
  updateDowngradeCollapseUI();
  setSaveIndicator('saved');
  if (historyMenuToggle) {
    historyMenuToggle.addEventListener('click', event => {
      event.stopPropagation();
      if (historyMenuToggle.disabled) return;
      toggleHistoryMenu();
    });
  }

  document.addEventListener('click', event => {
    if (!historyMenuOpen) return;
    if (historyMenu && historyMenu.contains(event.target)) return;
    closeHistoryMenu();
  });
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && appSettings.autoUpdatePolling) {
      void triggerAutomaticUpdateCheck();
    }
  });
  if (moduleSearchClearBtn) {
    moduleSearchClearBtn.classList.toggle('hidden', !(moduleSearchInput && moduleSearchInput.value));
  }

  if (moduleSearchInput) {
    moduleSearchInput.addEventListener('input', () => {
      sidebarSearchTerm = moduleSearchInput.value || '';
      if (moduleSearchClearBtn) moduleSearchClearBtn.classList.toggle('hidden', !moduleSearchInput.value);
      renderSidebar();
    });
  }

  if (moduleSearchClearBtn) {
    moduleSearchClearBtn.addEventListener('click', () => {
      if (!moduleSearchInput) return;
      moduleSearchInput.value = '';
      sidebarSearchTerm = '';
      moduleSearchClearBtn.classList.add('hidden');
      renderSidebar();
      moduleSearchInput.focus();
    });
  }

  if (downgradeToggle) {
    downgradeToggle.addEventListener('click', () => {
      downgradeCollapsed = !downgradeCollapsed;
      updateDowngradeCollapseUI();
      try {
        localStorage.setItem(DOWNGRADE_COLLAPSE_KEY, downgradeCollapsed ? '1' : '0');
      } catch (e) {}
    });
  }

  if (undoBtn) {
    undoBtn.addEventListener('click', async () => {
      if (!undoStack.length || historyInProgress) return;
      closeHistoryMenu();
      historyInProgress = true;
      const snapshot = undoStack.pop();
      const currentSnapshot = captureLayoutSnapshot();
      redoStack.push(JSON.parse(JSON.stringify(currentSnapshot)));
      updateUndoRedoButtons();
      try {
        if (snapshot) await restoreLayoutFromSnapshot(snapshot);
      } finally {
        historyInProgress = false;
        updateUndoRedoButtons();
      }
    });
  }

  if (redoBtn) {
    redoBtn.addEventListener('click', async () => {
      if (!redoStack.length || historyInProgress) return;
      closeHistoryMenu();
      historyInProgress = true;
      const snapshot = redoStack.pop();
      const currentSnapshot = captureLayoutSnapshot();
      undoStack.push(JSON.parse(JSON.stringify(currentSnapshot)));
      updateUndoRedoButtons();
      try {
        if (snapshot) await restoreLayoutFromSnapshot(snapshot);
      } finally {
        historyInProgress = false;
        updateUndoRedoButtons();
      }
    });
  }

  // Sidebar toggle
  sidebarToggle.addEventListener('click', () => {
    isSidebarOpen = !isSidebarOpen;
    sidebarEl.classList.toggle('collapsed', !isSidebarOpen);
    updateModuleDraggable();
    updateGridDraggable();
  });

  // Folder selection
  rootBtn.addEventListener('click', async () => {
    if (pendingRootPermission && rootDirHandle) {
      try {
        const granted = await ensureRWPermission(rootDirHandle, { mode: 'readwrite' });
        if (granted) {
          pendingRootPermission = false;
          rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
          rootBtn.classList.remove('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
          rootBtn.title = '';
          rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
          await loadModulesFromRoot(rootDirHandle);
          await loadAppSettings();
          applySettings();
          await loadAndInitTabs();
          await runUpdateCheck();
          return;
        }
      } catch (err) {
        console.warn('Erneute Berechtigungsabfrage für Arbeitsordner fehlgeschlagen', err);
      }
    }
    if (window.showDirectoryPicker) {
      try {
        rootDirHandle = await window.showDirectoryPicker();
        setGlobalHandle('root', rootDirHandle);                    // expose
        rootBtn.textContent = rootDirHandle.name;
        await idbSet(FS_HANDLE_KEY, rootDirHandle);                // persist handle
        try { localStorage.setItem(ROOT_HANDLE_NAME_KEY, rootDirHandle.name); } catch (e) {
          console.warn('Konnte Arbeitsordnernamen nicht speichern', e);
        }
        localStorage.setItem('rememberRootMeta', JSON.stringify({  // optional UI hint
          name: rootDirHandle.name, ts: Date.now()
        }));
        rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
        rootBtn.classList.remove('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
        rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
        pendingRootPermission = false;
        rootBtn.title = '';
        await loadModulesFromRoot(rootDirHandle);
        await loadAppSettings();
        applySettings();
        await loadAndInitTabs();
        // ensure grid state reflects current sidebar state
        updateModuleDraggable();
        updateGridDraggable();
        await runUpdateCheck();
      } catch (e) {
        console.warn(e);
        alert('Ordnerauswahl abgebrochen oder nicht erlaubt.');
      }
    } else {
      const inp = document.getElementById('folder-input');
      inp.onchange = async e => {
        const files = Array.from(e.target.files);
        if (!files.length) return;
        setGlobalHandle('root', null);              // not reusable
        await idbDel(FS_HANDLE_KEY);                // forget saved handle
        localStorage.removeItem('rememberRootMeta');
        const any = files[0];
        const parts = any.webkitRelativePath.split('/');
        const rootName = parts[0];
        rootBtn.textContent = rootName;
        rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
        rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
        pendingRootPermission = false;
        rootBtn.title = '';
        try { localStorage.setItem(ROOT_HANDLE_NAME_KEY, rootName); } catch (e) {
          console.warn('Konnte Arbeitsordnernamen nicht speichern', e);
        }
        await loadModulesFromFileList(files, rootName);
        await loadAndInitTabs();
        inp.value = null;
        updateModuleDraggable();
        updateGridDraggable();
        pendingUpdates = [];
        renderUpdateList();
      };
      inp.click();
    }
  });

  if (selectUpdateFolderBtn) {
    selectUpdateFolderBtn.addEventListener('click', async () => {
      if (!('showDirectoryPicker' in window)) {
        alert('Update-Ordner können nur mit einem kompatiblen Browser gewählt werden.');
        return;
      }
      if (pendingUpdatePermission && updateDirHandle) {
        try {
          const granted = await ensureRWPermission(updateDirHandle, { mode: 'read' });
          if (granted) {
            pendingUpdatePermission = false;
            if (updateFolderNameEl) updateFolderNameEl.textContent = updateDirHandle.name;
            await runUpdateCheck();
            return;
          }
        } catch (err) {
          console.warn('Erneute Berechtigungsabfrage für Update-Ordner fehlgeschlagen', err);
        }
      }
      try {
        const handle = await window.showDirectoryPicker();
        const granted = await ensureRWPermission(handle, { mode: 'read' });
        if (!granted) {
          alert('Der Zugriff auf den Update-Ordner wurde nicht erlaubt.');
          return;
        }
        updateDirHandle = handle;
        setGlobalHandle('update', updateDirHandle);
        htmlUpdateChangelogHandle = null;
        htmlUpdateChangelogFileName = null;
        cachedHtmlChangelogSections = null;
        htmlChangelogSourceLabel = null;
        if (updateFolderNameEl) updateFolderNameEl.textContent = handle.name;
        try { localStorage.setItem(UPDATE_HANDLE_NAME_KEY, handle.name); } catch (e) {
          console.warn('Konnte Update-Ordnernamen nicht speichern', e);
        }
        await idbSet(UPDATE_HANDLE_KEY, handle);
        pendingUpdatePermission = false;
        await runUpdateCheck();
      } catch (e) {
        if (e?.name !== 'AbortError') {
          console.warn('Update-Ordner Auswahl fehlgeschlagen', e);
          alert('Der Update-Ordner konnte nicht gewählt werden.');
        }
      }
    });
  }

  if (clearUpdateFolderBtn) {
    clearUpdateFolderBtn.addEventListener('click', async () => {
      updateDirHandle = null;
      setGlobalHandle('update', updateDirHandle);
      if (updateFolderNameEl) updateFolderNameEl.textContent = 'Keiner gewählt';
      try { localStorage.removeItem(UPDATE_HANDLE_NAME_KEY); } catch (e) {
        console.warn('Konnte Update-Ordnernamen nicht entfernen', e);
      }
      await idbDel(UPDATE_HANDLE_KEY);
      pendingUpdatePermission = false;
      pendingUpdates = [];
      htmlUpdateChangelogHandle = null;
      htmlUpdateChangelogFileName = null;
      cachedHtmlChangelogSections = null;
      htmlChangelogSourceLabel = null;
      versionOverview = {
        html: {
          localVersion: versionOverview.html?.localVersion || null,
          updateVersion: null,
          localFileName: versionOverview.html?.localFileName || HTML_FILE_NAME,
          updateFileName: null
        },
        modules: versionOverview.modules.map(mod => ({
          ...mod,
          updateVersion: null,
          newVersion: mod.localVersion ?? null,
          currentVersion: mod.localVersion ?? null,
          updateDirHandle: null,
          updateRelPath: null,
          sourceRelPath: mod.localRelPath || null,
          changelogHandle: null,
          changelogFileName: null,
          changelogPath: null,
          changelogRelativePath: null
        }))
      };
      renderUpdateList();
      await runUpdateCheck();
    });
  }

  if (updateStatusBtn) {
    updateStatusBtn.addEventListener('click', () => {
      if (updateStatusBtn.disabled) return;
      openSettings('updates');
    });
  }

  if (updateAllBtn) {
    updateAllBtn.addEventListener('click', async () => {
      if (updateAllBtn.disabled || !currentUpgradeItems.length) return;

      const itemsToUpdate = currentUpgradeItems.slice();
      const originalText = updateAllBtn.textContent;
      updateAllBtn.disabled = true;
      updateAllBtn.classList.add('opacity-60','cursor-wait','cursor-not-allowed');
      updateAllBtn.textContent = 'Aktualisiere…';

      if (updatesTableBody) {
        updatesTableBody.querySelectorAll('button').forEach(btn => {
          btn.disabled = true;
          btn.classList.add('opacity-60','cursor-not-allowed');
        });
      }

      let encounteredError = false;
      try {
        for (const item of itemsToUpdate) {
          try {
            await applySingleUpdate(item, { skipRecheck: true });
          } catch (err) {
            encounteredError = true;
            console.error('Fehler beim Aktualisieren', err);
          }
        }
      } catch (err) {
        encounteredError = true;
        console.error('Fehler beim Aktualisieren', err);
      } finally {
        try {
          await runUpdateCheck();
        } catch (err) {
          encounteredError = true;
          console.error('Fehler beim Aktualisieren', err);
        }
        updateAllBtn.disabled = false;
        updateAllBtn.classList.remove('opacity-60','cursor-wait','cursor-not-allowed');
        updateAllBtn.textContent = originalText;
        if (encounteredError) {
          alert('Beim Aktualisieren ist ein Fehler aufgetreten.');
        }
      }
    });
  }

  // Add new tab
  addTabBtn.addEventListener('click', () => {
    const name = prompt('Name für neuen Tab:', 'Neuer Tab');
    if (!name) return;
    createTab(name);
    renderTabs();
    activateTab(tabs.length - 1);
    updateModuleDraggable();
    updateGridDraggable();
    saveLayout();
  });

  // Settings open
  if (settingsBtn) {
    settingsBtn.addEventListener('click', () => {
      openSettings('general');
    });
  }
  if (closeSettingsBtn) {
    closeSettingsBtn.addEventListener('click', () => {
      hideSettingsModal();
    });
  }
  // Settings nav
  settingsNavButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      activateSettingsSection(btn.dataset.section);
    });
  });
  // Live preview for colours
  [inputAppBg,inputBorderColor,inputButtonBg,inputButtonText,inputTopBarBg,inputTabActiveBg,inputTabActiveText,inputTabInactiveBg,inputTabInactiveText,inputSidebarBg,inputSidebarText,inputGridHint,inputModuleBg,inputTextColor,inputModuleHeaderBg,inputModuleHeaderText,inputDangerBg,inputDangerText,inputModuleBorderColor,inputSidebarModuleBg,inputSidebarModuleText,inputSidebarModuleBorder].forEach(inp => {
    inp.addEventListener('input', () => {
      readInputsIntoSettings();
      applySettings();
      renderTabs();
      scheduleSettingsSave();
    });
  });
  if (moduleColorLayersContainer) {
    moduleColorLayersContainer.addEventListener('input', handleModuleColorLayerInput);
    moduleColorLayersContainer.addEventListener('change', handleModuleColorLayerInput);
    moduleColorLayersContainer.addEventListener('click', handleModuleColorLayerClick);
  }
  if (addModuleColorLayerBtn) {
    addModuleColorLayerBtn.addEventListener('click', () => {
      if (!Array.isArray(appSettings.moduleColorLayers)) {
        appSettings.moduleColorLayers = normalizeModuleColorLayers([]);
      }
      if (appSettings.moduleColorLayers.length >= MAX_MODULE_COLOR_LAYERS) {
        updateModuleColorLayerAddState();
        return;
      }
      const lastLayer = appSettings.moduleColorLayers[appSettings.moduleColorLayers.length - 1] || createColorLayer(
        `Layer ${appSettings.moduleColorLayers.length + 1}`,
        '#005983',
        '#ffffff',
        '#0f6ab4',
        '#0f6ab4',
        '#ffffff',
        '#0a487a',
        '#07365b',
        '#ffffff',
        '#052b47'
      );
      const newLayer = {
        ...lastLayer,
        id: generateLayerId(),
        name: `Layer ${appSettings.moduleColorLayers.length + 1}`
      };
      appSettings.moduleColorLayers.push(newLayer);
      renderModuleColorLayers(appSettings.moduleColorLayers);
      scheduleSettingsSave();
    });
  }
  if (inputShowUpdateButton) {
    inputShowUpdateButton.addEventListener('change', () => {
      appSettings.showUpdateStatusButton = inputShowUpdateButton.checked;
      setUpdateStatusButton();
      scheduleSettingsSave();
    });
  }
  if (inputUpdateAutoPoll) {
    inputUpdateAutoPoll.addEventListener('change', () => {
      appSettings.autoUpdatePolling = inputUpdateAutoPoll.checked;
      updateAutoPollingState({ immediate: inputUpdateAutoPoll.checked });
      scheduleSettingsSave();
    });
  }
  if (inputHideDowngradeButton) {
    inputHideDowngradeButton.addEventListener('change', () => {
      appSettings.hideDowngradeStatusButton = inputHideDowngradeButton.checked;
      setUpdateStatusButton();
      scheduleSettingsSave();
    });
  }
  if (inputAutoArrange) {
    inputAutoArrange.addEventListener('change', () => {
      readInputsIntoSettings();
      applySettings();
      scheduleSettingsSave();
    });
  }
  inputBorderRadius.addEventListener('input', () => {
    appSettings.moduleBorderRadius = ((parseFloat(inputBorderRadius.value)||0)/16) + 'rem';
    applySettings();
    scheduleSettingsSave();
  });

  /* First tab on initial load */
  createTab('Standard');
  renderTabs();
  activateTab(0, { skipSave: true });
  updateModuleDraggable();
  updateGridDraggable();
  updateGridAutoArrange();

  // --- Try to restore AFTER wiring handlers ---
  const restoredRoot = await tryRestoreRootHandle();
  await tryRestoreUpdateHandle();
  if (restoredRoot) {
    updateModuleDraggable();
    updateGridDraggable();
  }
  await runUpdateCheck();
});

/** Populate inputs from appSettings */
function populateInputsFromSettings() {
  inputAppBg.value = toColor(appSettings.appBgColor, inputAppBg.value);
  inputBorderColor.value = toColor(appSettings.borderColor, inputBorderColor.value);
  inputButtonBg.value = toColor(appSettings.buttonBg, inputButtonBg.value);
  inputButtonText.value = toColor(appSettings.buttonText, inputButtonText.value);
  inputTopBarBg.value = toColor(appSettings.topBarBg, inputTopBarBg.value);
  inputTabActiveBg.value = toColor(appSettings.tabActiveBg, inputTabActiveBg.value);
  inputTabActiveText.value = toColor(appSettings.tabActiveText, inputTabActiveText.value);
  inputTabInactiveBg.value = toColor(appSettings.tabInactiveBg, inputTabInactiveBg.value);
  inputTabInactiveText.value = toColor(appSettings.tabInactiveText, inputTabInactiveText.value);
  inputSidebarBg.value = toColor(appSettings.sidebarBg, inputSidebarBg.value);
  inputSidebarText.value = toColor(appSettings.sidebarText, inputSidebarText.value);
  inputGridHint.value = toColor(appSettings.gridHint, inputGridHint.value);
  if (inputAutoArrange) inputAutoArrange.checked = !!appSettings.autoArrangeModules;
  inputModuleBg.value = toColor(appSettings.moduleBgColor, inputModuleBg.value);
  inputTextColor.value = toColor(appSettings.textColor, inputTextColor.value);
  inputBorderRadius.value = Math.round(parseFloat(appSettings.moduleBorderRadius) * 16 || 0);
  inputModuleHeaderBg.value = toColor(appSettings.moduleHeaderBg, inputModuleHeaderBg.value);
  inputModuleHeaderText.value = toColor(appSettings.moduleHeaderText, inputModuleHeaderText.value);
  inputDangerBg.value = toColor(appSettings.dangerBg, inputDangerBg.value);
  inputDangerText.value = toColor(appSettings.dangerText, inputDangerText.value);

  renderModuleColorLayers(appSettings.moduleColorLayers);

  // New module border and sidebar module card settings
  if (inputModuleBorderColor) inputModuleBorderColor.value = toColor(appSettings.moduleBorderColor, inputModuleBorderColor.value);
  if (inputSidebarModuleBg) inputSidebarModuleBg.value = toColor(appSettings.sidebarModuleCardBg, inputSidebarModuleBg.value);
  if (inputSidebarModuleText) inputSidebarModuleText.value = toColor(appSettings.sidebarModuleCardText, inputSidebarModuleText.value);
  if (inputSidebarModuleBorder) inputSidebarModuleBorder.value = toColor(appSettings.sidebarModuleCardBorder, inputSidebarModuleBorder.value);
  if (inputShowUpdateButton) inputShowUpdateButton.checked = appSettings.showUpdateStatusButton !== false;
  if (inputUpdateAutoPoll) inputUpdateAutoPoll.checked = !!appSettings.autoUpdatePolling;
  if (inputHideDowngradeButton) inputHideDowngradeButton.checked = !!appSettings.hideDowngradeStatusButton;
}

/** Read inputs into appSettings */
function readInputsIntoSettings() {
  appSettings.appBgColor = inputAppBg.value;
  appSettings.borderColor = inputBorderColor.value;
  appSettings.buttonBg = inputButtonBg.value;
  appSettings.buttonText = inputButtonText.value;
  appSettings.topBarBg = inputTopBarBg.value;
  appSettings.tabActiveBg = inputTabActiveBg.value;
  appSettings.tabActiveText = inputTabActiveText.value;
  appSettings.tabInactiveBg = inputTabInactiveBg.value;
  appSettings.tabInactiveText = inputTabInactiveText.value;
  appSettings.sidebarBg = inputSidebarBg.value;
  appSettings.sidebarText = inputSidebarText.value;
  appSettings.gridHint = inputGridHint.value;
  if (inputAutoArrange) appSettings.autoArrangeModules = inputAutoArrange.checked;
  appSettings.moduleBgColor = inputModuleBg.value;
  appSettings.textColor = inputTextColor.value;
  appSettings.moduleBorderRadius = ((parseFloat(inputBorderRadius.value)||0)/16) + 'rem';
  appSettings.moduleHeaderBg = inputModuleHeaderBg.value;
  appSettings.moduleHeaderText = inputModuleHeaderText.value;
  appSettings.dangerBg = inputDangerBg.value;
  appSettings.dangerText = inputDangerText.value;

  if (moduleColorLayersContainer && moduleColorLayersContainer.children.length) {
    appSettings.moduleColorLayers = collectModuleColorLayersFromDom();
  }

  // New module border and sidebar module card settings
  appSettings.moduleBorderColor = inputModuleBorderColor.value;
  appSettings.sidebarModuleCardBg = inputSidebarModuleBg.value;
  appSettings.sidebarModuleCardText = inputSidebarModuleText.value;
  appSettings.sidebarModuleCardBorder = inputSidebarModuleBorder.value;
  if (inputShowUpdateButton) appSettings.showUpdateStatusButton = inputShowUpdateButton.checked;
  if (inputUpdateAutoPoll) appSettings.autoUpdatePolling = inputUpdateAutoPoll.checked;
  if (inputHideDowngradeButton) appSettings.hideDowngradeStatusButton = inputHideDowngradeButton.checked;
}

/** Convert rgba to hex for colour inputs */
function toColor(val, fallback) {
  if (!val) return fallback;
  if (/^#/.test(val)) return val;
  const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
  if (m) {
    const r = Number(m[1]).toString(16).padStart(2,'0');
    const g = Number(m[2]).toString(16).padStart(2,'0');
    const b = Number(m[3]).toString(16).padStart(2,'0');
    return '#' + r + g + b;
  }
  return fallback;
}

/** Apply CSS variables from appSettings */
function applySettings() {
  document.documentElement.style.setProperty('--app-bg', appSettings.appBgColor);
  document.documentElement.style.setProperty('--sidebar-bg', appSettings.sidebarBg);
  document.documentElement.style.setProperty('--sidebar-text', appSettings.sidebarText);
  document.documentElement.style.setProperty('--top-bar-bg', appSettings.topBarBg);
  document.documentElement.style.setProperty('--button-bg', appSettings.buttonBg);
  document.documentElement.style.setProperty('--button-text', appSettings.buttonText);
  document.documentElement.style.setProperty('--border-color', appSettings.borderColor);
  document.documentElement.style.setProperty('--module-bg', appSettings.moduleBgColor);
  document.documentElement.style.setProperty('--text-color', appSettings.textColor);
  document.documentElement.style.setProperty('--module-border-radius', appSettings.moduleBorderRadius);
  document.documentElement.style.setProperty('--module-header-bg', appSettings.moduleHeaderBg);
  document.documentElement.style.setProperty('--module-header-text', appSettings.moduleHeaderText);
  document.documentElement.style.setProperty('--danger-bg', appSettings.dangerBg);
  document.documentElement.style.setProperty('--danger-text', appSettings.dangerText);
  document.documentElement.style.setProperty('--tab-active-bg', appSettings.tabActiveBg);
  document.documentElement.style.setProperty('--tab-active-text', appSettings.tabActiveText);
  document.documentElement.style.setProperty('--tab-inactive-bg', appSettings.tabInactiveBg);
  document.documentElement.style.setProperty('--tab-inactive-text', appSettings.tabInactiveText);
  document.documentElement.style.setProperty('--grid-hint', appSettings.gridHint);

  // Apply module border and sidebar module card colours
  document.documentElement.style.setProperty('--module-border-color', appSettings.moduleBorderColor);
  document.documentElement.style.setProperty('--sidebar-module-card-bg', appSettings.sidebarModuleCardBg);
  document.documentElement.style.setProperty('--sidebar-module-card-text', appSettings.sidebarModuleCardText);
  document.documentElement.style.setProperty('--sidebar-module-card-border', appSettings.sidebarModuleCardBorder);

  updateGridAutoArrange();
  setUpdateStatusButton();
}

/** Save settings to storage */
async function saveAppSettings() {
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(settingsFileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(appSettings));
      await writable.close();
    } catch (e) { console.warn('Konnte Einstellungsdatei nicht speichern', e); }
  } else {
    try {
      localStorage.setItem('appSettings', JSON.stringify(appSettings));
    } catch (e) { console.warn('Konnte Einstellungen nicht im localStorage speichern', e); }
  }
}

function applyLoadedSettings(loadedSettings) {
  if (!loadedSettings || typeof loadedSettings !== 'object') return;
  const { gridFloat, autoArrangeModules, ...rest } = loadedSettings;
  appSettings = { ...appSettings, ...rest };
  appSettings.moduleColorLayers = normalizeModuleColorLayers(appSettings.moduleColorLayers);
  if (typeof autoArrangeModules === 'boolean') {
    appSettings.autoArrangeModules = autoArrangeModules;
  } else if (typeof gridFloat === 'boolean') {
    appSettings.autoArrangeModules = !gridFloat;
  }
}

/** Load settings from storage */
async function loadAppSettings() {
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(settingsFileName, { create: false });
      const file = await fileHandle.getFile();
      const text = await file.text();
      const loaded = JSON.parse(text);
      applyLoadedSettings(loaded);
    } catch (e) {}
  } else {
    try {
      const ls = localStorage.getItem('appSettings');
      if (ls) applyLoadedSettings(JSON.parse(ls));
    } catch (e) {}
  }
  applySettings();
  updateAutoPollingState();
}

/** Update card draggability */
function updateModuleDraggable() {
  listEl.querySelectorAll('.module-card[data-subdir]').forEach(card => {
    card.draggable = isSidebarOpen;
    card.style.webkitUserDrag = isSidebarOpen ? 'element' : 'none';
    card.style.cursor = isSidebarOpen ? 'grab' : 'default';
  });
}
function updateGridDraggable() {
  tabs.forEach(tab => {
    if (tab.grid) {
      // grid-wide static mode reflects sidebar state
      tab.grid.setStatic(!isSidebarOpen);
      tab.grid.engine.nodes.forEach(node => {
        tab.grid.movable(node.el, isSidebarOpen);
        tab.grid.resizable(node.el, isSidebarOpen);
        const dragHandle = node.el.querySelector('.drag-handle');
        if (dragHandle) dragHandle.style.cursor = isSidebarOpen ? 'move' : 'default';
        const delBtn = node.el.querySelector('.remove');
        if (delBtn) delBtn.style.display = isSidebarOpen ? '' : 'none';
        const resizeHandles = node.el.querySelectorAll('.ui-resizable-handle');
        resizeHandles.forEach(handle => {
          handle.style.display = isSidebarOpen ? '' : 'none';
          if (!isSidebarOpen) handle.style.cursor = 'default';
        });
      });
    }
  });
}

function updateGridAutoArrange() {
  const autoArrange = !!appSettings.autoArrangeModules;
  const shouldFloat = !autoArrange;
  tabs.forEach(tab => {
    const grid = tab.grid;
    if (!grid) return;
    if (typeof grid.float === 'function') {
      grid.float(shouldFloat);
    } else if (typeof grid.setFloat === 'function') {
      grid.setFloat(shouldFloat);
    } else {
      grid.opts = grid.opts || {};
      grid.opts.float = shouldFloat;
      if (grid.engine && Object.prototype.hasOwnProperty.call(grid.engine, 'float')) {
        grid.engine.float = shouldFloat;
      }
    }
  });
}

/** Load modules via FS API */
async function loadModulesFromRoot(rootHandle) {
  try {
    modulesDirHandle = await rootHandle.getDirectoryHandle('modules', { create: false });
  } catch {
    liveModuleTemplates = [];
    renderSidebar([]);
    alert('Kein "modules" Unterordner im gewählten Root gefunden.');
    return;
  }
  const { tree, modules } = await buildTreeFromHandle(modulesDirHandle);
  liveModuleTemplates = modules;
  renderSidebar(tree);

  // Apply a fade-in animation to grids container when modules load
  if (gridsContainer) {
    gridsContainer.classList.add('fade-in');
    setTimeout(() => gridsContainer.classList.remove('fade-in'), 600);
  }
}

/** Fallback load modules via file list */
async function loadModulesFromFileList(files, rootName) {
  const { tree, modules } = await buildTreeFromFileList(files, rootName);
  liveModuleTemplates = modules;
  renderSidebar(tree);

  // Apply fade-in to grids container when modules load via fallback
  if (gridsContainer) {
    gridsContainer.classList.add('fade-in');
    setTimeout(() => gridsContainer.classList.remove('fade-in'), 600);
  }
}

function filterSidebarTree(tree, filter) {
  if (!Array.isArray(tree)) return [];
  if (!filter) return tree;
  return tree
    .map(node => filterSidebarNode(node, filter))
    .filter(Boolean);
}

function filterSidebarNode(node, filter) {
  if (!node) return null;
  if (!filter) return node;
  if (node.type === 'folder') {
    const filteredChildren = (node.children || [])
      .map(child => filterSidebarNode(child, filter))
      .filter(Boolean);
    if (!filteredChildren.length) return null;
    return { ...node, children: filteredChildren };
  }
  const name = String(node.template?.name || node.subdir || '').toLowerCase();
  return name.includes(filter) ? node : null;
}

/** Render sidebar module cards */
function renderSidebar(tree) {
  if (Array.isArray(tree)) {
    sidebarTreeData = tree;
  } else if (!Array.isArray(sidebarTreeData)) {
    sidebarTreeData = [];
  }
  const sourceTree = Array.isArray(sidebarTreeData) ? sidebarTreeData : [];
  const filter = (sidebarSearchTerm || '').trim().toLowerCase();
  const displayTree = filterSidebarTree(sourceTree, filter);
  listEl.innerHTML = '';
  if (!displayTree.length) {
    listEl.innerHTML = `<div class="text-gray-400">${filter ? 'Keine passenden Module.' : 'Keine Module gefunden.'}</div>`;
    return;
  }
  displayTree.forEach(node => renderSidebarNode(node, listEl));
  updateModuleDraggable();
}

function renderSidebarNode(node, container) {
  if (node.type === 'folder') {
    const header = document.createElement('div');
    header.className = 'module-card rounded p-3 cursor-pointer shadow transition flex items-center';
    const nameSpan = document.createElement('span');
    nameSpan.className = 'font-semibold flex-1';
    nameSpan.textContent = node.name;
    const arrow = document.createElement('span');
    arrow.textContent = '▼';
    header.appendChild(nameSpan);
    header.appendChild(arrow);
    container.appendChild(header);
    const childrenContainer = document.createElement('div');
    childrenContainer.className = 'pl-4 flex flex-col gap-2 mt-2';
    childrenContainer.style.display = 'none';
    container.appendChild(childrenContainer);
    node.children.forEach(child => renderSidebarNode(child, childrenContainer));
    header.addEventListener('click', () => {
      const open = childrenContainer.style.display !== 'none';
      childrenContainer.style.display = open ? 'none' : '';
      arrow.textContent = open ? '▼' : '▲';
    });
  } else {
    const { template, subdir, attachments } = node;
    const card = document.createElement('div');
    card.className = 'module-card rounded p-3 cursor-grab shadow transition flex flex-col';
    card.dataset.subdir = subdir;
    const header = document.createElement('div');
    header.className = 'flex items-center gap-2';
    if (template.icon) {
      const iconSpan = document.createElement('span');
      iconSpan.className = 'text-xl';
      iconSpan.textContent = template.icon;
      header.appendChild(iconSpan);
    }
    const nameSpan = document.createElement('span');
    nameSpan.className = 'font-semibold flex-1';
    nameSpan.textContent = template.name || subdir;
    header.appendChild(nameSpan);
    card.appendChild(header);
    if (attachments?.length) {
      const att = document.createElement('div');
      att.className = 'sidebar-module-attachment mt-1';
      att.textContent = '📎 ' + attachments.join(', ');
      card.appendChild(att);
    }
    card.draggable = isSidebarOpen;
    card.addEventListener('dragstart', e => {
      if (!isSidebarOpen) {
        e.preventDefault(); return;
      }
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', subdir);
      e.dataTransfer.setData('application/x-module-subdir', subdir);
      card.classList.add('dragging');
    });
    card.addEventListener('dragend', () => card.classList.remove('dragging'));
    container.appendChild(card);
  }
}

async function buildTreeFromHandle(dirHandle, basePath = '') {
  const modules = [];
  async function scan(handle, relPath) {
    let moduleJson = null;
    const attachments = [];
    let hasJson = false, hasJs = false;
    const children = [];
    for await (const entry of handle.values()) {
      if (entry.kind === 'file') {
        if (entry.name.endsWith('.json')) {
          hasJson = true;
          const f = await entry.getFile();
          try { moduleJson = JSON.parse(await f.text()); } catch {}
        } else {
          if (entry.name.endsWith('.js')) hasJs = true;
          attachments.push(entry.name);
        }
      } else if (entry.kind === 'directory') {
        const child = await scan(entry, relPath ? `${relPath}/${entry.name}` : entry.name);
        if (child) children.push(child);
      }
    }
    if (hasJson && hasJs && moduleJson) {
      const node = { type: 'module', template: moduleJson, subdir: relPath, attachments, dirHandle: handle };
      modules.push(node);
      return node;
    }
    return { type: 'folder', name: handle.name, children };
  }
  const root = await scan(dirHandle, basePath);
  return { tree: root.children || [], modules };
}

async function buildTreeFromFileList(files, rootName) {
  const root = { name: 'modules', files: [], children: {} };
  for (const f of files) {
    const rel = f.webkitRelativePath.split('/');
    if (rel.length < 3) continue;
    if (rel[0] !== rootName || rel[1] !== 'modules') continue;
    insert(root, rel.slice(2), f);
  }
  const modules = [];
  async function finalize(node, relPath) {
    const hasJson = node.files.some(f => f.name.endsWith('.json'));
    const hasJs = node.files.some(f => f.name.endsWith('.js'));
    let moduleJson = null;
    const attachments = [];
    if (hasJson && hasJs) {
      for (const f of node.files) {
        if (f.name.endsWith('.json')) { try { moduleJson = JSON.parse(await f.text()); } catch {} }
        else attachments.push(f.name);
      }
      const subdir = relPath;
      const modNode = { type: 'module', template: moduleJson, subdir, attachments, fileList: node.files };
      modules.push(modNode);
      return modNode;
    }
    const children = [];
    for (const [name, child] of Object.entries(node.children)) {
      const childNode = await finalize(child, relPath ? `${relPath}/${name}` : name);
      if (childNode) children.push(childNode);
    }
    return { type: 'folder', name: node.name, children };
  }
  function insert(node, parts, file) {
    if (parts.length === 1) {
      node.files.push(file);
    } else {
      const [folder, ...rest] = parts;
      if (!node.children[folder]) node.children[folder] = { name: folder, files: [], children: {} };
      insert(node.children[folder], rest, file);
    }
  }
  const tree = await finalize(root, '');
  return { tree: tree.children || [], modules };
}

/** Reset and recreate tabs using saved layout */
async function loadAndInitTabs() {
  const savedActive = loadActiveTabIndex();
  resetTabs();
  let saved = await loadLayout();
  let migrated = false;

  if (saved && saved.length) {
    for (const tabData of saved) {
      if (!Array.isArray(tabData.modules)) continue;
      for (const mod of tabData.modules) {
        const name = mod.subdir || mod.name;
        const exists = name && liveModuleTemplates.find(t => t.subdir === name);
        if (!exists && name) {
          const base = name.split('/').pop();
          const found = liveModuleTemplates.find(t => t.subdir.split('/').pop() === base);
          if (found) {
            mod.subdir = found.subdir;
            delete mod.name;
            migrated = true;
          }
        }
      }
    }
  }

  // Seed used IDs and counter from saved layout
  usedInstanceIds = new Set();
  nextModuleInstanceId = 1;
  if (saved && saved.length) {
    for (const t of saved) {
      for (const m of (t.modules || [])) {
        if (m.id) {
          usedInstanceIds.add(m.id);
          const num = /^mod-(\d+)$/.exec(m.id)?.[1];
          if (num) nextModuleInstanceId = Math.max(nextModuleInstanceId, Number(num) + 1);
        }
      }
    }
  }

  if (saved && saved.length) {
    for (const tabData of saved) createTab(tabData.name, tabData.modules);
  } else {
    createTab('Standard');
  }
  if (tabs.length) {
    const initialIndex = (typeof savedActive === 'number' && savedActive >= 0 && savedActive < tabs.length)
      ? savedActive
      : 0;
    activateTab(initialIndex);
  }

  if (migrated) saveLayout();

  // ensure initial state reflects current sidebar state
  updateModuleDraggable();
  updateGridDraggable();
  updateGridAutoArrange();
}

/** Create a tab and grid */
function createTab(name, layoutModules = []) {
  const tabIndex = tabs.length;
  const tab = { name: name || ('Tab ' + (tabIndex + 1)), modules: [], grid: null, el: null, readyPromise: null };
  let resolveReady;
  tab.readyPromise = new Promise(resolve => {
    resolveReady = resolve;
  });
  const gridEl = document.createElement('div');
  gridEl.className = 'grid-stack p-4';
  gridEl.style.minHeight = 'calc(100vh - 40px)';
  gridEl.dataset.tabIndex = tabIndex;
  gridsContainer.appendChild(gridEl);

  const gridInstance = GridStack.init({ cellHeight: 30, margin: 5, handle: '.grid-stack-item-content', column: 12, float: !appSettings.autoArrangeModules, minRow: 8 }, gridEl);

  // Reflect current sidebar state immediately (no drag/resize when closed)
  gridInstance.setStatic(!isSidebarOpen);

  tab.grid = gridInstance;
  tab.el = gridEl;
  tabs.push(tab);
  gridInstance.on('change', () => {
    if (isLayoutRecordingSuppressed()) {
      updateModulesPositions(tab, { skipUndo: true, skipSave: true });
    } else {
      updateModulesPositions(tab);
    }
  });

  gridEl.addEventListener('dragover', e => {
    if (!isSidebarOpen) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
    gridEl.classList.add('grid-drop-hint');
  });
  gridEl.addEventListener('dragleave', () => gridEl.classList.remove('grid-drop-hint'));
  gridEl.addEventListener('drop', async e => {
    if (!isSidebarOpen) return;
    e.preventDefault();
    gridEl.classList.remove('grid-drop-hint');
    let subdir = e.dataTransfer.getData('application/x-module-subdir');
    if (!subdir) subdir = e.dataTransfer.getData('text/plain');
    if (!subdir) return;
    const modObj = liveModuleTemplates.find(m => m.subdir === subdir);
    if (!modObj) return;
    const rect = gridEl.getBoundingClientRect();
    const cell = gridInstance.getCellFromPixel({ left: e.clientX - rect.left, top: e.clientY - rect.top });
    const tmpl = modObj.template;
    const w = parseInt(tmpl.w) || 6;
    const h = parseInt(tmpl.h) || 3;
    const pos = { x: cell.x, y: cell.y, w, h };
    // Generate unique instance id for this drop
    const instanceId = generateInstanceId();
    if (tmpl.script) {
      const jsFileName = findScriptFileName(tmpl, modObj);
      if (!jsFileName) { alert('Kein Modul-JS gefunden für: ' + (tmpl.name || modObj.subdir)); return; }
      await loadAndRunModuleScript(jsFileName, tmpl, modObj, pos, gridInstance, tab, instanceId);
    } else if (tmpl.fields) {
      createUniversalModule(tmpl, pos, modObj, gridInstance, tab, instanceId);
    } else {
      createSimpleModule(tmpl.name || modObj.subdir, pos, gridInstance, tab, modObj.subdir, instanceId);
    }
  });

  if (layoutModules && layoutModules.length) {
    beginSuppressLayoutRecording();
    setTimeout(async () => {
      try {
        for (const m of layoutModules) {
          const modObj = liveModuleTemplates.find(t => t.subdir === m.subdir);
          const pos = { x: m.x || 0, y: m.y || 0, w: m.w || 6, h: m.h || 3 };
          // Use stored id if available; otherwise generate a new one
          const instanceId = m.id || generateInstanceId();
          if (modObj && modObj.template) {
            const tmpl = modObj.template;
            let handled = false;
            if (tmpl.script) {
              const jsFileName = findScriptFileName(tmpl, modObj);
              if (jsFileName) {
                await loadAndRunModuleScript(jsFileName, tmpl, modObj, pos, gridInstance, tab, instanceId, { skipUndo: true, skipSave: true });
                handled = true;
              }
            }
            if (!handled && tmpl.fields) {
              createUniversalModule(tmpl, pos, modObj, gridInstance, tab, instanceId, { skipUndo: true, skipSave: true });
              handled = true;
            }
            if (!handled) {
              createSimpleModule(tmpl.name || modObj.subdir, pos, gridInstance, tab, modObj.subdir, instanceId, { skipUndo: true, skipSave: true });
            }
          } else {
            createSimpleModule(m.subdir, pos, gridInstance, tab, m.subdir, instanceId, { skipUndo: true, skipSave: true });
          }
        }
      } finally {
        endSuppressLayoutRecording();
        if (typeof resolveReady === 'function') resolveReady();
      }
    }, 50);
  } else if (typeof resolveReady === 'function') {
    resolveReady();
  }
  return tab;
}

/** Render tabs */
function renderTabs() {
  if (tabsSortable) {
    tabsSortable.destroy();
    tabsSortable = null;
  }
  tabsContainer.innerHTML = '';
  tabs.forEach((tab, idx) => {
    const item = document.createElement('div');
    item.className = 'tab-item flex items-center gap-1 px-3 py-1 rounded cursor-pointer';
    if (idx === activeTabIndex) item.classList.add('tab-active'); else item.classList.add('tab-inactive','hover:opacity-90');
    item.dataset.tabIndex = idx;
    const label = document.createElement('span');
    label.className = 'truncate max-w-xs';
    label.textContent = tab.name;
    item.appendChild(label);
    item.addEventListener('click', () => activateTab(idx));
    item.addEventListener('contextmenu', e => openTabContextMenu(e, idx));
    tabsContainer.appendChild(item);
  });
  tabsSortable = Sortable.create(tabsContainer, {
    animation: 150,
    ghostClass: 'opacity-50',
    onStart: closeTabContextMenu,
    onEnd: handleTabReorder
  });
}

/** Handle tab drag-and-drop reorder */
function handleTabReorder(evt) {
  if (!evt || evt.oldIndex === undefined || evt.newIndex === undefined) return;
  const oldIndex = evt.oldIndex;
  const newIndex = evt.newIndex;
  if (oldIndex === newIndex) {
    activateTab(activeTabIndex);
    return;
  }
  const [movedTab] = tabs.splice(oldIndex, 1);
  tabs.splice(newIndex, 0, movedTab);

  if (activeTabIndex === oldIndex) {
    activeTabIndex = newIndex;
  } else if (oldIndex < activeTabIndex && activeTabIndex <= newIndex) {
    activeTabIndex -= 1;
  } else if (newIndex <= activeTabIndex && activeTabIndex < oldIndex) {
    activeTabIndex += 1;
  }

  updateGridsDomOrder();
  activateTab(activeTabIndex);
  saveLayout();
}

/** Sync grid DOM order with tab array order */
function updateGridsDomOrder() {
  tabs.forEach((tab, idx) => {
    if (tab.el && tab.el.parentNode === gridsContainer) {
      tab.el.dataset.tabIndex = idx;
      gridsContainer.appendChild(tab.el);
    }
  });
}

/** Activate a tab */
function activateTab(idx, options = {}) {
  if (idx < 0 || idx >= tabs.length) return;
  tabs.forEach((tab, i) => { if (tab.el) tab.el.style.display = (i === idx ? '' : 'none'); });
  activeTabIndex = idx;
  renderTabs();
  if (!options.skipSave) saveActiveTabIndex();
}

/** Delete tab */
function deleteTab(idx) {
  if (tabs.length <= 1) { alert('Mindestens ein Tab muss bestehen.'); return; }
  const removed = tabs.splice(idx,1)[0];
  if (removed && removed.el && removed.el.parentNode) removed.el.parentNode.removeChild(removed.el);
  if (activeTabIndex >= idx) activeTabIndex = Math.max(0, activeTabIndex - 1);
  renderTabs();
  activateTab(activeTabIndex);
  saveLayout();
}

/** Rename tab */
function renameTab(idx) {
  const newName = prompt('Neuer Name für den Tab:', tabs[idx].name);
  if (newName) {
    tabs[idx].name = newName;
    renderTabs();
    saveLayout();
  }
}

/** Open context menu for a tab */
function openTabContextMenu(e, idx) {
  e.preventDefault();
  closeTabContextMenu();
  const menu = document.createElement('div');
  menu.className = 'tab-context-menu absolute bg-white border rounded shadow z-50 text-sm';
  menu.style.left = e.pageX + 'px';
  menu.style.top = e.pageY + 'px';

  const renameItem = document.createElement('div');
  renameItem.className = 'px-3 py-1 hover:bg-gray-100 cursor-pointer';
  renameItem.textContent = 'Namen bearbeiten';
  renameItem.addEventListener('click', () => {
    closeTabContextMenu();
    renameTab(idx);
  });
  menu.appendChild(renameItem);

  const deleteItem = document.createElement('div');
  deleteItem.className = 'px-3 py-1 hover:bg-gray-100 cursor-pointer';
  deleteItem.textContent = 'Tab löschen';
  deleteItem.addEventListener('click', () => {
    closeTabContextMenu();
    if (!confirm('Tab wirklich löschen?')) return;
    deleteTab(idx);
  });
  menu.appendChild(deleteItem);

  document.body.appendChild(menu);
  tabContextMenu = menu;
}

function closeTabContextMenu() {
  if (tabContextMenu) {
    tabContextMenu.remove();
    tabContextMenu = null;
  }
}

document.addEventListener('click', () => closeTabContextMenu());

/** Remove all tabs */
function resetTabs() {
  tabs.forEach(tab => { if (tab.el && tab.el.parentNode) tab.el.parentNode.removeChild(tab.el); });
  tabs = [];
  tabsContainer.innerHTML = '';
  activeTabIndex = 0;
  clearActiveTabIndex();
}

/** Update module positions after drag/resizing */
function updateModulesPositions(tabOrIndex, options = {}) {
  const tab = typeof tabOrIndex === 'number' ? tabs[tabOrIndex] : tabOrIndex;
  if (!tab || !tab.grid) return;
  const { skipUndo = false, skipSave = false } = options;

  const nodes = tab.grid.engine.nodes || [];
  const newModules = nodes.map(node => {
    const subdir = node.el.dataset.subdir;
    const type = node.el.dataset.modType;
    let instanceId = node.el.dataset.instanceId;
    if (!instanceId) {
      instanceId = generateInstanceId();
      node.el.dataset.instanceId = instanceId;
    } else {
      usedInstanceIds.add(instanceId);
    }
    return { id: instanceId, subdir, type, x: node.x, y: node.y, w: node.w, h: node.h };
  });

  const prevModulesJson = JSON.stringify(tab.modules || []);
  const newModulesJson = JSON.stringify(newModules);
  const changed = prevModulesJson !== newModulesJson;

  let previousSnapshot = null;
  if (changed && !skipUndo && !isLayoutRecordingSuppressed()) {
    previousSnapshot = captureLayoutSnapshot();
  }

  tab.modules = newModules;

  if (changed && !skipUndo && !isLayoutRecordingSuppressed()) {
    pushUndoState(previousSnapshot);
  }

  if (changed && !skipSave) {
    saveLayout();
  } else if (!skipSave && saveIndicatorPending === 0) {
    setSaveIndicator('saved');
  }

  updateUndoRedoButtons();
}

function setSaveIndicator(state) {
  if (!saveIndicator) return;
  saveIndicator.classList.remove('bg-green-500','bg-yellow-400','bg-red-500');
  let title = '';
  if (state === 'pending') {
    saveIndicator.classList.add('bg-yellow-400');
    title = 'Speichern läuft…';
  } else if (state === 'error') {
    saveIndicator.classList.add('bg-red-500');
    title = 'Speichern fehlgeschlagen';
  } else {
    saveIndicator.classList.add('bg-green-500');
    title = 'Gespeichert';
  }
  saveIndicator.title = title;
}

/** Save layout */
async function saveLayout() {
  saveIndicatorPending++;
  setSaveIndicator('pending');
  const layoutData = { tabs: tabs.map(({name, modules}) => ({ name, modules })) };
  let success = true;
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(layoutFileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(layoutData));
      await writable.close();
    } catch (e) {
      success = false;
      setSaveIndicator('error');
      console.warn('Konnte Layout-Datei nicht speichern', e);
    }
  } else {
    try {
      localStorage.setItem('modulesLayout', JSON.stringify(layoutData));
    } catch (e) {
      success = false;
      setSaveIndicator('error');
      console.warn('Konnte Layout nicht im localStorage speichern', e);
    }
  }
  saveIndicatorPending = Math.max(0, saveIndicatorPending - 1);
  if (success && saveIndicatorPending === 0) {
    setSaveIndicator('saved');
  }
}

/** Load layout */
async function loadLayout() {
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(layoutFileName, { create: false });
      const file = await fileHandle.getFile();
      const text = await file.text();
      const obj = JSON.parse(text);
      if (obj && Array.isArray(obj.tabs)) return obj.tabs;
    } catch (e) {}
  }
  try {
    const ls = localStorage.getItem('modulesLayout');
    if (ls) {
      const obj = JSON.parse(ls);
      if (obj && Array.isArray(obj.tabs)) return obj.tabs;
    }
  } catch (e) {}
  return null;
}

function saveActiveTabIndex() {
  try {
    localStorage.setItem(ACTIVE_TAB_STORAGE_KEY, String(activeTabIndex));
  } catch (e) {}
}

function loadActiveTabIndex() {
  try {
    const stored = localStorage.getItem(ACTIVE_TAB_STORAGE_KEY);
    if (stored === null) return null;
    const parsed = Number.parseInt(stored, 10);
    return Number.isNaN(parsed) ? null : parsed;
  } catch (e) {
    return null;
  }
}

function clearActiveTabIndex() {
  try { localStorage.removeItem(ACTIVE_TAB_STORAGE_KEY); } catch (e) {}
}

/** Determine script filename from module JSON */
function findScriptFileName(moduleJson, modObj) {
  const base = String(moduleJson.script).replace(/^render/, '');
  const candidates = (modObj.attachments || []).filter(n => n.endsWith('.js'));
  let jsFileName = candidates.find(n => n.replace(/\.js$/, '') === base);
  if (!jsFileName) jsFileName = candidates[0];
  return jsFileName;
}

/** Load and run script module */
async function loadAndRunModuleScript(jsFileName, moduleJson, modObj, gridPos, gridInstance, tabRef, instanceIdArg, options = {}) {
  let jsText = '';
  if (modObj.dirHandle) {
    const jsHandle = await modObj.dirHandle.getFileHandle(jsFileName);
    jsText = await (await jsHandle.getFile()).text();
  } else if (modObj.fileList) {
    const f = modObj.fileList.find(f => f.name === jsFileName);
    if (!f) { alert('JS-Datei nicht gefunden (Fallback).'); return; }
    jsText = await f.text();
  } else {
    alert('Keine Quelle für JS-Datei gefunden.');
    return;
  }
  try { eval(jsText); } catch (e) { console.error(e); alert('Fehler im Modul-JS.'); return; }
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  el.innerHTML = `<div class="grid-stack-item-content relative">
  <button class="remove gs-remove px-2 py-1 text-xs rounded">🗑</button>
  <div class="content"></div>
  </div>`;
  el.dataset.subdir = modObj.subdir;
  el.dataset.modType = 'script';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  const pos = gridPos || { x:0, y:0, w: moduleJson.w || 6, h: moduleJson.h || 3 };
  const widgetOptions = {
    ...pos,
    minW: moduleJson.minW || 1,
    minH: moduleJson.minH || 1
  };
  if (Number.isFinite(moduleJson.maxW)) widgetOptions.maxW = moduleJson.maxW;
  if (Number.isFinite(moduleJson.maxH)) widgetOptions.maxH = moduleJson.maxH;
  gridInstance.addWidget(el, widgetOptions);
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabRef);
    updateGridDraggable();
  };
  if (typeof window[moduleJson.script] === 'function') {
    window[moduleJson.script](el.querySelector('.content'), { moduleJson, attachments: modObj.attachments || [], subdir: modObj.subdir });
  } else {
    alert('Exportierte Funktion nicht gefunden: ' + moduleJson.script);
  }
  // Apply fade-in animation to new module content
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabRef, options);
  updateGridDraggable();
}

/** Create universal (fields) module */
function createUniversalModule(mod, pos, modObj, gridInstance, tabRef, instanceIdArg, options = {}) {
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  const defaultW = parseInt(mod.w) || 6;
  const defaultH = parseInt(mod.h) || 3;
  const finalPos = { ...pos };
  if (!pos || typeof pos.w === 'undefined') finalPos.w = defaultW;
  if (!pos || typeof pos.h === 'undefined') finalPos.h = defaultH;
  const bg = mod.color || appSettings.moduleBgColor;
  let html = `<div class="grid-stack-item-content" style="background:${bg}">`;
  html += `<div class="drag-handle"><span class="font-semibold">${mod.name || modObj.subdir}</span><button class="remove px-2 py-1 text-xs rounded">🗑</button></div>`;
  html += `<form class="unimod-form grid grid-cols-2 gap-3">`;
  (mod.fields || []).forEach(field => {
    const colSpan = field.width === 2 ? 'col-span-2' : 'col-span-1';
    html += `<label class="${colSpan} text-sm flex flex-col gap-1"><span class="font-medium">${field.label || field.key}</span>`;
    if (field.type === 'textarea') {
      html += `<textarea name="${field.key}" class="w-full text-black p-1 rounded"></textarea>`;
    } else if (field.type === 'select') {
      html += `<select name="${field.key}" class="w-full text-black p-1 rounded">` + (field.options || []).map(o => `<option>${o}</option>`).join('') + `</select>`;
    } else {
      html += `<input type="${field.type || 'text'}" name="${field.key}" class="w-full text-black p-1 rounded" />`;
    }
    html += `</label>`;
  });
  html += `</form>`;
  if (mod.actions?.length) {
    html += `<div class="mt-2 flex flex-wrap gap-2">` + mod.actions.map((a,i) => `<button type="button" class="action-btn bg-indigo-500 hover:bg-indigo-600 text-white px-3 py-1 rounded text-sm" data-i="${i}">${a.label}</button>`).join('') + `</div>`;
  }
  html += `</div>`;
  el.innerHTML = html;
  el.dataset.subdir = modObj.subdir;
  el.dataset.modType = 'fields';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  const widgetOptions = {
    ...(finalPos || { x:0,y:0,w:defaultW,h:defaultH }),
    minW: mod.minW || 1,
    minH: mod.minH || 1,
    maxW: mod.maxW || finalPos.w,
    maxH: mod.maxH || finalPos.h
  };
  gridInstance.addWidget(el, widgetOptions);
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabRef);
    updateGridDraggable();
  };
  if (mod.actions?.length) {
    el.querySelectorAll('.action-btn').forEach(btn => {
      btn.onclick = () => {
        const i = Number(btn.dataset.i);
        const script = mod.actions[i].script;
        if (!script) return;
        runInlineScript(script, el.querySelector('form'), { modulename: mod.name || modObj.subdir });
      };
    });
  }
  // Apply fade-in animation to new universal module
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabRef, options);
  updateGridDraggable();
}

/** Run script for universal module */
function runInlineScript(script, formEl, context) {
  const fields = {};
  Array.from(formEl.elements).forEach(el => { if (el.name) fields[el.name] = el; });
  const helpers = {
    exportAsCSV: fields => {
      const row = Object.values(fields).map(f => (f && f.value || '')).join(';');
      const blob = new Blob([row], { type:'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (context.modulename || 'modul') + '.csv';
      a.click();
    }
  };
  const fn = new Function('fields','context',...Object.keys(helpers), script);
  try { fn(fields, context, ...Object.values(helpers)); } catch (e) { console.error(e); alert('Script-Fehler.'); }
}

/** Create simple module */
function createSimpleModule(title, pos, gridInstance, tabRef, subdir, instanceIdArg, options = {}) {
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  const w = (pos && pos.w) || 4;
  const h = (pos && pos.h) || 2;
  el.innerHTML = `<div class="grid-stack-item-content relative">
  <button class="remove gs-remove px-2 py-1 text-xs rounded">🗑</button>
  <div class="text-sm opacity-80">Kein Script/Fields definiert.</div>
  </div>`;
  el.dataset.subdir = subdir || title;
  el.dataset.modType = 'simple';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  gridInstance.addWidget(el, pos || { x:0, y:0, w, h });
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabRef);
    updateGridDraggable();
  };
  // Apply fade-in animation to new simple module
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabRef, options);
  updateGridDraggable();
}
  </script>
</body>
</html>
