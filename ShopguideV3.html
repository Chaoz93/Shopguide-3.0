<!-- Version: 1.2 -->
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Shopguide V3</title>
  <meta id="viewport-meta" name="viewport" content="initial-scale=1.0" />
  <script>
    (function(meta){ if(!meta) return; var parts=['de','vice-width']; meta.setAttribute('content','width='+parts.join('')+', initial-scale=1.0'); })(document.getElementById('viewport-meta'));
  </script>
  <!-- Tailwind for easy styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- GridStack styles and scripts -->
  <link href="https://cdn.jsdelivr.net/npm/gridstack@9.2.2/dist/gridstack.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/gridstack@9.2.2/dist/gridstack-all.js"></script>
  <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
  <script src="https://code.jquery.com/ui/1.14.1/jquery-ui.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>

  <link rel="stylesheet" href="https://code.jquery.com/ui/1.14.1/themes/base/jquery-ui.css">
  <style>
    :root {
      /* General colours */
      --app-bg: #f3f4f6;
      --sidebar-bg: #f3f4f6;
      --sidebar-text: #1f2937;
      --top-bar-bg: #ffffff;
      --button-bg: #2563eb;
      --button-text: #ffffff;
      --border-color: #e5e7eb;
      /* Module colours */
      --module-bg: #005983;
      --text-color: #ffffff;
      --module-border-radius: 1.25rem;
      --module-header-bg: rgba(255,255,255,0.08);
      --module-header-text: #ffffff;
      /* Module border */
      --module-border-color: #e5e7eb;
      --danger-bg: #ef4444;
      --danger-text: #ffffff;
      /* Tabs colours */
      --tab-active-bg: #2563eb;
      --tab-active-text: #ffffff;
      --tab-inactive-bg: #e5e7eb;
      --tab-inactive-text: #1f2937;
      /* Grid hint */
      --grid-hint: #60a5fa;

      /* Sidebar module card colours */
      --sidebar-module-card-bg: #ffffff;
      --sidebar-module-card-text: #1f2937;
      --sidebar-module-card-border: #e5e7eb;

      /* Attachment text colour for module cards */
      --sidebar-module-card-attachment-color: #6B7280;

      /* Body text colour (used for general text; separate from sidebar text) */
      --body-text: #1f2937;
    }

    html, body { height: 100%; }
    body { margin: 0; background: var(--app-bg); color: var(--body-text); }
    /* module contents */
    .grid-stack-item-content {
      background: var(--module-bg);
      border-radius: var(--module-border-radius);
      color: var(--text-color);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      min-height: 10px;
      /* apply border using module border colour */
      border: 1px solid var(--module-border-color);
    }
    .drag-handle {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:.5rem;
      cursor: move;
      background: var(--module-header-bg);
      color: var(--module-header-text);
      border-radius: calc(var(--module-border-radius) - 0.25rem);
      padding: .25rem .5rem;
    }
    .module-card.dragging { opacity: 0.5; }
    .grid-drop-hint { outline: 2px dashed var(--grid-hint); outline-offset: -6px; }
    .module-card {
      -webkit-user-drag: element;
      user-select: none;
      /* use CSS variables for sidebar module appearance */
      background-color: var(--sidebar-module-card-bg);
      color: var(--sidebar-module-card-text);
      border: 1px solid var(--sidebar-module-card-border);
    }
    /* Sidebar collapsed state */
    #sidebar.collapsed { width: 2.5rem !important; min-width: 2.5rem !important; padding-left: 0; padding-right: 0; }
    #sidebar.collapsed .list-content { display: none; }
    #sidebar.collapsed .collapse-icon { transform: rotate(180deg); }
    #sidebar.collapsed .module-card { pointer-events: none; }
    #sidebar.collapsed #module-list { pointer-events: none; }
    /* Topbar, sidebar and buttons use variables */
    #top-bar { background-color: var(--top-bar-bg) !important; border-bottom: 1px solid var(--border-color) !important; }
    #sidebar { background-color: var(--sidebar-bg) !important; border-right: 1px solid var(--border-color) !important; color: var(--sidebar-text); overflow-y: auto; }
    #select-root { background-color: var(--button-bg) !important; color: var(--button-text) !important; }
    button.remove { background-color: var(--danger-bg) !important; color: var(--danger-text) !important; }
    /* Tabs */
    .tab-item { user-select: none; }
    .tab-active { background: var(--tab-active-bg); color: var(--tab-active-text); }
    .tab-inactive { background: var(--tab-inactive-bg); color: var(--tab-inactive-text); }
    /* Settings Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 50;
    }
    .modal {
      background: white;
      border-radius: 0.75rem;
      padding: 1rem;
      width: 95%;
      max-width: 860px;
      max-height: 90vh;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;

      /* Ensure modal text colour does not inherit sidebar text colour */
      color: var(--body-text);
    }
    .settings-content {
      overflow-y: auto;
      flex: 1;
    }
    .updates-table-container {
      max-height: 50vh;
      overflow-y: auto;
    }
    .update-settings-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem 0.75rem;
    }
    .update-settings-row .update-folder-info {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
    }
    .update-toggle {
      position: relative;
      display: inline-flex;
      align-items: center;
      cursor: pointer;
    }
    .update-toggle input {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      white-space: nowrap;
      border: 0;
    }
    .update-toggle-track {
      width: 2.75rem;
      height: 1.5rem;
      background-color: #d1d5db;
      border-radius: 9999px;
      transition: background-color 0.2s ease;
    }
    .update-toggle-thumb {
      position: absolute;
      left: 0.25rem;
      top: 0.25rem;
      width: 1rem;
      height: 1rem;
      border-radius: 9999px;
      background-color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      transition: transform 0.2s ease;
    }
    .update-toggle input:checked + .update-toggle-track {
      background-color: #2563eb;
    }
    .update-toggle input:checked + .update-toggle-track + .update-toggle-thumb {
      transform: translateX(1.25rem);
    }
    .version-overview-grid {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 5rem 5rem;
      column-gap: 1.5rem;
      row-gap: 0.5rem;
      align-items: center;
    }
    .version-overview-header {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
    }
    .version-overview-name {
      font-weight: 500;
      color: #374151;
    }
    .version-overview-value {
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: #4b5563;
    }
    .version-overview-empty {
      grid-column: 1 / -1;
      color: #6b7280;
      font-style: italic;
    }
    .settings-nav button {
      border-radius: .5rem;
      padding: .5rem .75rem;
    }
    .settings-nav button.active { background: #e5e7eb; }
    .settings-section { display: none; }
    .settings-section.active { display: block; }
    .field-grid {
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: .75rem;
    }
    @media (max-width: 640px){ .field-grid { grid-template-columns: 1fr; } }
    .form-field label { font-size:.875rem; font-weight:600; }

    /* Simple fade-in animation for startup and loading */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .fade-in {
      animation: fadeIn 0.5s ease-out;
    }

    /* Attachment text style in sidebar module cards */
    #module-list .sidebar-module-attachment {
      color: var(--sidebar-module-card-attachment-color);
      font-size: 0.75rem;
    }

    /* Ensure module names in the sidebar wrap rather than truncate */
    #module-list .module-card .font-semibold {
      word-break: break-word;
      white-space: normal;
    }
    .gs-remove {
      position: absolute;
      top: .35rem;
      right: .35rem;
    }

    .changelog-overlay {
      position: fixed;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      background: rgba(0,0,0,0.45);
      z-index: 60;
    }

    .changelog-overlay.open {
      display: flex;
    }

    .changelog-modal {
      position: relative;
      width: min(720px, 100%);
      max-height: 85vh;
      background: #ffffff;
      color: var(--body-text);
      border-radius: 0.75rem;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .changelog-header {
      padding: 1rem 1.25rem 0.75rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .changelog-title {
      font-size: 1.15rem;
      font-weight: 600;
    }

    .changelog-subtitle {
      font-size: 0.85rem;
      color: #6b7280;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .changelog-body {
      padding: 1rem 1.25rem;
      overflow-y: auto;
    }

    .changelog-section + .changelog-section {
      margin-top: 1.5rem;
    }

    .changelog-section h3 {
      margin: 0 0 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      color: var(--body-text);
    }

    .changelog-pre {
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
      font-size: 0.875rem;
      line-height: 1.4;
      font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 0.75rem;
      color: #1f2937;
    }

    .changelog-empty {
      font-size: 0.9rem;
      color: #6b7280;
    }

    .changelog-loading {
      font-size: 0.9rem;
      color: #374151;
    }

    .changelog-error {
      color: var(--danger-bg);
      font-weight: 500;
      font-size: 0.95rem;
    }

    .changelog-close {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      border: none;
      background: transparent;
      font-size: 1.5rem;
      line-height: 1;
      color: #6b7280;
      cursor: pointer;
    }

    .changelog-close:hover {
      color: #111827;
    }
  </style>
  <style id="custom-styles"></style>
</head>
<body>
  <!-- Top bar with tabs and buttons -->
  <header id="top-bar" class="flex items-center gap-1 px-3 py-2 shadow" style="height:40px">
    <div id="tabs-container" class="flex items-center gap-1 flex-wrap"></div>
    <button id="add-tab" title="Neuen Tab erstellen" class="text-xl px-2 py-1 leading-none hover:opacity-80">➕</button>
    <div class="ml-auto flex items-center gap-2">
      <button id="update-status" class="text-sm px-3 py-1 rounded hidden">Update prüfen</button>
      <button id="select-root" class="text-sm px-3 py-1 rounded">Ordner wählen</button>
      <button id="open-settings" title="Einstellungen" class="bg-gray-300 hover:bg-gray-400 text-gray-800 text-sm px-3 py-1 rounded">⚙️</button>
    </div>
  </header>
  <div class="flex" style="height: calc(100% - 40px);">
    <aside id="sidebar" class="w-72 min-h-full p-3 relative transition-all duration-300 ease-in-out">
      <button id="sidebar-toggle" class="absolute top-2 right-2 text-xl collapse-icon" title="Liste ein-/ausblenden">⬅️</button>
      <h2 class="font-semibold mb-2 list-content">Module</h2>
      <div id="module-list" class="list-content flex flex-col gap-2 text-sm">
        <div class="text-gray-400">Wähle oben einen Ordner…</div>
      </div>
    </aside>
    <main class="flex-1 min-h-full overflow-auto">
      <div id="grids" class="relative w-full h-full"></div>
    </main>
  </div>
  <input type="file" id="folder-input" webkitdirectory directory multiple hidden />
  <!-- Settings Modal -->
  <div id="settings-modal" class="modal-overlay hidden">
    <div class="modal">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-lg font-semibold">Einstellungen</h2>
        <div class="flex gap-2"></div>
      </div>
      <div class="settings-nav flex gap-2 mb-3">
        <button data-section="general" class="active">Allgemein</button>
        <button data-section="topbar">Topbar</button>
        <button data-section="sidebar">Sidebar</button>
        <button data-section="modules">Module</button>
        <button data-section="updates">Updates</button>
      </div>
      <div class="settings-content mt-1 pr-1">
        <!-- Allgemein section -->
        <div id="section-general" class="settings-section active">
          <div class="field-grid">
            <div class="form-field">
              <label>App Hintergrundfarbe</label>
              <input type="color" id="setting-app-bg" value="#f3f4f6" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Border Farbe</label>
            <input type="color" id="setting-border-color" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Primäre Buttonfarbe</label>
            <input type="color" id="setting-button-bg" value="#2563eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Primäre Buttontextfarbe</label>
            <input type="color" id="setting-button-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field col-span-2">
            <div class="flex items-center justify-between gap-4">
              <div>
                <label for="setting-grid-auto-arrange">Automatisches Nachrücken</label>
                <p class="text-xs text-gray-500">Module rücken Lücken automatisch nach oben, wenn diese Option aktiv ist.</p>
              </div>
              <label for="setting-grid-auto-arrange" class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="setting-grid-auto-arrange" class="sr-only peer">
                <div class="w-11 h-6 bg-gray-300 rounded-full transition peer-focus:ring-2 peer-focus:ring-blue-300 peer-checked:bg-blue-600"></div>
                <span class="absolute left-1 top-1 h-4 w-4 rounded-full bg-white transition-transform peer-checked:translate-x-5"></span>
              </label>
            </div>
          </div>
        </div>
      </div>
        <!-- Topbar section -->
        <div id="section-topbar" class="settings-section">
          <div class="field-grid">
            <div class="form-field">
              <label>Topbar Hintergrundfarbe</label>
              <input type="color" id="setting-topbar-bg" value="#ffffff" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Aktiver Tab Hintergrund</label>
            <input type="color" id="setting-tab-active-bg" value="#2563eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Aktiver Tab Text</label>
            <input type="color" id="setting-tab-active-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Inaktiver Tab Hintergrund</label>
            <input type="color" id="setting-tab-inactive-bg" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Inaktiver Tab Text</label>
            <input type="color" id="setting-tab-inactive-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
        <!-- Sidebar section -->
        <div id="section-sidebar" class="settings-section">
          <div class="field-grid">
            <div class="form-field">
              <label>Sidebar Hintergrundfarbe</label>
              <input type="color" id="setting-sidebar-bg" value="#f3f4f6" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Sidebar Textfarbe</label>
            <input type="color" id="setting-sidebar-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Drag &amp; Drop Hinweisfarbe</label>
            <input type="color" id="setting-grid-hint" value="#60a5fa" class="w-full border rounded p-1">
          </div>
          <!-- New sidebar module card settings -->
          <div class="form-field">
            <label>Sidebar Modul Hintergrundfarbe</label>
            <input type="color" id="setting-sidebar-module-bg" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Sidebar Modul Textfarbe</label>
            <input type="color" id="setting-sidebar-module-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Sidebar Modul Rahmenfarbe</label>
            <input type="color" id="setting-sidebar-module-border" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
        <!-- Modules section -->
        <div id="section-modules" class="settings-section">
          <div class="field-grid">
            <div class="form-field">
              <label>Modul Hintergrundfarbe</label>
              <input type="color" id="setting-module-bg" value="#005983" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Modul Textfarbe</label>
            <input type="color" id="setting-text-color" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Modul Rundung (px)</label>
            <input type="number" id="setting-border-radius" value="20" class="w-full border rounded p-1" min="0">
          </div>
          <div class="form-field">
            <label>Modul Kopfzeile Hintergrund</label>
            <input type="color" id="setting-module-header-bg" value="#0a0a0a" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Modul Kopfzeile Textfarbe</label>
            <input type="color" id="setting-module-header-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Löschen-Button Hintergrundfarbe</label>
            <input type="color" id="setting-danger-bg" value="#ef4444" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Löschen-Button Textfarbe</label>
            <input type="color" id="setting-danger-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Modul Rahmenfarbe</label>
            <input type="color" id="setting-module-border-color" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
        <div id="section-updates" class="settings-section">
          <div class="space-y-4">
            <div class="text-sm space-y-2">
              <div class="update-settings-row">
                <div class="update-folder-info">
                  <span class="font-medium">Update-Ordner:</span>
                  <span id="update-folder-name" class="px-2 py-1 bg-gray-100 rounded">Keiner gewählt</span>
                  <button id="select-update-folder" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded">Ordner wählen</button>
                  <button id="clear-update-folder" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded">Zurücksetzen</button>
                  <span id="update-check-status" class="text-gray-500"></span>
                </div>
                <label class="update-toggle" title="Update-Hinweis im Hauptfenster anzeigen">
                  <span class="sr-only">Update-Hinweis im Hauptfenster anzeigen</span>
                  <input type="checkbox" id="setting-show-update-button">
                  <span class="update-toggle-track"></span>
                  <span class="update-toggle-thumb"></span>
                </label>
              </div>
            </div>
            <div id="updates-empty-state" class="text-sm text-gray-500">Keine Updates erforderlich.</div>
            <div id="update-all-container" class="flex justify-end hidden">
              <button id="update-all" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded">Alle aktualisieren</button>
            </div>
            <div class="updates-table-container overflow-x-auto">
              <table class="min-w-full text-sm border border-gray-200 rounded" id="updates-table">
                <thead class="bg-gray-100">
                  <tr>
                    <th class="text-left px-3 py-2">Datei</th>
                    <th class="text-left px-3 py-2">Version</th>
                    <th class="text-right px-3 py-2">Aktion</th>
                  </tr>
                </thead>
                <tbody id="updates-table-body"></tbody>
              </table>
            </div>
            <div id="update-version-overview" class="border border-gray-200 rounded p-3 text-sm space-y-3">
              <div class="font-semibold text-gray-700">Versionsübersicht</div>
              <div id="update-version-rows" class="version-overview-grid"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="mt-4 flex justify-end gap-2">
        <button id="close-settings" class="bg-gray-300 hover:bg-gray-400 text-gray-800 text-sm px-3 py-1 rounded">Abbrechen</button>
        <button id="save-settings" class="bg-blue-600 hover:bg-blue-700 text-white text-sm px-3 py-1 rounded">Speichern</button>
      </div>
    </div>
  </div>
  <div id="changelog-modal" class="changelog-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="changelog-modal">
      <button id="close-changelog" class="changelog-close" type="button" aria-label="Changelog schließen">×</button>
      <div class="changelog-header">
        <div id="changelog-title" class="changelog-title">Changelog</div>
        <div id="changelog-subtitle" class="changelog-subtitle"></div>
      </div>
      <div id="changelog-body" class="changelog-body">
        <div class="changelog-loading">Lade Changelog…</div>
      </div>
    </div>
  </div>
  <script>
/*
 * Global settings object; defaults correspond to CSS variables defined above.
 * New properties for border colour and sidebar text are included.
 */
let appSettings = {
  appBgColor: '#f3f4f6',
  sidebarBg: '#f3f4f6',
  sidebarText: '#1f2937',
  topBarBg: '#ffffff',
  buttonBg: '#2563eb',
  buttonText: '#ffffff',
  borderColor: '#e5e7eb',
  autoArrangeModules: true,
  moduleBgColor: '#005983',
  textColor: '#ffffff',
  moduleBorderRadius: '1.25rem',
  moduleHeaderBg: 'rgba(255,255,255,0.08)',
  moduleHeaderText: '#ffffff',
  dangerBg: '#ef4444',
  dangerText: '#ffffff',
  tabActiveBg: '#2563eb',
  tabActiveText: '#ffffff',
  tabInactiveBg: '#e5e7eb',
  tabInactiveText: '#1f2937',
  gridHint: '#60a5fa',
  moduleBorderColor: '#e5e7eb',
  sidebarModuleCardBg: '#ffffff',
  sidebarModuleCardText: '#1f2937',
  sidebarModuleCardBorder: '#e5e7eb',
  showUpdateStatusButton: true
};


const layoutFileName = 'layout.json';
const settingsFileName = 'settings.json';
const HTML_FILE_NAME = 'ShopguideV3.html';
const ACTIVE_TAB_STORAGE_KEY = 'modulesLayoutActiveTab';
let rootDirHandle = null;
let updateDirHandle = null;
let modulesDirHandle = null;
let liveModuleTemplates = [];
let tabs = [];
let activeTabIndex = 0;
let tabContextMenu = null;
let tabsSortable = null;
// Start with sidebar closed by default
let isSidebarOpen = false;
let pendingUpdates = [];
let updateCheckInProgress = false;
let originalSettings = null;
let lastUpdateError = false;
let versionOverview = {
  html: {
    localVersion: null,
    updateVersion: null,
    localFileName: HTML_FILE_NAME,
    updateFileName: null
  },
  modules: []
};
let rerunUpdateCheckWhenUnlocked = false;
let changelogRequestToken = 0;
let lastChangelogTrigger = null;

/* ==== UNIQUE IDs ==== */
let usedInstanceIds = new Set();
let nextModuleInstanceId = 1;
function generateInstanceId() {
  if (window.crypto?.randomUUID) {
    let id;
    do { id = 'mod-' + crypto.randomUUID(); }
    while (usedInstanceIds.has(id));
    usedInstanceIds.add(id);
    return id;
  }
  let id;
  do { id = 'mod-' + (nextModuleInstanceId++); }
  while (usedInstanceIds.has(id));
  usedInstanceIds.add(id);
  return id;
}

// Cache DOM elements
const listEl = document.getElementById('module-list');
const gridsContainer = document.getElementById('grids');
const tabsContainer = document.getElementById('tabs-container');
const addTabBtn = document.getElementById('add-tab');
const sidebarEl = document.getElementById('sidebar');
const sidebarToggle = document.getElementById('sidebar-toggle');
const updateStatusBtn = document.getElementById('update-status');
const rootBtn = document.getElementById('select-root');
const settingsBtn = document.getElementById('open-settings');
const settingsModal = document.getElementById('settings-modal');
const closeSettingsBtn = document.getElementById('close-settings');
const saveSettingsBtn = document.getElementById('save-settings');
const updateFolderNameEl = document.getElementById('update-folder-name');
const selectUpdateFolderBtn = document.getElementById('select-update-folder');
const clearUpdateFolderBtn = document.getElementById('clear-update-folder');
const updatesTableBody = document.getElementById('updates-table-body');
const updatesEmptyState = document.getElementById('updates-empty-state');
const updateCheckStatus = document.getElementById('update-check-status');
const versionOverviewContainer = document.getElementById('update-version-overview');
const versionOverviewRowsEl = document.getElementById('update-version-rows');
const changelogOverlay = document.getElementById('changelog-modal');
const changelogTitleEl = document.getElementById('changelog-title');
const changelogSubtitleEl = document.getElementById('changelog-subtitle');
const changelogBodyEl = document.getElementById('changelog-body');
const closeChangelogBtn = document.getElementById('close-changelog');
const updateAllContainer = document.getElementById('update-all-container');
const updateAllBtn = document.getElementById('update-all');
// Settings inputs
const inputAppBg = document.getElementById('setting-app-bg');
const inputBorderColor = document.getElementById('setting-border-color');
const inputButtonBg = document.getElementById('setting-button-bg');
const inputButtonText = document.getElementById('setting-button-text');
const inputTopBarBg = document.getElementById('setting-topbar-bg');
const inputTabActiveBg = document.getElementById('setting-tab-active-bg');
const inputTabActiveText = document.getElementById('setting-tab-active-text');
const inputTabInactiveBg = document.getElementById('setting-tab-inactive-bg');
const inputTabInactiveText = document.getElementById('setting-tab-inactive-text');
const inputSidebarBg = document.getElementById('setting-sidebar-bg');
const inputSidebarText = document.getElementById('setting-sidebar-text');
const inputGridHint = document.getElementById('setting-grid-hint');
const inputAutoArrange = document.getElementById('setting-grid-auto-arrange');
const inputModuleBg = document.getElementById('setting-module-bg');
const inputTextColor = document.getElementById('setting-text-color');
const inputBorderRadius = document.getElementById('setting-border-radius');
const inputModuleHeaderBg = document.getElementById('setting-module-header-bg');
const inputModuleHeaderText = document.getElementById('setting-module-header-text');
const inputDangerBg = document.getElementById('setting-danger-bg');
const inputDangerText = document.getElementById('setting-danger-text');

// New module border and sidebar module card inputs
const inputModuleBorderColor = document.getElementById('setting-module-border-color');
const inputSidebarModuleBg = document.getElementById('setting-sidebar-module-bg');
const inputSidebarModuleText = document.getElementById('setting-sidebar-module-text');
const inputSidebarModuleBorder = document.getElementById('setting-sidebar-module-border');
const inputShowUpdateButton = document.getElementById('setting-show-update-button');

// Navigation buttons for settings
const settingsNavButtons = document.querySelectorAll('.settings-nav button');

// Remember the selected root folder across sessions
const FS_HANDLE_KEY = 'rootDirHandle';
const ROOT_HANDLE_NAME_KEY = 'rootDirDisplayName';
const UPDATE_HANDLE_KEY = 'updateDirHandle';
const UPDATE_HANDLE_NAME_KEY = 'updateDirDisplayName';

let pendingRootPermission = false;
let pendingUpdatePermission = false;

const storedRootFolderName = (() => {
  try {
    return localStorage.getItem(ROOT_HANDLE_NAME_KEY);
  } catch (e) {
    console.warn('Konnte Arbeitsordnernamen nicht aus dem localStorage lesen', e);
    return null;
  }
})();
if (storedRootFolderName && rootBtn) {
  rootBtn.textContent = storedRootFolderName;
  rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
}

const storedUpdateFolderName = (() => {
  try {
    return localStorage.getItem(UPDATE_HANDLE_NAME_KEY);
  } catch (e) {
    console.warn('Konnte Update-Ordnernamen nicht aus dem localStorage lesen', e);
    return null;
  }
})();
if (storedUpdateFolderName && updateFolderNameEl) {
  updateFolderNameEl.textContent = storedUpdateFolderName;
}

function idbOpen() {
  return new Promise((res, rej) => {
    const req = indexedDB.open('modulesApp', 1);
    req.onupgradeneeded = () => req.result.createObjectStore('fs-handles');
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}
async function idbSet(key, val){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction('fs-handles','readwrite');
    tx.objectStore('fs-handles').put(val, key);
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction('fs-handles','readonly');
    const req = tx.objectStore('fs-handles').get(key);
    req.onsuccess = () => res(req.result || null);
    req.onerror = () => rej(req.error);
  });
}
async function idbDel(key){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction('fs-handles','readwrite');
    tx.objectStore('fs-handles').delete(key);
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function ensureRWPermission(handle, opts = {}){
  if (typeof handle?.queryPermission !== 'function') return true;
  const mode = opts.mode || 'readwrite';
  const q = await handle.queryPermission({ mode });
  if (q === 'granted') return true;
  if (opts.request === false) return false;
  try {
    const r = await handle.requestPermission({ mode });
    return r === 'granted';
  } catch (err) {
    console.warn('requestPermission failed', err);
    return false;
  }
}
async function tryRestoreRootHandle(){
  if (!('showDirectoryPicker' in window)) return false;
  try {
    const h = await idbGet(FS_HANDLE_KEY);
    if (!h) return false;
    let ok = await ensureRWPermission(h, { mode: 'readwrite', request: false });
    if (!ok) {
      try {
        ok = await ensureRWPermission(h, { mode: 'readwrite' });
      } catch (permErr) {
        console.warn('requestPermission für Arbeitsordner fehlgeschlagen:', permErr);
      }
    }

    rootDirHandle = h;
    window.rootDirHandle = h;
    const displayName = storedRootFolderName || h.name;
    rootBtn.textContent = displayName;
    try { localStorage.setItem(ROOT_HANDLE_NAME_KEY, h.name); } catch (e) {
      console.warn('Konnte Arbeitsordnernamen nicht speichern', e);
    }

    if (!ok) {
      pendingRootPermission = true;
      rootBtn.classList.remove('bg-gray-300','hover:bg-gray-400','text-gray-800');
      rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
      rootBtn.classList.add('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
      rootBtn.title = 'Bitte Zugriff auf den gespeicherten Arbeitsordner erlauben oder einen neuen wählen.';
      setUpdateStatusButton();
      renderUpdateList();
      return false;
    }

    pendingRootPermission = false;
    rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
    rootBtn.classList.remove('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
    rootBtn.title = '';
    rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');

    await loadModulesFromRoot(h);
    await loadAppSettings();
    applySettings();
    await loadAndInitTabs();
    return true;
  } catch (e) {
    console.warn('Restore root handle failed:', e);
    return false;
  }
}

async function tryRestoreUpdateHandle(){
  if (!('showDirectoryPicker' in window)) return false;
  try {
    const h = await idbGet(UPDATE_HANDLE_KEY);
    if (!h) return false;
    let ok = await ensureRWPermission(h, { request: false, mode: 'read' });
    if (!ok) {
      try {
        ok = await ensureRWPermission(h, { mode: 'read' });
      } catch (permErr) {
        console.warn('requestPermission für Update-Ordner fehlgeschlagen:', permErr);
      }
    }
    updateDirHandle = h;
    if (updateFolderNameEl) updateFolderNameEl.textContent = h.name;
    try { localStorage.setItem(UPDATE_HANDLE_NAME_KEY, h.name); } catch (e) {
      console.warn('Konnte Update-Ordnernamen nicht speichern', e);
    }
    if (!ok) {
      pendingUpdatePermission = true;
      if (updateCheckStatus) {
        updateCheckStatus.textContent = 'Bitte Zugriff auf den Update-Ordner erlauben.';
      }
      setUpdateStatusButton();
      renderUpdateList();
      return false;
    }
    pendingUpdatePermission = false;
    return true;
  } catch (e) {
    console.warn('Restore update handle failed:', e);
    return false;
  }
}

function formatVersionDisplay(val) {
  if (val === null || typeof val === 'undefined') return '–';
  if (typeof val === 'string' && val.trim() === '') return '–';
  return String(val);
}

function normalizeVersionValue(value) {
  if (value === null || typeof value === 'undefined') return null;
  const str = String(value).trim();
  if (!str) return null;
  if (/^unreleased$/i.test(str)) return null;
  return str.replace(/^[vV]\s*/, '').trim();
}

function compareVersions(a, b) {
  const normA = normalizeVersionValue(a);
  const normB = normalizeVersionValue(b);
  if (normA === null && normB === null) return 0;
  if (normA === null) return -1;
  if (normB === null) return 1;

  const partsA = normA.split(/[^0-9A-Za-z]+/).filter(Boolean);
  const partsB = normB.split(/[^0-9A-Za-z]+/).filter(Boolean);
  const len = Math.max(partsA.length, partsB.length);

  for (let i = 0; i < len; i++) {
    const segA = partsA[i] ?? '0';
    const segB = partsB[i] ?? '0';
    const numA = Number(segA);
    const numB = Number(segB);

    const bothNumeric = !Number.isNaN(numA) && !Number.isNaN(numB);
    if (bothNumeric) {
      if (numA > numB) return 1;
      if (numA < numB) return -1;
      continue;
    }

    const cmp = segA.localeCompare(segB, undefined, { numeric: true, sensitivity: 'base' });
    if (cmp > 0) return 1;
    if (cmp < 0) return -1;
  }

  return 0;
}

function parseChangelogSections(text) {
  if (!text) return [];
  const normalized = text.replace(/\r\n/g, '\n');
  const lines = normalized.split('\n');
  const sections = [];
  let current = null;

  for (const line of lines) {
    const headingMatch = line.match(/^##\s*(?:\[(.+?)\]|([^\s]+))(.*)$/);
    if (headingMatch) {
      if (current) {
        sections.push({
          version: current.version,
          rawVersion: current.rawVersion,
          heading: current.heading,
          content: current.lines.join('\n').trim()
        });
      }
      const versionCandidate = (headingMatch[1] || headingMatch[2] || '').trim();
      const headingText = line.replace(/^##\s*/, '').trim();
      current = {
        rawVersion: versionCandidate,
        version: normalizeVersionValue(versionCandidate) || null,
        heading: headingText,
        lines: []
      };
    } else if (current) {
      current.lines.push(line);
    }
  }

  if (current) {
    sections.push({
      version: current.version,
      rawVersion: current.rawVersion,
      heading: current.heading,
      content: current.lines.join('\n').trim()
    });
  }

  return sections;
}

function filterChangelogSections(sections, currentVersion, targetVersion) {
  const current = normalizeVersionValue(currentVersion);
  const target = normalizeVersionValue(targetVersion);

  return sections.filter(section => {
    if (!section.version) return false;
    if (target && compareVersions(section.version, target) === 1) return false;
    if (current && compareVersions(section.version, current) <= 0) return false;
    return true;
  });
}

async function findChangelogFile(dirHandle, relPath = '') {
  if (!dirHandle?.values) return null;
  const entries = [];

  try {
    for await (const entry of dirHandle.values()) {
      entries.push(entry);
    }
  } catch (err) {
    console.warn('Changelog-Dateien konnten nicht gelesen werden', err);
    return null;
  }

  const files = entries
    .filter(entry => entry.kind === 'file')
    .sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));

  for (const file of files) {
    if (file.name.toLowerCase().includes('changelog')) {
      return {
        handle: file,
        name: file.name,
        path: relPath ? `${relPath}/${file.name}` : file.name
      };
    }
  }

  for (const entry of entries) {
    if (entry.kind === 'directory') {
      const childRel = relPath ? `${relPath}/${entry.name}` : entry.name;
      const found = await findChangelogFile(entry, childRel);
      if (found) return found;
    }
  }

  return null;
}

function buildModuleChangelogDisplayPath(baseModulePath, relativeFilePath) {
  if (!relativeFilePath) return null;
  const cleanBase = (baseModulePath || '').replace(/^[\\/]+|[\\/]+$/g, '');
  const cleanFile = relativeFilePath.replace(/^[\\/]+/, '');
  const parts = ['modules'];
  if (cleanBase) parts.push(cleanBase);
  if (cleanFile) parts.push(cleanFile);
  return parts.join('/');
}

async function ensureChangelogHandle(item) {
  if (!item) return null;
  if (item.changelogHandle) return item.changelogHandle;
  if (!item.updateDirHandle) return null;

  try {
    const info = await findChangelogFile(item.updateDirHandle);
    if (info?.handle) {
      const relativePath = (info.path || info.name || '').replace(/^[\\/]+/, '');
      const moduleBasePath = item.sourceRelPath || item.targetRelPath || '';
      item.changelogHandle = info.handle;
      item.changelogFileName = info.name;
      item.changelogRelativePath = relativePath || null;
      item.changelogPath = relativePath
        ? buildModuleChangelogDisplayPath(moduleBasePath, relativePath)
        : item.changelogPath || null;
      return item.changelogHandle;
    }
  } catch (err) {
    console.warn('Changelog-Suche fehlgeschlagen', err);
  }

  return null;
}

function updateChangelogSubtitle(item) {
  if (!changelogSubtitleEl) return;
  if (!item) {
    changelogSubtitleEl.textContent = '';
    return;
  }

  const parts = [];
  parts.push(`Versionen: ${formatVersionDisplay(item.currentVersion)} → ${formatVersionDisplay(item.newVersion)}`);
  const moduleBasePath = item.sourceRelPath || item.targetRelPath || '';
  const displayPath = item.changelogPath
    || (item.changelogRelativePath ? buildModuleChangelogDisplayPath(moduleBasePath, item.changelogRelativePath) : null);
  if (displayPath) {
    parts.push(`Datei: ${displayPath}`);
  } else if (item.changelogFileName) {
    parts.push(`Datei: ${item.changelogFileName}`);
  }
  changelogSubtitleEl.textContent = parts.join(' • ');
}

function closeChangelogModal() {
  if (!changelogOverlay) return;
  changelogOverlay.classList.remove('open');
  changelogOverlay.setAttribute('aria-hidden', 'true');
  changelogRequestToken++;
  if (changelogBodyEl) changelogBodyEl.innerHTML = '';
  if (lastChangelogTrigger && typeof lastChangelogTrigger.focus === 'function') {
    try { lastChangelogTrigger.focus(); } catch {}
  }
  lastChangelogTrigger = null;
}

async function openChangelogModal(item) {
  if (!item || !changelogOverlay || !changelogBodyEl) return;

  lastChangelogTrigger = document.activeElement instanceof HTMLElement ? document.activeElement : null;

  if (changelogTitleEl) {
    const title = item.displayName ? `Changelog – ${item.displayName}` : 'Changelog';
    changelogTitleEl.textContent = title;
  }

  updateChangelogSubtitle(item);

  changelogBodyEl.innerHTML = '<div class="changelog-loading">Lade Changelog…</div>';
  changelogOverlay.classList.add('open');
  changelogOverlay.setAttribute('aria-hidden', 'false');

  const requestId = ++changelogRequestToken;

  if (closeChangelogBtn && typeof closeChangelogBtn.focus === 'function') {
    closeChangelogBtn.focus();
  }

  try {
    const handle = await ensureChangelogHandle(item);
    if (requestId !== changelogRequestToken) return;

    updateChangelogSubtitle(item);

    if (!handle) {
      changelogBodyEl.innerHTML = '<div class="changelog-empty">Keine Changelog-Datei gefunden.</div>';
      return;
    }

    const file = await handle.getFile();
    const text = await file.text();
    if (requestId !== changelogRequestToken) return;

    const sections = parseChangelogSections(text);
    let relevantSections = filterChangelogSections(sections, item.currentVersion, item.newVersion);

    changelogBodyEl.innerHTML = '';

    if (!sections.length) {
      const empty = document.createElement('div');
      empty.className = 'changelog-empty';
      empty.textContent = 'Die Changelog-Datei enthält keine Einträge.';
      changelogBodyEl.appendChild(empty);
      return;
    }

    if (!relevantSections.length) {
      const notice = document.createElement('div');
      notice.className = 'changelog-empty';
      notice.textContent = 'Keine Einträge für den Versionsbereich gefunden. Vollständiger Changelog wird angezeigt.';
      changelogBodyEl.appendChild(notice);
      relevantSections = sections;
    }

    relevantSections.forEach(section => {
      const sectionEl = document.createElement('section');
      sectionEl.className = 'changelog-section';

      const headingEl = document.createElement('h3');
      headingEl.textContent = section.heading || (section.rawVersion ? `Version ${section.rawVersion}` : 'Changelog-Eintrag');
      sectionEl.appendChild(headingEl);

      const pre = document.createElement('pre');
      pre.className = 'changelog-pre';
      pre.textContent = section.content || 'Keine Details vorhanden.';
      sectionEl.appendChild(pre);

      changelogBodyEl.appendChild(sectionEl);
    });
  } catch (err) {
    console.error('Changelog konnte nicht geladen werden', err);
    if (requestId !== changelogRequestToken) return;
    changelogBodyEl.innerHTML = '<div class="changelog-error">Der Changelog konnte nicht gelesen werden.</div>';
  }
}

if (closeChangelogBtn) {
  closeChangelogBtn.addEventListener('click', closeChangelogModal);
}
if (changelogOverlay) {
  changelogOverlay.addEventListener('click', event => {
    if (event.target === changelogOverlay) {
      closeChangelogModal();
    }
  });
}
document.addEventListener('keydown', event => {
  if (event.key === 'Escape' && changelogOverlay?.classList.contains('open')) {
    closeChangelogModal();
  }
});

function setUpdateStatusButton(state) {
  if (!updateStatusBtn) return;
  updateStatusBtn.className = 'text-sm px-3 py-1 rounded';
  updateStatusBtn.disabled = false;

  if (appSettings.showUpdateStatusButton === false) {
    updateStatusBtn.classList.add('hidden');
    return;
  }

  updateStatusBtn.classList.remove('hidden');

  if (pendingRootPermission) {
    updateStatusBtn.textContent = 'Arbeitsordner entsperren';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-yellow-500','text-gray-900','cursor-not-allowed');
    return;
  }

  if (pendingUpdatePermission) {
    updateStatusBtn.textContent = 'Update-Ordner entsperren';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-yellow-500','text-gray-900','cursor-not-allowed');
    return;
  }

  if (!rootDirHandle) {
    updateStatusBtn.textContent = 'Kein Arbeitsordner';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-gray-300','text-gray-700','cursor-not-allowed');
    return;
  }

  if (!updateDirHandle) {
    updateStatusBtn.textContent = 'Kein Update-Ordner';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-gray-300','text-gray-700','cursor-not-allowed');
    return;
  }

  if (state === 'checking') {
    updateStatusBtn.textContent = 'Prüfe…';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-gray-300','text-gray-700','cursor-wait');
    return;
  }

  if (lastUpdateError) {
    updateStatusBtn.textContent = 'Prüfung fehlgeschlagen';
    updateStatusBtn.classList.add('bg-yellow-500','hover:bg-yellow-600','text-white');
    return;
  }

  if (pendingUpdates.length) {
    updateStatusBtn.textContent = 'Update available!';
    updateStatusBtn.classList.add('bg-red-600','hover:bg-red-700','text-white');
  } else {
    updateStatusBtn.textContent = 'Up to date!';
    updateStatusBtn.classList.add('bg-green-600','hover:bg-green-700','text-white');
  }
}

function renderUpdateList() {
  if (!updatesTableBody || !updatesEmptyState) return;
  updatesTableBody.innerHTML = '';
  if (updateAllContainer) updateAllContainer.classList.add('hidden');
  if (updateAllBtn) {
    updateAllBtn.disabled = true;
    updateAllBtn.textContent = 'Alle aktualisieren';
    updateAllBtn.classList.remove('opacity-60','cursor-wait','cursor-not-allowed');
  }
  if (pendingRootPermission) {
    updatesEmptyState.textContent = 'Bitte erlauben Sie den Zugriff auf den Arbeitsordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    setUpdateStatusButton();
    return;
  }
  if (pendingUpdatePermission) {
    updatesEmptyState.textContent = 'Bitte erlauben Sie den Zugriff auf den Update-Ordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    setUpdateStatusButton();
    return;
  }
  if (!rootDirHandle) {
    updatesEmptyState.textContent = 'Bitte wählen Sie einen Arbeitsordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    renderVersionOverview();
    setUpdateStatusButton();
    return;
  }

  if (!updateDirHandle) {
    updatesEmptyState.textContent = 'Bitte wählen Sie einen Update-Ordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    renderVersionOverview();
    setUpdateStatusButton();
    return;
  }

  if (!pendingUpdates.length) {
    updatesEmptyState.textContent = 'Keine Updates erforderlich.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus && !lastUpdateError) updateCheckStatus.textContent = 'Keine Updates erforderlich.';
    renderVersionOverview();
    setUpdateStatusButton();
    return;
  }

  updatesEmptyState.classList.add('hidden');
  if (updateCheckStatus && !lastUpdateError) {
    updateCheckStatus.textContent = `${pendingUpdates.length} Update${pendingUpdates.length === 1 ? '' : 's'} verfügbar.`;
  }

  if (updateAllContainer) updateAllContainer.classList.remove('hidden');
  if (updateAllBtn) {
    updateAllBtn.disabled = false;
    updateAllBtn.textContent = 'Alle aktualisieren';
  }

  pendingUpdates.forEach((item, index) => {
    const tr = document.createElement('tr');
    tr.className = index % 2 ? 'bg-white' : 'bg-gray-50';

    const tdPath = document.createElement('td');
    tdPath.className = 'px-3 py-2 align-top';
    tdPath.textContent = item.displayName || item.path;

    const tdVersion = document.createElement('td');
    tdVersion.className = 'px-3 py-2 align-top whitespace-nowrap';
    tdVersion.textContent = `${formatVersionDisplay(item.currentVersion)} → ${formatVersionDisplay(item.newVersion)}`;

    const tdAction = document.createElement('td');
    tdAction.className = 'px-3 py-2 align-top';
    const actionWrapper = document.createElement('div');
    actionWrapper.className = 'flex justify-end flex-wrap gap-2';

    if (item.type === 'module') {
      const changelogBtn = document.createElement('button');
      changelogBtn.type = 'button';
      changelogBtn.className = 'bg-white border border-gray-300 text-gray-800 px-3 py-1 rounded hover:bg-gray-100';
      changelogBtn.textContent = 'Changelog';
      changelogBtn.addEventListener('click', () => {
        openChangelogModal(item);
      });
      actionWrapper.appendChild(changelogBtn);
    }

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded';
    btn.textContent = 'sync';
    btn.addEventListener('click', async () => {
      btn.disabled = true;
      btn.classList.add('opacity-60','cursor-wait');
      try {
        await applySingleUpdate(item);
      } catch (err) {
        console.error('Fehler beim Aktualisieren', err);
        alert('Die Datei konnte nicht aktualisiert werden.');
      } finally {
        btn.disabled = false;
        btn.classList.remove('opacity-60','cursor-wait');
      }
    });
    actionWrapper.appendChild(btn);

    tdAction.appendChild(actionWrapper);

    tr.appendChild(tdPath);
    tr.appendChild(tdVersion);
    tr.appendChild(tdAction);
    updatesTableBody.appendChild(tr);
  });

  renderVersionOverview();
  setUpdateStatusButton();
}

function renderVersionOverview() {
  if (!versionOverviewContainer || !versionOverviewRowsEl) return;
  const htmlInfo = versionOverview?.html || { localVersion: null, updateVersion: null };
  const modulesInfo = Array.isArray(versionOverview?.modules) ? versionOverview.modules : [];

  versionOverviewRowsEl.innerHTML = '';

  const headerName = document.createElement('div');
  headerName.className = 'version-overview-header';
  headerName.textContent = 'Datei';
  const headerLocal = document.createElement('div');
  headerLocal.className = 'version-overview-header text-right';
  headerLocal.textContent = 'Aktuell';
  const headerUpdate = document.createElement('div');
  headerUpdate.className = 'version-overview-header text-right';
  headerUpdate.textContent = 'Update';
  versionOverviewRowsEl.append(headerName, headerLocal, headerUpdate);

  const addRow = (label, localValue, updateValue) => {
    const nameEl = document.createElement('div');
    nameEl.className = 'version-overview-name';
    nameEl.textContent = label;

    const localEl = document.createElement('div');
    localEl.className = 'version-overview-value';
    localEl.textContent = localValue;

    const updateEl = document.createElement('div');
    updateEl.className = 'version-overview-value';
    updateEl.textContent = updateValue;

    versionOverviewRowsEl.append(nameEl, localEl, updateEl);
  };

  const htmlLabel = htmlInfo.updateFileName || htmlInfo.localFileName || HTML_FILE_NAME;
  addRow(
    `HTML (${htmlLabel})`,
    formatVersionDisplay(htmlInfo.localVersion),
    formatVersionDisplay(htmlInfo.updateVersion)
  );

  if (!modulesInfo.length) {
    const emptyEl = document.createElement('div');
    emptyEl.className = 'version-overview-empty';
    emptyEl.textContent = 'Keine Module gefunden.';
    versionOverviewRowsEl.appendChild(emptyEl);
    return;
  }

  modulesInfo.forEach(mod => {
    addRow(
      mod.name,
      formatVersionDisplay(mod.localVersion),
      formatVersionDisplay(mod.updateVersion)
    );
  });
}

async function readHtmlVersion(rootHandle) {
  if (!rootHandle) return null;

  const readFromHandle = async (fileHandle, fileName) => {
    const file = await fileHandle.getFile();
    const text = await file.text();
    const match = text.match(/<!--\s*Version:\s*([^>]+?)\s*-->/i);
    const version = match ? match[1].trim() : null;
    return { version, fileHandle, fileName };
  };

  try {
    const fileHandle = await rootHandle.getFileHandle(HTML_FILE_NAME, { create: false });
    return await readFromHandle(fileHandle, HTML_FILE_NAME);
  } catch (e) {
    if (e?.name !== 'NotFoundError') {
      console.warn('HTML-Version konnte nicht gelesen werden', e);
      return null;
    }
  }

  const htmlCandidates = [];
  try {
    for await (const entry of rootHandle.values()) {
      if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.html')) {
        htmlCandidates.push(entry.name);
        if (htmlCandidates.length > 1) break;
      }
    }
  } catch (err) {
    console.warn('HTML-Dateien konnten nicht ermittelt werden', err);
    return null;
  }

  if (htmlCandidates.length === 1) {
    const fallbackName = htmlCandidates[0];
    try {
      const fileHandle = await rootHandle.getFileHandle(fallbackName, { create: false });
      return await readFromHandle(fileHandle, fallbackName);
    } catch (err) {
      console.warn('Fallback-HTML-Version konnte nicht gelesen werden', err);
      return null;
    }
  }

  return null;
}

async function gatherModulesMetadata(rootHandle) {
  const modules = new Map();
  if (!rootHandle) return { modules };
  let modulesRoot;
  try {
    modulesRoot = await rootHandle.getDirectoryHandle('modules', { create: false });
  } catch {
    return { modules };
  }

  async function walk(dirHandle, relPath) {
    const entries = [];
    for await (const entry of dirHandle.values()) entries.push(entry);

    let moduleData = null;
    for (const entry of entries) {
      if (entry.kind === 'file' && entry.name.endsWith('.json')) {
        try {
          const file = await entry.getFile();
          const parsed = JSON.parse(await file.text());
          if (parsed && typeof parsed === 'object') {
            const moduleId = parsed.moduleId || parsed.id || parsed.name || relPath;
            if (moduleId) {
              moduleData = {
                moduleId,
                version: parsed.version ?? null,
                name: parsed.name || moduleId,
                relPath,
                dirHandle,
                raw: parsed
              };
              break;
            }
          }
        } catch (e) {
          console.warn('Modul-Metadaten konnten nicht gelesen werden', e);
        }
      }
    }

    if (moduleData) {
      const versionValue = moduleData.version;
      modules.set(moduleData.moduleId, {
        moduleId: moduleData.moduleId,
        version: versionValue === null || typeof versionValue === 'undefined' ? null : String(versionValue),
        name: moduleData.name,
        relPath,
        dirHandle
      });
    }

    for (const entry of entries) {
      if (entry.kind === 'directory') {
        const childRel = relPath ? `${relPath}/${entry.name}` : entry.name;
        await walk(entry, childRel);
      }
    }
  }

  await walk(modulesRoot, '');
  return { modules };
}

async function collectVersionDiffs(updateHandle, localHandle) {
  const overview = {
    html: {
      localVersion: null,
      updateVersion: null,
      localFileName: HTML_FILE_NAME,
      updateFileName: null
    },
    modules: []
  };
  const diffs = [];

  let localHtml = null;
  let updateHtml = null;
  try { localHtml = await readHtmlVersion(localHandle); } catch {}
  try { updateHtml = await readHtmlVersion(updateHandle); } catch {}

  if (localHtml) {
    overview.html.localVersion = localHtml.version || null;
    overview.html.localFileName = localHtml.fileName || HTML_FILE_NAME;
  }
  if (updateHtml) {
    overview.html.updateVersion = updateHtml.version || null;
    overview.html.updateFileName = updateHtml.fileName || null;
  }

  if (updateHtml && (updateHtml.version || !localHtml)) {
    const localVersion = localHtml?.version || null;
    if (localVersion !== updateHtml.version) {
      const sourceFileName = updateHtml.fileName || HTML_FILE_NAME;
      diffs.push({
        type: 'html',
        path: sourceFileName,
        displayName: sourceFileName,
        currentVersion: localVersion,
        newVersion: updateHtml.version || null,
        sourcePath: sourceFileName,
        targetPath: localHtml?.fileName || HTML_FILE_NAME
      });
    }
  }

  const localModules = await gatherModulesMetadata(localHandle);
  const updateModules = await gatherModulesMetadata(updateHandle);
  const moduleIds = new Set([
    ...Array.from(localModules.modules.keys()),
    ...Array.from(updateModules.modules.keys())
  ]);

  const modulesList = [];
  for (const moduleId of moduleIds) {
    const localMeta = localModules.modules.get(moduleId) || null;
    const updateMeta = updateModules.modules.get(moduleId) || null;
    const name = updateMeta?.name || localMeta?.name || moduleId;
    const localVersion = localMeta?.version || null;
    const updateVersion = updateMeta?.version || null;
    modulesList.push({ moduleId, name, localVersion, updateVersion });

    if (updateMeta && (localVersion !== updateVersion)) {
      const changelogInfo = updateMeta?.dirHandle ? await findChangelogFile(updateMeta.dirHandle) : null;
      const changelogRelativePath = (changelogInfo?.path || changelogInfo?.name || '').replace(/^[\\/]+/, '');
      const changelogDisplayPath = changelogInfo && changelogRelativePath
        ? buildModuleChangelogDisplayPath(updateMeta?.relPath || '', changelogRelativePath)
        : null;
      diffs.push({
        type: 'module',
        moduleId,
        path: updateMeta.relPath ? `modules/${updateMeta.relPath}` : `modules/${moduleId}`,
        displayName: name,
        currentVersion: localVersion,
        newVersion: updateVersion,
        sourceRelPath: updateMeta.relPath,
        targetRelPath: localMeta?.relPath || updateMeta.relPath,
        updateDirHandle: updateMeta.dirHandle,
        localDirHandle: localMeta?.dirHandle || null,
        changelogHandle: changelogInfo?.handle || null,
        changelogFileName: changelogInfo?.name || null,
        changelogPath: changelogDisplayPath,
        changelogRelativePath: changelogRelativePath || null
      });
    }
  }

  modulesList.sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));
  overview.modules = modulesList;

  diffs.sort((a, b) => {
    const nameA = (a.displayName || a.path || '').toLowerCase();
    const nameB = (b.displayName || b.path || '').toLowerCase();
    return nameA.localeCompare(nameB, 'de', { sensitivity: 'base' });
  });

  return { diffs, overview };
}

async function ensureDirectoryChain(root, parts, { create = true } = {}) {
  let current = root;
  for (const part of parts) {
    if (!part) continue;
    current = await current.getDirectoryHandle(part, { create });
  }
  return current;
}

async function applySingleUpdate(item, { skipRecheck = false } = {}) {
  if (!rootDirHandle) return;
  if (!item) return;

  try {
    if (item.type === 'html') {
      if (!updateDirHandle) throw new Error('Kein Update-Ordner vorhanden.');
      const sourceFileName = item.sourcePath || HTML_FILE_NAME;
      const updateFileHandle = await updateDirHandle.getFileHandle(sourceFileName, { create: false });
      const updateFile = await updateFileHandle.getFile();
      const targetFileHandle = await rootDirHandle.getFileHandle(sourceFileName, { create: true });
      const writable = await targetFileHandle.createWritable();
      await writable.write(await updateFile.arrayBuffer());
      await writable.close();
      await removeOtherHtmlFiles(rootDirHandle, sourceFileName);
    } else if (item.type === 'module') {
      if (!updateDirHandle) throw new Error('Kein Update-Ordner vorhanden.');
      const sourceSegments = ['modules', ...(item.sourceRelPath ? item.sourceRelPath.split('/') : [])];
      const targetSegments = ['modules', ...(item.targetRelPath ? item.targetRelPath.split('/') : [])];
      const sourceDir = await ensureDirectoryChain(updateDirHandle, sourceSegments, { create: false });
      const targetDir = await ensureDirectoryChain(rootDirHandle, targetSegments, { create: true });
      await syncDirectoryContents(sourceDir, targetDir);
    } else if (item.sourcePath) {
      if (!updateDirHandle) throw new Error('Kein Update-Ordner vorhanden.');
      const segments = item.sourcePath.split('/');
      const fileName = segments.pop();
      const sourceDir = await ensureDirectoryChain(updateDirHandle, segments, { create: false });
      const updateFileHandle = await sourceDir.getFileHandle(fileName, { create: false });
      const targetDir = await ensureDirectoryChain(rootDirHandle, segments, { create: true });
      const targetFileHandle = await targetDir.getFileHandle(fileName, { create: true });
      const updateFile = await updateFileHandle.getFile();
      const writable = await targetFileHandle.createWritable();
      await writable.write(await updateFile.arrayBuffer());
      await writable.close();
    }
  } catch (err) {
    console.error('Fehler beim Synchronisieren', err);
    throw err;
  }

  if (!skipRecheck) {
    await runUpdateCheck();
  }
}

async function syncDirectoryContents(sourceDir, targetDir) {
  const sourceEntries = new Map();
  for await (const entry of sourceDir.values()) {
    sourceEntries.set(entry.name, entry);
  }

  const targetEntries = [];
  for await (const entry of targetDir.values()) {
    targetEntries.push(entry);
  }

  for (const entry of targetEntries) {
    if (!sourceEntries.has(entry.name)) {
      try {
        await targetDir.removeEntry(entry.name, { recursive: true });
      } catch (err) {
        if (err?.name !== 'NotFoundError') {
          console.warn('Eintrag konnte nicht entfernt werden', err);
        }
      }
    }
  }

  for (const [name, entry] of sourceEntries.entries()) {
    if (entry.kind === 'file') {
      const file = await entry.getFile();
      const targetFileHandle = await targetDir.getFileHandle(name, { create: true });
      const writable = await targetFileHandle.createWritable();
      await writable.write(await file.arrayBuffer());
      await writable.close();
    } else if (entry.kind === 'directory') {
      const subTarget = await targetDir.getDirectoryHandle(name, { create: true });
      await syncDirectoryContents(entry, subTarget);
    }
  }
}

async function removeOtherHtmlFiles(rootHandle, keepFileName) {
  if (!rootHandle) return;
  const toRemove = [];
  for await (const entry of rootHandle.values()) {
    if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.html') && entry.name !== keepFileName) {
      toRemove.push(entry.name);
    }
  }

  for (const name of toRemove) {
    try {
      await rootHandle.removeEntry(name);
    } catch (err) {
      if (err?.name !== 'NotFoundError') {
        console.warn(`Konnte HTML-Datei ${name} nicht entfernen`, err);
      }
    }
  }
}

async function runUpdateCheck() {
  if (updateCheckInProgress) {
    rerunUpdateCheckWhenUnlocked = true;
    return;
  }
  lastUpdateError = false;

  if (pendingRootPermission || pendingUpdatePermission) {
    rerunUpdateCheckWhenUnlocked = true;
    renderUpdateList();
    setUpdateStatusButton();
    return;
  }

  if (!rootDirHandle && !updateDirHandle) {
    versionOverview = {
      html: {
        localVersion: null,
        updateVersion: null,
        localFileName: HTML_FILE_NAME,
        updateFileName: null
      },
      modules: []
    };
    pendingUpdates = [];
    rerunUpdateCheckWhenUnlocked = false;
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    renderUpdateList();
    return;
  }

  if (rootDirHandle && updateDirHandle) {
    updateCheckInProgress = true;
    rerunUpdateCheckWhenUnlocked = false;
    setUpdateStatusButton('checking');
    if (updateCheckStatus) updateCheckStatus.textContent = 'Prüfung läuft…';
  } else {
    rerunUpdateCheckWhenUnlocked = false;
  }

  try {
    const result = await collectVersionDiffs(updateDirHandle, rootDirHandle);
    versionOverview = result.overview;
    pendingUpdates = rootDirHandle && updateDirHandle ? result.diffs : [];
    lastUpdateError = false;
    if (updateCheckStatus && rootDirHandle && updateDirHandle) {
      if (!pendingUpdates.length) {
        updateCheckStatus.textContent = 'Letzte Prüfung abgeschlossen.';
      } else {
        updateCheckStatus.textContent = `${pendingUpdates.length} Update${pendingUpdates.length === 1 ? '' : 's'} verfügbar.`;
      }
    }
    if (updateCheckStatus && (!rootDirHandle || !updateDirHandle)) {
      updateCheckStatus.textContent = '';
    }
  } catch (err) {
    console.error('Update-Prüfung fehlgeschlagen', err);
    pendingUpdates = [];
    lastUpdateError = true;
    if (updateCheckStatus && rootDirHandle && updateDirHandle) {
      updateCheckStatus.textContent = 'Fehler bei der Prüfung.';
    }
    try {
      const fallback = await collectVersionDiffs(null, rootDirHandle);
      versionOverview = fallback.overview;
    } catch {}
  } finally {
    updateCheckInProgress = false;
    renderUpdateList();
    if (rerunUpdateCheckWhenUnlocked && !pendingRootPermission && !pendingUpdatePermission) {
      rerunUpdateCheckWhenUnlocked = false;
      await runUpdateCheck();
    }
  }
}

function activateSettingsSection(section) {
  document.querySelectorAll('.settings-nav button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.section === section);
  });
  document.querySelectorAll('.settings-section').forEach(sec => {
    sec.classList.toggle('active', sec.id === `section-${section}`);
  });
}

function openSettings(section = 'general') {
  originalSettings = JSON.parse(JSON.stringify(appSettings));
  populateInputsFromSettings();
  settingsModal.classList.remove('hidden');
  activateSettingsSection(section);
}


document.addEventListener('DOMContentLoaded', async () => {
  // Initialize sidebar collapsed state
  sidebarEl.classList.add('collapsed');
  // Trigger fade-in animation on initial load
  document.body.classList.add('fade-in');

  setUpdateStatusButton();
  renderUpdateList();

  // Sidebar toggle
  sidebarToggle.addEventListener('click', () => {
    isSidebarOpen = !isSidebarOpen;
    sidebarEl.classList.toggle('collapsed', !isSidebarOpen);
    updateModuleDraggable();
    updateGridDraggable();
  });

  // Folder selection
  rootBtn.addEventListener('click', async () => {
    if (pendingRootPermission && rootDirHandle) {
      try {
        const granted = await ensureRWPermission(rootDirHandle, { mode: 'readwrite' });
        if (granted) {
          pendingRootPermission = false;
          rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
          rootBtn.classList.remove('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
          rootBtn.title = '';
          rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
          await loadModulesFromRoot(rootDirHandle);
          await loadAppSettings();
          applySettings();
          await loadAndInitTabs();
          await runUpdateCheck();
          return;
        }
      } catch (err) {
        console.warn('Erneute Berechtigungsabfrage für Arbeitsordner fehlgeschlagen', err);
      }
    }
    if (window.showDirectoryPicker) {
      try {
        rootDirHandle = await window.showDirectoryPicker();
        window.rootDirHandle = rootDirHandle;                      // expose
        rootBtn.textContent = rootDirHandle.name;
        await idbSet(FS_HANDLE_KEY, rootDirHandle);                // persist handle
        try { localStorage.setItem(ROOT_HANDLE_NAME_KEY, rootDirHandle.name); } catch (e) {
          console.warn('Konnte Arbeitsordnernamen nicht speichern', e);
        }
        localStorage.setItem('rememberRootMeta', JSON.stringify({  // optional UI hint
          name: rootDirHandle.name, ts: Date.now()
        }));
        rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
        rootBtn.classList.remove('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
        rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
        pendingRootPermission = false;
        rootBtn.title = '';
        await loadModulesFromRoot(rootDirHandle);
        await loadAppSettings();
        applySettings();
        await loadAndInitTabs();
        // ensure grid state reflects current sidebar state
        updateModuleDraggable();
        updateGridDraggable();
        await runUpdateCheck();
      } catch (e) {
        console.warn(e);
        alert('Ordnerauswahl abgebrochen oder nicht erlaubt.');
      }
    } else {
      const inp = document.getElementById('folder-input');
      inp.onchange = async e => {
        const files = Array.from(e.target.files);
        if (!files.length) return;
        window.rootDirHandle = null;                // not reusable
        await idbDel(FS_HANDLE_KEY);                // forget saved handle
        localStorage.removeItem('rememberRootMeta');
        const any = files[0];
        const parts = any.webkitRelativePath.split('/');
        const rootName = parts[0];
        rootBtn.textContent = rootName;
        rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
        rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
        pendingRootPermission = false;
        rootBtn.title = '';
        try { localStorage.setItem(ROOT_HANDLE_NAME_KEY, rootName); } catch (e) {
          console.warn('Konnte Arbeitsordnernamen nicht speichern', e);
        }
        await loadModulesFromFileList(files, rootName);
        await loadAndInitTabs();
        inp.value = null;
        updateModuleDraggable();
        updateGridDraggable();
        pendingUpdates = [];
        renderUpdateList();
      };
      inp.click();
    }
  });

  if (selectUpdateFolderBtn) {
    selectUpdateFolderBtn.addEventListener('click', async () => {
      if (!('showDirectoryPicker' in window)) {
        alert('Update-Ordner können nur mit einem kompatiblen Browser gewählt werden.');
        return;
      }
      if (pendingUpdatePermission && updateDirHandle) {
        try {
          const granted = await ensureRWPermission(updateDirHandle, { mode: 'read' });
          if (granted) {
            pendingUpdatePermission = false;
            if (updateFolderNameEl) updateFolderNameEl.textContent = updateDirHandle.name;
            await runUpdateCheck();
            return;
          }
        } catch (err) {
          console.warn('Erneute Berechtigungsabfrage für Update-Ordner fehlgeschlagen', err);
        }
      }
      try {
        const handle = await window.showDirectoryPicker();
        const granted = await ensureRWPermission(handle, { mode: 'read' });
        if (!granted) {
          alert('Der Zugriff auf den Update-Ordner wurde nicht erlaubt.');
          return;
        }
        updateDirHandle = handle;
        if (updateFolderNameEl) updateFolderNameEl.textContent = handle.name;
        try { localStorage.setItem(UPDATE_HANDLE_NAME_KEY, handle.name); } catch (e) {
          console.warn('Konnte Update-Ordnernamen nicht speichern', e);
        }
        await idbSet(UPDATE_HANDLE_KEY, handle);
        pendingUpdatePermission = false;
        await runUpdateCheck();
      } catch (e) {
        if (e?.name !== 'AbortError') {
          console.warn('Update-Ordner Auswahl fehlgeschlagen', e);
          alert('Der Update-Ordner konnte nicht gewählt werden.');
        }
      }
    });
  }

  if (clearUpdateFolderBtn) {
    clearUpdateFolderBtn.addEventListener('click', async () => {
      updateDirHandle = null;
      if (updateFolderNameEl) updateFolderNameEl.textContent = 'Keiner gewählt';
      try { localStorage.removeItem(UPDATE_HANDLE_NAME_KEY); } catch (e) {
        console.warn('Konnte Update-Ordnernamen nicht entfernen', e);
      }
      await idbDel(UPDATE_HANDLE_KEY);
      pendingUpdatePermission = false;
      pendingUpdates = [];
      versionOverview = {
        html: {
          localVersion: versionOverview.html?.localVersion || null,
          updateVersion: null,
          localFileName: versionOverview.html?.localFileName || HTML_FILE_NAME,
          updateFileName: null
        },
        modules: versionOverview.modules.map(mod => ({ ...mod, updateVersion: null }))
      };
      renderUpdateList();
      await runUpdateCheck();
    });
  }

  if (updateStatusBtn) {
    updateStatusBtn.addEventListener('click', () => {
      if (updateStatusBtn.disabled) return;
      openSettings('updates');
    });
  }

  if (updateAllBtn) {
    updateAllBtn.addEventListener('click', async () => {
      if (updateAllBtn.disabled || !pendingUpdates.length) return;

      const itemsToUpdate = pendingUpdates.slice();
      const originalText = updateAllBtn.textContent;
      updateAllBtn.disabled = true;
      updateAllBtn.classList.add('opacity-60','cursor-wait','cursor-not-allowed');
      updateAllBtn.textContent = 'Aktualisiere…';

      if (updatesTableBody) {
        updatesTableBody.querySelectorAll('button').forEach(btn => {
          btn.disabled = true;
          btn.classList.add('opacity-60','cursor-not-allowed');
        });
      }

      let encounteredError = false;
      try {
        for (const item of itemsToUpdate) {
          try {
            await applySingleUpdate(item, { skipRecheck: true });
          } catch (err) {
            encounteredError = true;
            console.error('Fehler beim Aktualisieren', err);
          }
        }
      } catch (err) {
        encounteredError = true;
        console.error('Fehler beim Aktualisieren', err);
      } finally {
        try {
          await runUpdateCheck();
        } catch (err) {
          encounteredError = true;
          console.error('Fehler beim Aktualisieren', err);
        }
        updateAllBtn.disabled = false;
        updateAllBtn.classList.remove('opacity-60','cursor-wait','cursor-not-allowed');
        updateAllBtn.textContent = originalText;
        if (encounteredError) {
          alert('Beim Aktualisieren ist ein Fehler aufgetreten.');
        }
      }
    });
  }

  // Add new tab
  addTabBtn.addEventListener('click', () => {
    const name = prompt('Name für neuen Tab:', 'Neuer Tab');
    if (!name) return;
    createTab(name);
    renderTabs();
    activateTab(tabs.length - 1);
    updateModuleDraggable();
    updateGridDraggable();
    saveLayout();
  });

  // Settings open
  settingsBtn.addEventListener('click', () => {
    openSettings('general');
  });
  // Settings cancel
  closeSettingsBtn.addEventListener('click', () => {
    settingsModal.classList.add('hidden');
    if (typeof originalSettings !== 'undefined' && originalSettings !== null) {
      appSettings = { ...originalSettings };
      applySettings();
      renderTabs();
    }
    originalSettings = null;
  });
  // Settings save
  saveSettingsBtn.addEventListener('click', async () => {
    readInputsIntoSettings();
    applySettings();
    await saveAppSettings();
    settingsModal.classList.add('hidden');
    renderTabs();
    originalSettings = null;
  });
  // Settings nav
  settingsNavButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      activateSettingsSection(btn.dataset.section);
    });
  });
  // Live preview for colours
  [inputAppBg,inputBorderColor,inputButtonBg,inputButtonText,inputTopBarBg,inputTabActiveBg,inputTabActiveText,inputTabInactiveBg,inputTabInactiveText,inputSidebarBg,inputSidebarText,inputGridHint,inputModuleBg,inputTextColor,inputModuleHeaderBg,inputModuleHeaderText,inputDangerBg,inputDangerText,inputModuleBorderColor,inputSidebarModuleBg,inputSidebarModuleText,inputSidebarModuleBorder].forEach(inp => {
    inp.addEventListener('input', () => {
      readInputsIntoSettings();
      applySettings();
      renderTabs();
    });
  });
  if (inputShowUpdateButton) {
    inputShowUpdateButton.addEventListener('change', () => {
      appSettings.showUpdateStatusButton = inputShowUpdateButton.checked;
      setUpdateStatusButton();
    });
  }
  if (inputAutoArrange) {
    inputAutoArrange.addEventListener('change', () => {
      readInputsIntoSettings();
      applySettings();
    });
  }
  inputBorderRadius.addEventListener('input', () => {
    appSettings.moduleBorderRadius = ((parseFloat(inputBorderRadius.value)||0)/16) + 'rem';
    applySettings();
  });

  /* First tab on initial load */
  createTab('Standard');
  renderTabs();
  activateTab(0, { skipSave: true });
  updateModuleDraggable();
  updateGridDraggable();
  updateGridAutoArrange();

  // --- Try to restore AFTER wiring handlers ---
  const restoredRoot = await tryRestoreRootHandle();
  await tryRestoreUpdateHandle();
  if (restoredRoot) {
    updateModuleDraggable();
    updateGridDraggable();
  }
  await runUpdateCheck();
});

/** Populate inputs from appSettings */
function populateInputsFromSettings() {
  inputAppBg.value = toColor(appSettings.appBgColor, inputAppBg.value);
  inputBorderColor.value = toColor(appSettings.borderColor, inputBorderColor.value);
  inputButtonBg.value = toColor(appSettings.buttonBg, inputButtonBg.value);
  inputButtonText.value = toColor(appSettings.buttonText, inputButtonText.value);
  inputTopBarBg.value = toColor(appSettings.topBarBg, inputTopBarBg.value);
  inputTabActiveBg.value = toColor(appSettings.tabActiveBg, inputTabActiveBg.value);
  inputTabActiveText.value = toColor(appSettings.tabActiveText, inputTabActiveText.value);
  inputTabInactiveBg.value = toColor(appSettings.tabInactiveBg, inputTabInactiveBg.value);
  inputTabInactiveText.value = toColor(appSettings.tabInactiveText, inputTabInactiveText.value);
  inputSidebarBg.value = toColor(appSettings.sidebarBg, inputSidebarBg.value);
  inputSidebarText.value = toColor(appSettings.sidebarText, inputSidebarText.value);
  inputGridHint.value = toColor(appSettings.gridHint, inputGridHint.value);
  if (inputAutoArrange) inputAutoArrange.checked = !!appSettings.autoArrangeModules;
  inputModuleBg.value = toColor(appSettings.moduleBgColor, inputModuleBg.value);
  inputTextColor.value = toColor(appSettings.textColor, inputTextColor.value);
  inputBorderRadius.value = Math.round(parseFloat(appSettings.moduleBorderRadius) * 16 || 0);
  inputModuleHeaderBg.value = toColor(appSettings.moduleHeaderBg, inputModuleHeaderBg.value);
  inputModuleHeaderText.value = toColor(appSettings.moduleHeaderText, inputModuleHeaderText.value);
  inputDangerBg.value = toColor(appSettings.dangerBg, inputDangerBg.value);
  inputDangerText.value = toColor(appSettings.dangerText, inputDangerText.value);

  // New module border and sidebar module card settings
  if (inputModuleBorderColor) inputModuleBorderColor.value = toColor(appSettings.moduleBorderColor, inputModuleBorderColor.value);
  if (inputSidebarModuleBg) inputSidebarModuleBg.value = toColor(appSettings.sidebarModuleCardBg, inputSidebarModuleBg.value);
  if (inputSidebarModuleText) inputSidebarModuleText.value = toColor(appSettings.sidebarModuleCardText, inputSidebarModuleText.value);
  if (inputSidebarModuleBorder) inputSidebarModuleBorder.value = toColor(appSettings.sidebarModuleCardBorder, inputSidebarModuleBorder.value);
  if (inputShowUpdateButton) inputShowUpdateButton.checked = appSettings.showUpdateStatusButton !== false;
}

/** Read inputs into appSettings */
function readInputsIntoSettings() {
  appSettings.appBgColor = inputAppBg.value;
  appSettings.borderColor = inputBorderColor.value;
  appSettings.buttonBg = inputButtonBg.value;
  appSettings.buttonText = inputButtonText.value;
  appSettings.topBarBg = inputTopBarBg.value;
  appSettings.tabActiveBg = inputTabActiveBg.value;
  appSettings.tabActiveText = inputTabActiveText.value;
  appSettings.tabInactiveBg = inputTabInactiveBg.value;
  appSettings.tabInactiveText = inputTabInactiveText.value;
  appSettings.sidebarBg = inputSidebarBg.value;
  appSettings.sidebarText = inputSidebarText.value;
  appSettings.gridHint = inputGridHint.value;
  if (inputAutoArrange) appSettings.autoArrangeModules = inputAutoArrange.checked;
  appSettings.moduleBgColor = inputModuleBg.value;
  appSettings.textColor = inputTextColor.value;
  appSettings.moduleBorderRadius = ((parseFloat(inputBorderRadius.value)||0)/16) + 'rem';
  appSettings.moduleHeaderBg = inputModuleHeaderBg.value;
  appSettings.moduleHeaderText = inputModuleHeaderText.value;
  appSettings.dangerBg = inputDangerBg.value;
  appSettings.dangerText = inputDangerText.value;

  // New module border and sidebar module card settings
  appSettings.moduleBorderColor = inputModuleBorderColor.value;
  appSettings.sidebarModuleCardBg = inputSidebarModuleBg.value;
  appSettings.sidebarModuleCardText = inputSidebarModuleText.value;
  appSettings.sidebarModuleCardBorder = inputSidebarModuleBorder.value;
  if (inputShowUpdateButton) appSettings.showUpdateStatusButton = inputShowUpdateButton.checked;
}

/** Convert rgba to hex for colour inputs */
function toColor(val, fallback) {
  if (!val) return fallback;
  if (/^#/.test(val)) return val;
  const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
  if (m) {
    const r = Number(m[1]).toString(16).padStart(2,'0');
    const g = Number(m[2]).toString(16).padStart(2,'0');
    const b = Number(m[3]).toString(16).padStart(2,'0');
    return '#' + r + g + b;
  }
  return fallback;
}

/** Apply CSS variables from appSettings */
function applySettings() {
  document.documentElement.style.setProperty('--app-bg', appSettings.appBgColor);
  document.documentElement.style.setProperty('--sidebar-bg', appSettings.sidebarBg);
  document.documentElement.style.setProperty('--sidebar-text', appSettings.sidebarText);
  document.documentElement.style.setProperty('--top-bar-bg', appSettings.topBarBg);
  document.documentElement.style.setProperty('--button-bg', appSettings.buttonBg);
  document.documentElement.style.setProperty('--button-text', appSettings.buttonText);
  document.documentElement.style.setProperty('--border-color', appSettings.borderColor);
  document.documentElement.style.setProperty('--module-bg', appSettings.moduleBgColor);
  document.documentElement.style.setProperty('--text-color', appSettings.textColor);
  document.documentElement.style.setProperty('--module-border-radius', appSettings.moduleBorderRadius);
  document.documentElement.style.setProperty('--module-header-bg', appSettings.moduleHeaderBg);
  document.documentElement.style.setProperty('--module-header-text', appSettings.moduleHeaderText);
  document.documentElement.style.setProperty('--danger-bg', appSettings.dangerBg);
  document.documentElement.style.setProperty('--danger-text', appSettings.dangerText);
  document.documentElement.style.setProperty('--tab-active-bg', appSettings.tabActiveBg);
  document.documentElement.style.setProperty('--tab-active-text', appSettings.tabActiveText);
  document.documentElement.style.setProperty('--tab-inactive-bg', appSettings.tabInactiveBg);
  document.documentElement.style.setProperty('--tab-inactive-text', appSettings.tabInactiveText);
  document.documentElement.style.setProperty('--grid-hint', appSettings.gridHint);

  // Apply module border and sidebar module card colours
  document.documentElement.style.setProperty('--module-border-color', appSettings.moduleBorderColor);
  document.documentElement.style.setProperty('--sidebar-module-card-bg', appSettings.sidebarModuleCardBg);
  document.documentElement.style.setProperty('--sidebar-module-card-text', appSettings.sidebarModuleCardText);
  document.documentElement.style.setProperty('--sidebar-module-card-border', appSettings.sidebarModuleCardBorder);

  updateGridAutoArrange();
  setUpdateStatusButton();
}

/** Save settings to storage */
async function saveAppSettings() {
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(settingsFileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(appSettings));
      await writable.close();
    } catch (e) { console.warn('Konnte Einstellungsdatei nicht speichern', e); }
  } else {
    try {
      localStorage.setItem('appSettings', JSON.stringify(appSettings));
    } catch (e) { console.warn('Konnte Einstellungen nicht im localStorage speichern', e); }
  }
}

function applyLoadedSettings(loadedSettings) {
  if (!loadedSettings || typeof loadedSettings !== 'object') return;
  const { gridFloat, autoArrangeModules, ...rest } = loadedSettings;
  appSettings = { ...appSettings, ...rest };
  if (typeof autoArrangeModules === 'boolean') {
    appSettings.autoArrangeModules = autoArrangeModules;
  } else if (typeof gridFloat === 'boolean') {
    appSettings.autoArrangeModules = !gridFloat;
  }
}

/** Load settings from storage */
async function loadAppSettings() {
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(settingsFileName, { create: false });
      const file = await fileHandle.getFile();
      const text = await file.text();
      const loaded = JSON.parse(text);
      applyLoadedSettings(loaded);
    } catch (e) {}
  } else {
    try {
      const ls = localStorage.getItem('appSettings');
      if (ls) applyLoadedSettings(JSON.parse(ls));
    } catch (e) {}
  }
  applySettings();
}

/** Update card draggability */
function updateModuleDraggable() {
  listEl.querySelectorAll('.module-card[data-subdir]').forEach(card => {
    card.draggable = isSidebarOpen;
    card.style.webkitUserDrag = isSidebarOpen ? 'element' : 'none';
    card.style.cursor = isSidebarOpen ? 'grab' : 'default';
  });
}
function updateGridDraggable() {
  tabs.forEach(tab => {
    if (tab.grid) {
      // grid-wide static mode reflects sidebar state
      tab.grid.setStatic(!isSidebarOpen);
      tab.grid.engine.nodes.forEach(node => {
        tab.grid.movable(node.el, isSidebarOpen);
        tab.grid.resizable(node.el, isSidebarOpen);
        const dragHandle = node.el.querySelector('.drag-handle');
        if (dragHandle) dragHandle.style.cursor = isSidebarOpen ? 'move' : 'default';
        const delBtn = node.el.querySelector('.remove');
        if (delBtn) delBtn.style.display = isSidebarOpen ? '' : 'none';
        const resizeHandles = node.el.querySelectorAll('.ui-resizable-handle');
        resizeHandles.forEach(handle => {
          handle.style.display = isSidebarOpen ? '' : 'none';
          if (!isSidebarOpen) handle.style.cursor = 'default';
        });
      });
    }
  });
}

function updateGridAutoArrange() {
  const autoArrange = !!appSettings.autoArrangeModules;
  const shouldFloat = !autoArrange;
  tabs.forEach(tab => {
    const grid = tab.grid;
    if (!grid) return;
    if (typeof grid.float === 'function') {
      grid.float(shouldFloat);
    } else if (typeof grid.setFloat === 'function') {
      grid.setFloat(shouldFloat);
    } else {
      grid.opts = grid.opts || {};
      grid.opts.float = shouldFloat;
      if (grid.engine && Object.prototype.hasOwnProperty.call(grid.engine, 'float')) {
        grid.engine.float = shouldFloat;
      }
    }
  });
}

/** Load modules via FS API */
async function loadModulesFromRoot(rootHandle) {
  try {
    modulesDirHandle = await rootHandle.getDirectoryHandle('modules', { create: false });
  } catch {
    liveModuleTemplates = [];
    renderSidebar([]);
    alert('Kein "modules" Unterordner im gewählten Root gefunden.');
    return;
  }
  const { tree, modules } = await buildTreeFromHandle(modulesDirHandle);
  liveModuleTemplates = modules;
  renderSidebar(tree);

  // Apply a fade-in animation to grids container when modules load
  if (gridsContainer) {
    gridsContainer.classList.add('fade-in');
    setTimeout(() => gridsContainer.classList.remove('fade-in'), 600);
  }
}

/** Fallback load modules via file list */
async function loadModulesFromFileList(files, rootName) {
  const { tree, modules } = await buildTreeFromFileList(files, rootName);
  liveModuleTemplates = modules;
  renderSidebar(tree);

  // Apply fade-in to grids container when modules load via fallback
  if (gridsContainer) {
    gridsContainer.classList.add('fade-in');
    setTimeout(() => gridsContainer.classList.remove('fade-in'), 600);
  }
}

/** Render sidebar module cards */
function renderSidebar(tree) {
  listEl.innerHTML = '';
  if (!tree.length) {
    listEl.innerHTML = '<div class="text-gray-400">Keine Module gefunden.</div>';
    return;
  }
  tree.forEach(node => renderSidebarNode(node, listEl));
  updateModuleDraggable();
}

function renderSidebarNode(node, container) {
  if (node.type === 'folder') {
    const header = document.createElement('div');
    header.className = 'module-card rounded p-3 cursor-pointer shadow transition flex items-center';
    const nameSpan = document.createElement('span');
    nameSpan.className = 'font-semibold flex-1';
    nameSpan.textContent = node.name;
    const arrow = document.createElement('span');
    arrow.textContent = '▼';
    header.appendChild(nameSpan);
    header.appendChild(arrow);
    container.appendChild(header);
    const childrenContainer = document.createElement('div');
    childrenContainer.className = 'pl-4 flex flex-col gap-2 mt-2';
    childrenContainer.style.display = 'none';
    container.appendChild(childrenContainer);
    node.children.forEach(child => renderSidebarNode(child, childrenContainer));
    header.addEventListener('click', () => {
      const open = childrenContainer.style.display !== 'none';
      childrenContainer.style.display = open ? 'none' : '';
      arrow.textContent = open ? '▼' : '▲';
    });
  } else {
    const { template, subdir, attachments } = node;
    const card = document.createElement('div');
    card.className = 'module-card rounded p-3 cursor-grab shadow transition flex flex-col';
    card.dataset.subdir = subdir;
    const header = document.createElement('div');
    header.className = 'flex items-center gap-2';
    if (template.icon) {
      const iconSpan = document.createElement('span');
      iconSpan.className = 'text-xl';
      iconSpan.textContent = template.icon;
      header.appendChild(iconSpan);
    }
    const nameSpan = document.createElement('span');
    nameSpan.className = 'font-semibold flex-1';
    nameSpan.textContent = template.name || subdir;
    header.appendChild(nameSpan);
    card.appendChild(header);
    if (attachments?.length) {
      const att = document.createElement('div');
      att.className = 'sidebar-module-attachment mt-1';
      att.textContent = '📎 ' + attachments.join(', ');
      card.appendChild(att);
    }
    card.draggable = isSidebarOpen;
    card.addEventListener('dragstart', e => {
      if (!isSidebarOpen) {
        e.preventDefault(); return;
      }
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', subdir);
      e.dataTransfer.setData('application/x-module-subdir', subdir);
      card.classList.add('dragging');
    });
    card.addEventListener('dragend', () => card.classList.remove('dragging'));
    container.appendChild(card);
  }
}

async function buildTreeFromHandle(dirHandle, basePath = '') {
  const modules = [];
  async function scan(handle, relPath) {
    let moduleJson = null;
    const attachments = [];
    let hasJson = false, hasJs = false;
    const children = [];
    for await (const entry of handle.values()) {
      if (entry.kind === 'file') {
        if (entry.name.endsWith('.json')) {
          hasJson = true;
          const f = await entry.getFile();
          try { moduleJson = JSON.parse(await f.text()); } catch {}
        } else {
          if (entry.name.endsWith('.js')) hasJs = true;
          attachments.push(entry.name);
        }
      } else if (entry.kind === 'directory') {
        const child = await scan(entry, relPath ? `${relPath}/${entry.name}` : entry.name);
        if (child) children.push(child);
      }
    }
    if (hasJson && hasJs && moduleJson) {
      const node = { type: 'module', template: moduleJson, subdir: relPath, attachments, dirHandle: handle };
      modules.push(node);
      return node;
    }
    return { type: 'folder', name: handle.name, children };
  }
  const root = await scan(dirHandle, basePath);
  return { tree: root.children || [], modules };
}

async function buildTreeFromFileList(files, rootName) {
  const root = { name: 'modules', files: [], children: {} };
  for (const f of files) {
    const rel = f.webkitRelativePath.split('/');
    if (rel.length < 3) continue;
    if (rel[0] !== rootName || rel[1] !== 'modules') continue;
    insert(root, rel.slice(2), f);
  }
  const modules = [];
  async function finalize(node, relPath) {
    const hasJson = node.files.some(f => f.name.endsWith('.json'));
    const hasJs = node.files.some(f => f.name.endsWith('.js'));
    let moduleJson = null;
    const attachments = [];
    if (hasJson && hasJs) {
      for (const f of node.files) {
        if (f.name.endsWith('.json')) { try { moduleJson = JSON.parse(await f.text()); } catch {} }
        else attachments.push(f.name);
      }
      const subdir = relPath;
      const modNode = { type: 'module', template: moduleJson, subdir, attachments, fileList: node.files };
      modules.push(modNode);
      return modNode;
    }
    const children = [];
    for (const [name, child] of Object.entries(node.children)) {
      const childNode = await finalize(child, relPath ? `${relPath}/${name}` : name);
      if (childNode) children.push(childNode);
    }
    return { type: 'folder', name: node.name, children };
  }
  function insert(node, parts, file) {
    if (parts.length === 1) {
      node.files.push(file);
    } else {
      const [folder, ...rest] = parts;
      if (!node.children[folder]) node.children[folder] = { name: folder, files: [], children: {} };
      insert(node.children[folder], rest, file);
    }
  }
  const tree = await finalize(root, '');
  return { tree: tree.children || [], modules };
}

/** Reset and recreate tabs using saved layout */
async function loadAndInitTabs() {
  const savedActive = loadActiveTabIndex();
  resetTabs();
  let saved = await loadLayout();
  let migrated = false;

  if (saved && saved.length) {
    for (const tabData of saved) {
      if (!Array.isArray(tabData.modules)) continue;
      for (const mod of tabData.modules) {
        const name = mod.subdir || mod.name;
        const exists = name && liveModuleTemplates.find(t => t.subdir === name);
        if (!exists && name) {
          const base = name.split('/').pop();
          const found = liveModuleTemplates.find(t => t.subdir.split('/').pop() === base);
          if (found) {
            mod.subdir = found.subdir;
            delete mod.name;
            migrated = true;
          }
        }
      }
    }
  }

  // Seed used IDs and counter from saved layout
  usedInstanceIds = new Set();
  nextModuleInstanceId = 1;
  if (saved && saved.length) {
    for (const t of saved) {
      for (const m of (t.modules || [])) {
        if (m.id) {
          usedInstanceIds.add(m.id);
          const num = /^mod-(\d+)$/.exec(m.id)?.[1];
          if (num) nextModuleInstanceId = Math.max(nextModuleInstanceId, Number(num) + 1);
        }
      }
    }
  }

  if (saved && saved.length) {
    for (const tabData of saved) createTab(tabData.name, tabData.modules);
  } else {
    createTab('Standard');
  }
  if (tabs.length) {
    const initialIndex = (typeof savedActive === 'number' && savedActive >= 0 && savedActive < tabs.length)
      ? savedActive
      : 0;
    activateTab(initialIndex);
  }

  if (migrated) saveLayout();

  // ensure initial state reflects current sidebar state
  updateModuleDraggable();
  updateGridDraggable();
  updateGridAutoArrange();
}

/** Create a tab and grid */
function createTab(name, layoutModules = []) {
  const tabIndex = tabs.length;
  const tab = { name: name || ('Tab ' + (tabIndex + 1)), modules: [], grid: null, el: null };
  const gridEl = document.createElement('div');
  gridEl.className = 'grid-stack p-4';
  gridEl.style.minHeight = 'calc(100vh - 40px)';
  gridEl.dataset.tabIndex = tabIndex;
  gridsContainer.appendChild(gridEl);

  const gridInstance = GridStack.init({ cellHeight: 30, margin: 5, handle: '.grid-stack-item-content', column: 12, float: !appSettings.autoArrangeModules, minRow: 8 }, gridEl);

  // Reflect current sidebar state immediately (no drag/resize when closed)
  gridInstance.setStatic(!isSidebarOpen);

  tab.grid = gridInstance;
  tab.el = gridEl;
  tabs.push(tab);
  gridInstance.on('change', () => updateModulesPositions(tab));

  gridEl.addEventListener('dragover', e => {
    if (!isSidebarOpen) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
    gridEl.classList.add('grid-drop-hint');
  });
  gridEl.addEventListener('dragleave', () => gridEl.classList.remove('grid-drop-hint'));
  gridEl.addEventListener('drop', async e => {
    if (!isSidebarOpen) return;
    e.preventDefault();
    gridEl.classList.remove('grid-drop-hint');
    let subdir = e.dataTransfer.getData('application/x-module-subdir');
    if (!subdir) subdir = e.dataTransfer.getData('text/plain');
    if (!subdir) return;
    const modObj = liveModuleTemplates.find(m => m.subdir === subdir);
    if (!modObj) return;
    const rect = gridEl.getBoundingClientRect();
    const cell = gridInstance.getCellFromPixel({ left: e.clientX - rect.left, top: e.clientY - rect.top });
    const tmpl = modObj.template;
    const w = parseInt(tmpl.w) || 6;
    const h = parseInt(tmpl.h) || 3;
    const pos = { x: cell.x, y: cell.y, w, h };
    // Generate unique instance id for this drop
    const instanceId = generateInstanceId();
    if (tmpl.script) {
      const jsFileName = findScriptFileName(tmpl, modObj);
      if (!jsFileName) { alert('Kein Modul-JS gefunden für: ' + (tmpl.name || modObj.subdir)); return; }
      await loadAndRunModuleScript(jsFileName, tmpl, modObj, pos, gridInstance, tab, instanceId);
    } else if (tmpl.fields) {
      createUniversalModule(tmpl, pos, modObj, gridInstance, tab, instanceId);
    } else {
      createSimpleModule(tmpl.name || modObj.subdir, pos, gridInstance, tab, modObj.subdir, instanceId);
    }
  });

  if (layoutModules && layoutModules.length) {
    setTimeout(async () => {
      for (const m of layoutModules) {
        const modObj = liveModuleTemplates.find(t => t.subdir === m.subdir);
        const pos = { x: m.x || 0, y: m.y || 0, w: m.w || 6, h: m.h || 3 };
        // Use stored id if available; otherwise generate a new one
        const instanceId = m.id || generateInstanceId();
        if (modObj && modObj.template) {
          const tmpl = modObj.template;
          if (m.type === 'script' && tmpl.script) {
            const jsFileName = findScriptFileName(tmpl, modObj);
            if (jsFileName) await loadAndRunModuleScript(jsFileName, tmpl, modObj, pos, gridInstance, tab, instanceId);
          } else if (m.type === 'fields' && tmpl.fields) {
            createUniversalModule(tmpl, pos, modObj, gridInstance, tab, instanceId);
          } else {
            createSimpleModule(tmpl.name || modObj.subdir, pos, gridInstance, tab, modObj.subdir, instanceId);
          }
        } else {
          createSimpleModule(m.subdir, pos, gridInstance, tab, m.subdir, instanceId);
        }
      }
    }, 50);
  }
  return tab;
}

/** Render tabs */
function renderTabs() {
  if (tabsSortable) {
    tabsSortable.destroy();
    tabsSortable = null;
  }
  tabsContainer.innerHTML = '';
  tabs.forEach((tab, idx) => {
    const item = document.createElement('div');
    item.className = 'tab-item flex items-center gap-1 px-3 py-1 rounded cursor-pointer';
    if (idx === activeTabIndex) item.classList.add('tab-active'); else item.classList.add('tab-inactive','hover:opacity-90');
    item.dataset.tabIndex = idx;
    const label = document.createElement('span');
    label.className = 'truncate max-w-xs';
    label.textContent = tab.name;
    item.appendChild(label);
    item.addEventListener('click', () => activateTab(idx));
    item.addEventListener('contextmenu', e => openTabContextMenu(e, idx));
    tabsContainer.appendChild(item);
  });
  tabsSortable = Sortable.create(tabsContainer, {
    animation: 150,
    ghostClass: 'opacity-50',
    onStart: closeTabContextMenu,
    onEnd: handleTabReorder
  });
}

/** Handle tab drag-and-drop reorder */
function handleTabReorder(evt) {
  if (!evt || evt.oldIndex === undefined || evt.newIndex === undefined) return;
  const oldIndex = evt.oldIndex;
  const newIndex = evt.newIndex;
  if (oldIndex === newIndex) {
    activateTab(activeTabIndex);
    return;
  }
  const [movedTab] = tabs.splice(oldIndex, 1);
  tabs.splice(newIndex, 0, movedTab);

  if (activeTabIndex === oldIndex) {
    activeTabIndex = newIndex;
  } else if (oldIndex < activeTabIndex && activeTabIndex <= newIndex) {
    activeTabIndex -= 1;
  } else if (newIndex <= activeTabIndex && activeTabIndex < oldIndex) {
    activeTabIndex += 1;
  }

  updateGridsDomOrder();
  activateTab(activeTabIndex);
  saveLayout();
}

/** Sync grid DOM order with tab array order */
function updateGridsDomOrder() {
  tabs.forEach((tab, idx) => {
    if (tab.el && tab.el.parentNode === gridsContainer) {
      tab.el.dataset.tabIndex = idx;
      gridsContainer.appendChild(tab.el);
    }
  });
}

/** Activate a tab */
function activateTab(idx, options = {}) {
  if (idx < 0 || idx >= tabs.length) return;
  tabs.forEach((tab, i) => { if (tab.el) tab.el.style.display = (i === idx ? '' : 'none'); });
  activeTabIndex = idx;
  renderTabs();
  if (!options.skipSave) saveActiveTabIndex();
}

/** Delete tab */
function deleteTab(idx) {
  if (tabs.length <= 1) { alert('Mindestens ein Tab muss bestehen.'); return; }
  const removed = tabs.splice(idx,1)[0];
  if (removed && removed.el && removed.el.parentNode) removed.el.parentNode.removeChild(removed.el);
  if (activeTabIndex >= idx) activeTabIndex = Math.max(0, activeTabIndex - 1);
  renderTabs();
  activateTab(activeTabIndex);
  saveLayout();
}

/** Rename tab */
function renameTab(idx) {
  const newName = prompt('Neuer Name für den Tab:', tabs[idx].name);
  if (newName) {
    tabs[idx].name = newName;
    renderTabs();
    saveLayout();
  }
}

/** Open context menu for a tab */
function openTabContextMenu(e, idx) {
  e.preventDefault();
  closeTabContextMenu();
  const menu = document.createElement('div');
  menu.className = 'tab-context-menu absolute bg-white border rounded shadow z-50 text-sm';
  menu.style.left = e.pageX + 'px';
  menu.style.top = e.pageY + 'px';

  const renameItem = document.createElement('div');
  renameItem.className = 'px-3 py-1 hover:bg-gray-100 cursor-pointer';
  renameItem.textContent = 'Namen bearbeiten';
  renameItem.addEventListener('click', () => {
    closeTabContextMenu();
    renameTab(idx);
  });
  menu.appendChild(renameItem);

  const deleteItem = document.createElement('div');
  deleteItem.className = 'px-3 py-1 hover:bg-gray-100 cursor-pointer';
  deleteItem.textContent = 'Tab löschen';
  deleteItem.addEventListener('click', () => {
    closeTabContextMenu();
    if (!confirm('Tab wirklich löschen?')) return;
    deleteTab(idx);
  });
  menu.appendChild(deleteItem);

  document.body.appendChild(menu);
  tabContextMenu = menu;
}

function closeTabContextMenu() {
  if (tabContextMenu) {
    tabContextMenu.remove();
    tabContextMenu = null;
  }
}

document.addEventListener('click', () => closeTabContextMenu());

/** Remove all tabs */
function resetTabs() {
  tabs.forEach(tab => { if (tab.el && tab.el.parentNode) tab.el.parentNode.removeChild(tab.el); });
  tabs = [];
  tabsContainer.innerHTML = '';
  activeTabIndex = 0;
  clearActiveTabIndex();
}

/** Update module positions after drag/resizing */
function updateModulesPositions(tabOrIndex) {
  const tab = typeof tabOrIndex === 'number' ? tabs[tabOrIndex] : tabOrIndex;
  if (!tab || !tab.grid) return;
  tab.modules = tab.grid.engine.nodes.map(node => {
    const subdir = node.el.dataset.subdir;
    const type = node.el.dataset.modType;
    let instanceId = node.el.dataset.instanceId;
    if (!instanceId) {
      instanceId = generateInstanceId();
      node.el.dataset.instanceId = instanceId;
    } else {
      usedInstanceIds.add(instanceId);
    }
    return { id: instanceId, subdir, type, x: node.x, y: node.y, w: node.w, h: node.h };
  });
  saveLayout();
}

/** Save layout */
async function saveLayout() {
  const layoutData = { tabs: tabs.map(({name, modules}) => ({ name, modules })) };
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(layoutFileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(layoutData));
      await writable.close();
    } catch (e) { console.warn('Konnte Layout-Datei nicht speichern', e); }
  } else {
    try {
      localStorage.setItem('modulesLayout', JSON.stringify(layoutData));
    } catch (e) { console.warn('Konnte Layout nicht im localStorage speichern', e); }
  }
}

/** Load layout */
async function loadLayout() {
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(layoutFileName, { create: false });
      const file = await fileHandle.getFile();
      const text = await file.text();
      const obj = JSON.parse(text);
      if (obj && Array.isArray(obj.tabs)) return obj.tabs;
    } catch (e) {}
  }
  try {
    const ls = localStorage.getItem('modulesLayout');
    if (ls) {
      const obj = JSON.parse(ls);
      if (obj && Array.isArray(obj.tabs)) return obj.tabs;
    }
  } catch (e) {}
  return null;
}

function saveActiveTabIndex() {
  try {
    localStorage.setItem(ACTIVE_TAB_STORAGE_KEY, String(activeTabIndex));
  } catch (e) {}
}

function loadActiveTabIndex() {
  try {
    const stored = localStorage.getItem(ACTIVE_TAB_STORAGE_KEY);
    if (stored === null) return null;
    const parsed = Number.parseInt(stored, 10);
    return Number.isNaN(parsed) ? null : parsed;
  } catch (e) {
    return null;
  }
}

function clearActiveTabIndex() {
  try { localStorage.removeItem(ACTIVE_TAB_STORAGE_KEY); } catch (e) {}
}

/** Determine script filename from module JSON */
function findScriptFileName(moduleJson, modObj) {
  const base = String(moduleJson.script).replace(/^render/, '');
  const candidates = (modObj.attachments || []).filter(n => n.endsWith('.js'));
  let jsFileName = candidates.find(n => n.replace(/\.js$/, '') === base);
  if (!jsFileName) jsFileName = candidates[0];
  return jsFileName;
}

/** Load and run script module */
async function loadAndRunModuleScript(jsFileName, moduleJson, modObj, gridPos, gridInstance, tabRef, instanceIdArg) {
  let jsText = '';
  if (modObj.dirHandle) {
    const jsHandle = await modObj.dirHandle.getFileHandle(jsFileName);
    jsText = await (await jsHandle.getFile()).text();
  } else if (modObj.fileList) {
    const f = modObj.fileList.find(f => f.name === jsFileName);
    if (!f) { alert('JS-Datei nicht gefunden (Fallback).'); return; }
    jsText = await f.text();
  } else {
    alert('Keine Quelle für JS-Datei gefunden.');
    return;
  }
  try { eval(jsText); } catch (e) { console.error(e); alert('Fehler im Modul-JS.'); return; }
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  el.innerHTML = `<div class="grid-stack-item-content relative">
  <button class="remove gs-remove px-2 py-1 text-xs rounded">🗑</button>
  <div class="content"></div>
  </div>`;
  el.dataset.subdir = modObj.subdir;
  el.dataset.modType = 'script';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  const pos = gridPos || { x:0, y:0, w: moduleJson.w || 6, h: moduleJson.h || 3 };
  const widgetOptions = {
    ...pos,
    minW: moduleJson.minW || 1,
    minH: moduleJson.minH || 1
  };
  if (Number.isFinite(moduleJson.maxW)) widgetOptions.maxW = moduleJson.maxW;
  if (Number.isFinite(moduleJson.maxH)) widgetOptions.maxH = moduleJson.maxH;
  gridInstance.addWidget(el, widgetOptions);
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabRef);
    updateGridDraggable();
  };
  if (typeof window[moduleJson.script] === 'function') {
    window[moduleJson.script](el.querySelector('.content'), { moduleJson, attachments: modObj.attachments || [], subdir: modObj.subdir });
  } else {
    alert('Exportierte Funktion nicht gefunden: ' + moduleJson.script);
  }
  // Apply fade-in animation to new module content
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabRef);
  updateGridDraggable();
}

/** Create universal (fields) module */
function createUniversalModule(mod, pos, modObj, gridInstance, tabRef, instanceIdArg) {
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  const defaultW = parseInt(mod.w) || 6;
  const defaultH = parseInt(mod.h) || 3;
  const finalPos = { ...pos };
  if (!pos || typeof pos.w === 'undefined') finalPos.w = defaultW;
  if (!pos || typeof pos.h === 'undefined') finalPos.h = defaultH;
  const bg = mod.color || appSettings.moduleBgColor;
  let html = `<div class="grid-stack-item-content" style="background:${bg}">`;
  html += `<div class="drag-handle"><span class="font-semibold">${mod.name || modObj.subdir}</span><button class="remove px-2 py-1 text-xs rounded">🗑</button></div>`;
  html += `<form class="unimod-form grid grid-cols-2 gap-3">`;
  (mod.fields || []).forEach(field => {
    const colSpan = field.width === 2 ? 'col-span-2' : 'col-span-1';
    html += `<label class="${colSpan} text-sm flex flex-col gap-1"><span class="font-medium">${field.label || field.key}</span>`;
    if (field.type === 'textarea') {
      html += `<textarea name="${field.key}" class="w-full text-black p-1 rounded"></textarea>`;
    } else if (field.type === 'select') {
      html += `<select name="${field.key}" class="w-full text-black p-1 rounded">` + (field.options || []).map(o => `<option>${o}</option>`).join('') + `</select>`;
    } else {
      html += `<input type="${field.type || 'text'}" name="${field.key}" class="w-full text-black p-1 rounded" />`;
    }
    html += `</label>`;
  });
  html += `</form>`;
  if (mod.actions?.length) {
    html += `<div class="mt-2 flex flex-wrap gap-2">` + mod.actions.map((a,i) => `<button type="button" class="action-btn bg-indigo-500 hover:bg-indigo-600 text-white px-3 py-1 rounded text-sm" data-i="${i}">${a.label}</button>`).join('') + `</div>`;
  }
  html += `</div>`;
  el.innerHTML = html;
  el.dataset.subdir = modObj.subdir;
  el.dataset.modType = 'fields';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  const widgetOptions = {
    ...(finalPos || { x:0,y:0,w:defaultW,h:defaultH }),
    minW: mod.minW || 1,
    minH: mod.minH || 1,
    maxW: mod.maxW || finalPos.w,
    maxH: mod.maxH || finalPos.h
  };
  gridInstance.addWidget(el, widgetOptions);
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabRef);
    updateGridDraggable();
  };
  if (mod.actions?.length) {
    el.querySelectorAll('.action-btn').forEach(btn => {
      btn.onclick = () => {
        const i = Number(btn.dataset.i);
        const script = mod.actions[i].script;
        if (!script) return;
        runInlineScript(script, el.querySelector('form'), { modulename: mod.name || modObj.subdir });
      };
    });
  }
  // Apply fade-in animation to new universal module
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabRef);
  updateGridDraggable();
}

/** Run script for universal module */
function runInlineScript(script, formEl, context) {
  const fields = {};
  Array.from(formEl.elements).forEach(el => { if (el.name) fields[el.name] = el; });
  const helpers = {
    exportAsCSV: fields => {
      const row = Object.values(fields).map(f => (f && f.value || '')).join(';');
      const blob = new Blob([row], { type:'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (context.modulename || 'modul') + '.csv';
      a.click();
    }
  };
  const fn = new Function('fields','context',...Object.keys(helpers), script);
  try { fn(fields, context, ...Object.values(helpers)); } catch (e) { console.error(e); alert('Script-Fehler.'); }
}

/** Create simple module */
function createSimpleModule(title, pos, gridInstance, tabRef, subdir, instanceIdArg) {
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  const w = (pos && pos.w) || 4;
  const h = (pos && pos.h) || 2;
  el.innerHTML = `<div class="grid-stack-item-content relative">
  <button class="remove gs-remove px-2 py-1 text-xs rounded">🗑</button>
  <div class="text-sm opacity-80">Kein Script/Fields definiert.</div>
  </div>`;
  el.dataset.subdir = subdir || title;
  el.dataset.modType = 'simple';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  gridInstance.addWidget(el, pos || { x:0, y:0, w, h });
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabRef);
    updateGridDraggable();
  };
  // Apply fade-in animation to new simple module
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabRef);
  updateGridDraggable();
}
  </script>
</body>
</html>
