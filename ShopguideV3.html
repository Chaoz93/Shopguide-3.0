<!-- Version: 3.6.11 -->
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Shopguide V3</title>
  <meta id="viewport-meta" name="viewport" content="initial-scale=1.0" />
  <script>
    (function(meta){ if(!meta) return; var parts=['de','vice-width']; meta.setAttribute('content','width='+parts.join('')+', initial-scale=1.0'); })(document.getElementById('viewport-meta'));
  </script>
  <!-- Tailwind for easy styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- GridStack styles and scripts -->
  <link href="https://cdn.jsdelivr.net/npm/gridstack@9.2.2/dist/gridstack.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/gridstack@9.2.2/dist/gridstack-all.js"></script>
  <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
  <script src="https://code.jquery.com/ui/1.14.1/jquery-ui.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>

  <link rel="stylesheet" href="https://code.jquery.com/ui/1.14.1/themes/base/jquery-ui.css">
  <style>
    :root {
      /* General colours */
      --app-bg: #f3f4f6;
      --sidebar-bg: #f3f4f6;
      --sidebar-text: #1f2937;
      --top-bar-bg: #ffffff;
      --button-bg: #2563eb;
      --button-text: #ffffff;
      --border-color: #e5e7eb;
      /* Module colours */
      --module-bg: #005983;
      --text-color: #ffffff;
      --module-border-radius: 1.25rem;
      --module-header-bg: rgba(255,255,255,0.08);
      --module-header-text: #ffffff;
      /* Module border */
      --module-border-color: #e5e7eb;
      --danger-bg: #ef4444;
      --danger-text: #ffffff;
      /* Scrollbar styling */
      --scrollbar-thumb: rgba(15,23,42,0.35);
      --scrollbar-thumb-hover: rgba(15,23,42,0.55);
      --scrollbar-track: transparent;
      --scrollbar-thumb-inverse: rgba(255,255,255,0.5);
      --scrollbar-thumb-inverse-hover: rgba(255,255,255,0.7);
      /* Tabs colours */
      --tab-active-bg: #2563eb;
      --tab-active-text: #ffffff;
      --tab-inactive-bg: #e5e7eb;
      --tab-inactive-text: #1f2937;
      /* Grid hint */
      --grid-hint: #60a5fa;

      /* Sidebar module card colours */
      --sidebar-module-card-bg: #ffffff;
      --sidebar-module-card-text: #1f2937;
      --sidebar-module-card-border: #e5e7eb;

      /* Attachment text colour for module cards */
      --sidebar-module-card-attachment-color: #6B7280;

      /* Body text colour (used for general text; separate from sidebar text) */
      --body-text: #1f2937;
    }

    html, body { height: 100%; }
    body { margin: 0; background: var(--app-bg); color: var(--body-text); }
    /* Global modern scrollbar styling */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
    }
    *::-webkit-scrollbar {
      width: 0.55rem;
      height: 0.55rem;
    }
    *::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
    }
    *::-webkit-scrollbar-thumb {
      background-color: var(--scrollbar-thumb);
      border-radius: 9999px;
      border: 2px solid transparent;
      background-clip: padding-box;
    }
    *::-webkit-scrollbar-thumb:hover {
      background-color: var(--scrollbar-thumb-hover);
    }
    /* module contents */
    .grid-stack-item-content {
      background: var(--module-bg);
      border-radius: var(--module-border-radius);
      color: var(--text-color);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      min-height: 10px;
      /* apply border using module border colour */
      border: 1px solid var(--module-border-color);
      overflow: auto;
      scrollbar-color: var(--scrollbar-thumb-inverse) transparent;
    }
    .grid-stack-item-content::-webkit-scrollbar-thumb {
      background-color: var(--scrollbar-thumb-inverse);
    }
    .grid-stack-item-content::-webkit-scrollbar-thumb:hover {
      background-color: var(--scrollbar-thumb-inverse-hover);
    }
    .drag-handle {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:.5rem;
      cursor: move;
      background: var(--module-header-bg);
      color: var(--module-header-text);
      border-radius: calc(var(--module-border-radius) - 0.25rem);
      padding: .25rem .5rem;
    }
    .module-card.dragging { opacity: 0.5; }
    .grid-drop-hint { outline: 2px dashed var(--grid-hint); outline-offset: -6px; }
    .module-card {
      -webkit-user-drag: element;
      user-select: none;
      /* use CSS variables for sidebar module appearance */
      background-color: var(--sidebar-module-card-bg);
      color: var(--sidebar-module-card-text);
      border: 1px solid var(--sidebar-module-card-border);
    }
    /* Sidebar collapsed state */
    #sidebar.collapsed { width: 2.5rem !important; min-width: 2.5rem !important; padding-left: 0; padding-right: 0; }
    #sidebar.collapsed .list-content { display: none; }
    #sidebar.collapsed .collapse-icon { transform: rotate(180deg); }
    #sidebar.collapsed .module-card { pointer-events: none; }
    #sidebar.collapsed #module-list { pointer-events: none; }
    #module-search {
      background-color: var(--sidebar-module-card-bg);
      color: var(--sidebar-module-card-text);
    }
    #save-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }
    /* Topbar, sidebar and buttons use variables */
    #top-bar { background-color: var(--top-bar-bg) !important; border-bottom: 1px solid var(--border-color) !important; }
    #sidebar { background-color: var(--sidebar-bg) !important; border-right: 1px solid var(--border-color) !important; color: var(--sidebar-text); overflow-y: auto; }
    #select-root { background-color: var(--button-bg) !important; color: var(--button-text) !important; }
    button.remove { background-color: var(--danger-bg) !important; color: var(--danger-text) !important; }
    /* Tabs */
    .tab-item { user-select: none; }
    .tab-active { background: var(--tab-active-bg); color: var(--tab-active-text); }
    .tab-inactive { background: var(--tab-inactive-bg); color: var(--tab-inactive-text); }
    /* Settings Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 50;
    }
    .modal {
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-radius: 0.75rem;
      padding: 1.5rem;
      width: min(98vw, 1500px);
      max-width: none;
      max-height: 90vh;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      color: var(--body-text);
    }
    .settings-content {
      overflow-y: auto;
      flex: 1;
    }
    .profile-manager {
      margin-top: 1.5rem;
      padding: 1rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border-color);
      background: rgba(255,255,255,0.6);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .profile-manager-title {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      color: var(--body-text);
    }
    .profile-manager-hint {
      margin: 0;
      font-size: 0.85rem;
      color: #4b5563;
    }
    .profile-manager-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }
    .profile-manager-controls select,
    .profile-manager-controls input[type="text"] {
      flex: 1 1 180px;
      min-width: 160px;
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border-color);
      background: var(--sidebar-module-card-bg);
      color: var(--body-text);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .profile-manager-controls select:focus,
    .profile-manager-controls input[type="text"]:focus {
      outline: none;
      border-color: var(--button-bg);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.25);
    }
    .profile-manager-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .profile-manager-buttons .profile-btn {
      flex: 1 1 140px;
      min-width: 140px;
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid transparent;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .profile-manager-buttons .profile-save {
      background: var(--button-bg);
      color: var(--button-text);
    }
    .profile-manager-buttons .profile-load {
      background: var(--sidebar-module-card-bg);
      color: var(--body-text);
      border-color: var(--border-color);
    }
    .profile-manager-buttons .profile-delete {
      background: var(--danger-bg);
      color: var(--danger-text);
    }
    .profile-manager-buttons .profile-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .updates-table-container {
      max-height: 50vh;
      overflow-y: auto;
    }
    .update-settings-row {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 0.75rem 1.25rem;
    }
    .update-settings-row .update-folder-info {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem 0.75rem;
      flex: 1 1 320px;
    }
    .update-controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem 1.25rem;
      flex: 1 1 320px;
    }
    .update-toggle {
      position: relative;
      display: inline-flex;
      align-items: center;
      cursor: pointer;
    }
    .update-toggle input {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      white-space: nowrap;
      border: 0;
    }
    .update-toggle-track {
      width: 2.75rem;
      height: 1.5rem;
      background-color: #d1d5db;
      border-radius: 9999px;
      transition: background-color 0.2s ease;
    }
    .update-toggle-thumb {
      position: absolute;
      left: 0.25rem;
      top: 0.25rem;
      width: 1rem;
      height: 1rem;
      border-radius: 9999px;
      background-color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      transition: transform 0.2s ease;
    }
    .update-toggle-stack {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem 1.25rem;
      flex: 1 1 auto;
      min-width: 260px;
    }
    .update-toggle-group {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    .update-toggle-label {
      font-weight: 500;
      color: #374151;
    }
    .update-all-container {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      flex: 0 0 auto;
      margin-left: auto;
    }
    .update-all-container.hidden {
      display: none;
    }
    .update-toggle input:checked + .update-toggle-track {
      background-color: #2563eb;
    }
    .update-toggle input:checked + .update-toggle-track + .update-toggle-thumb {
      transform: translateX(1.25rem);
    }
    .version-overview-grid {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 5rem 5rem 8rem;
      column-gap: 1.5rem;
      row-gap: 0.5rem;
      align-items: center;
    }
    .version-overview-header {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
    }
    .version-overview-name {
      font-weight: 500;
      color: #374151;
    }
    .version-overview-value {
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: #4b5563;
    }
    .version-overview-action {
      display: flex;
      justify-content: flex-end;
      align-items: center;
    }
    .version-overview-action .version-overview-button {
      background-color: #ffffff;
      border: 1px solid #d1d5db;
      color: #374151;
      font-size: 0.75rem;
      padding: 0.25rem 0.75rem;
      border-radius: 0.375rem;
      transition: background-color 0.2s ease;
    }
    .version-overview-action .version-overview-button:hover {
      background-color: #f3f4f6;
    }
    .version-overview-empty {
      grid-column: 1 / -1;
      color: #6b7280;
      font-style: italic;
    }
    .settings-nav button {
      border-radius: .5rem;
      padding: .5rem .75rem;
    }
    .settings-nav button.active { background: #e5e7eb; }
    .settings-section { display: none; }
    .settings-section.active { display: block; }
    .field-grid {
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: .75rem;
    }
    @media (max-width: 640px){ .field-grid { grid-template-columns: 1fr; } }
    .form-field label { font-size:.875rem; font-weight:600; }

    .hsla-native-input { display: none !important; }

    .hsla-picker {
      position: relative;
      width: 100%;
      --hsla-color: hsla(210, 20%, 50%, 1);
    }
    .hsla-picker-trigger {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.55rem 0.85rem;
      border-radius: 0.85rem;
      border: 1px solid rgba(15,23,42,0.08);
      background: linear-gradient(135deg, rgba(248,250,252,0.9), rgba(241,245,249,0.9));
      transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
      cursor: pointer;
    }
    .hsla-picker-trigger:hover,
    .hsla-picker.open .hsla-picker-trigger {
      border-color: rgba(37,99,235,0.45);
      box-shadow: 0 8px 24px rgba(15,23,42,0.12);
    }
    .hsla-picker-trigger:focus-visible {
      outline: 2px solid rgba(37,99,235,0.8);
      outline-offset: 2px;
    }
    .hsla-chip {
      position: relative;
      width: 2rem;
      height: 2rem;
      border-radius: 0.9rem;
      flex-shrink: 0;
      background-color: #f8fafc;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.45), 0 4px 12px rgba(15,23,42,0.22);
    }
    .hsla-chip::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background-image:
        linear-gradient(45deg, #e2e8f0 25%, transparent 25%, transparent 75%, #e2e8f0 75%),
        linear-gradient(45deg, transparent 25%, #e2e8f0 25%, #e2e8f0 75%, transparent 75%);
      background-size: 6px 6px;
      background-position: 0 0, 3px 3px;
    }
    .hsla-chip::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: var(--hsla-color);
    }
    .hsla-summary {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.2rem;
      text-align: left;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    .hsla-summary-label {
      font-size: 0.65rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      color: #64748b;
    }
    .hsla-value {
      font-size: 0.82rem;
      font-family: 'JetBrains Mono', 'Fira Code', 'SFMono-Regular', ui-monospace, 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      color: #0f172a;
    }
    .hsla-caret {
      display: inline-flex;
      transform: rotate(0deg);
      transition: transform 0.2s ease;
      color: #64748b;
    }
    .hsla-picker.open .hsla-caret {
      transform: rotate(180deg);
      color: #2563eb;
    }
    .hsla-popover {
      position: absolute;
      right: 0;
      top: calc(100% + 0.65rem);
      width: min(320px, 88vw);
      background: rgba(255,255,255,0.98);
      border: 1px solid rgba(15,23,42,0.1);
      border-radius: 1rem;
      box-shadow: 0 24px 45px rgba(15,23,42,0.18);
      padding: 1rem;
      display: none;
      z-index: 90;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .hsla-picker.open .hsla-popover { display: block; }
    .hsla-sliders {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .hsla-slider-row {
      display: grid;
      grid-template-columns: auto 1fr minmax(0, 4.75rem);
      align-items: center;
      gap: 0.65rem;
    }
    .hsla-slider-label {
      font-size: 0.7rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #475569;
      font-weight: 600;
    }
    .hsla-slider-value {
      font-size: 0.78rem;
      font-family: 'JetBrains Mono', 'Fira Code', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      color: #0f172a;
      min-width: 0;
      width: 100%;
      text-align: right;
      border: 1px solid rgba(15,23,42,0.12);
      border-radius: 0.45rem;
      padding: 0.3rem 0.45rem;
      background: rgba(248,250,252,0.9);
      box-shadow: inset 0 1px 1px rgba(15,23,42,0.04);
    }
    .hsla-slider-value:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(37,99,235,0.18);
      border-color: rgba(37,99,235,0.6);
    }
    .hsla-slider-value::-webkit-outer-spin-button,
    .hsla-slider-value::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .hsla-slider-value { -moz-appearance: textfield; }
    .hsla-slider-row input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 0.65rem;
      border-radius: 999px;
      background: #e2e8f0;
      border: 1px solid rgba(15,23,42,0.08);
      overflow: hidden;
      cursor: pointer;
    }
    .hsla-slider-row input[type="range"]::-webkit-slider-runnable-track {
      height: 100%;
      border-radius: inherit;
      background: inherit;
      border: none;
    }
    .hsla-slider-row input[type="range"]:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(37,99,235,0.22);
    }
    .hsla-slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid #2563eb;
      box-shadow: 0 2px 4px rgba(15,23,42,0.2);
      transition: transform 0.2s ease;
    }
    .hsla-slider-row input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.05);
    }
    .hsla-slider-row input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid #2563eb;
      box-shadow: 0 2px 4px rgba(15,23,42,0.2);
      transition: transform 0.2s ease;
    }
    .hsla-slider-row input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.05);
    }
    .hsla-slider-row input[type="range"]::-moz-range-track {
      height: 0.65rem;
      border-radius: 999px;
      background: inherit;
      border: none;
    }
    .hsla-slider-row input[type="range"]::-ms-track {
      height: 0.65rem;
      border-radius: 999px;
      background: transparent;
      border-color: transparent;
      color: transparent;
    }
    .hsla-slider-row input[type="range"]::-ms-fill-lower,
    .hsla-slider-row input[type="range"]::-ms-fill-upper {
      border-radius: inherit;
      background: inherit;
      border: none;
    }
    .hsla-slider-row input[type="range"]::-ms-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid #2563eb;
    }
    .hsla-slider-hue {
      background: linear-gradient(
        90deg,
        hsl(0, 100%, 50%),
        hsl(45, 100%, 50%),
        hsl(90, 100%, 50%),
        hsl(135, 100%, 50%),
        hsl(180, 100%, 50%),
        hsl(225, 100%, 50%),
        hsl(270, 100%, 50%),
        hsl(315, 100%, 50%),
        hsl(360, 100%, 50%)
      );
    }
    .hsla-slider-alpha {
      background-image:
        linear-gradient(to right, rgba(15,23,42,0), rgba(15,23,42,1)),
        linear-gradient(45deg, #e2e8f0 25%, transparent 25%, transparent 75%, #e2e8f0 75%),
        linear-gradient(45deg, transparent 25%, #e2e8f0 25%, #e2e8f0 75%, transparent 75%);
      background-size: 100% 100%, 12px 12px, 12px 12px;
      background-position: center, 0 0, 6px 6px;
      background-repeat: no-repeat, repeat, repeat;
    }
    .hsla-inline-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.25rem;
    }
    .hsla-inline-actions button {
      font-size: 0.75rem;
      padding: 0.35rem 0.65rem;
      border-radius: 0.55rem;
      border: 1px solid rgba(15,23,42,0.08);
      background: rgba(241,245,249,0.6);
      color: #1f2937;
      cursor: pointer;
    }
    .hsla-inline-actions button:hover {
      background: rgba(226,232,240,0.9);
    }

    .module-layer-manager {
      background: #f9fafb;
      border: 1px solid var(--border-color);
      border-radius: 0.75rem;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }
    .module-layer-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .module-layer-title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0;
    }
    .module-layer-subtitle {
      font-size: 0.8125rem;
      color: #4b5563;
      margin: 0.25rem 0 0;
    }
    .module-layer-add {
      background: #2563eb;
      color: #ffffff;
      border: none;
      border-radius: 0.5rem;
      padding: 0.5rem 0.9rem;
      font-weight: 600;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .module-layer-add:hover:not(:disabled) {
      background: #1d4ed8;
      transform: translateY(-1px);
    }
    .module-layer-add:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .module-color-layer {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1.35rem;
      background: #ffffff;
      border: 1px solid var(--border-color);
      border-radius: 0.75rem;
      box-shadow: 0 1px 2px rgba(15,23,42,0.08);
    }
    .layer-content {
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      align-items: start;
      gap: 1.5rem;
      width: 100%;
    }
    .module-layer-badge {
      align-self: flex-start;
      padding: 0.3rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.72rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      background: rgba(255,255,255,0.85);
      color: #1f2937;
      border: 1px solid transparent;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .layer-header {
      border-radius: 0.5rem;
      border: 1px solid transparent;
      padding: 0.75rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      background: rgba(148,163,184,0.2);
      transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .layer-header .layer-description {
      margin: 0;
      font-size: 0.85rem;
      line-height: 1.45;
      opacity: 0.9;
    }
    .layer-substack {
      display: grid;
      gap: 0.75rem;
    }
    .layer-sub {
      border-radius: 0.5rem;
      border: 1px solid transparent;
      padding: 0.85rem 1rem;
      background: rgba(148,163,184,0.12);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .layer-sub-children {
      display: grid;
      gap: 0.75rem;
      margin-top: 0.75rem;
      padding-left: 1rem;
    }
    .layer-sub-children:empty {
      display: none;
    }
    .layer-sub p {
      margin: 0;
      font-size: 0.82rem;
      line-height: 1.45;
      opacity: 0.92;
    }
    .layer-label {
      align-self: flex-start;
      padding: 0.3rem 0.8rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      border: 1px solid transparent;
      background: rgba(255,255,255,0.6);
      color: #0f172a;
      transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .layer-sample-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.6rem;
    }
    .layer-sample-grid--module {
      margin-top: 0.35rem;
    }
    .layer-sample-grid--header {
      margin-top: 0.45rem;
    }
    .layer-sample {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.55rem 0.75rem;
      border-radius: 0.55rem;
      border: 1px solid rgba(255,255,255,0.28);
      background: rgba(148,163,184,0.18);
      transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }
    .layer-sample-label {
      font-size: 0.68rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-weight: 600;
      opacity: 0.92;
    }
    .layer-sample-chip {
      width: 1.65rem;
      height: 1.65rem;
      border-radius: 0.45rem;
      border: 2px solid rgba(15,23,42,0.2);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.35);
      flex-shrink: 0;
    }
    @media (max-width: 1400px) {
      .module-color-layer {
        padding: 1.1rem;
      }
    }
    @media (max-width: 1100px) {
      .layer-content {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    @media (max-width: 900px) {
      .layer-preview {
        padding: 1.25rem;
      }
      .layer-main {
        padding: 1.1rem;
      }
    }
    @media (max-width: 720px) {
      .layer-preview {
        padding: 1rem;
      }
      .layer-main {
        padding: 1rem;
      }
      .layer-content {
        gap: 1rem;
      }
    }
    .module-layer-controls {
      min-width: 0;
      width: 100%;
      max-width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
    }
    .module-layer-name-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .module-layer-name-field label {
      font-size: 0.8125rem;
      font-weight: 600;
      color: #1f2937;
    }
    .module-layer-groups {
      display: grid;
      gap: 0.75rem;
    }
    .module-layer-group {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      padding: 0.75rem;
      border-radius: 0.75rem;
      background: #f9fafb;
      border: 1px solid var(--border-color);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
      position: relative;
    }
    .module-layer-group,
    .module-layer-subgroup {
      transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .module-layer-group-title {
      font-size: 0.8125rem;
      font-weight: 600;
      color: #111827;
    }
    .module-layer-group-description {
      margin: 0;
      font-size: 0.78rem;
      line-height: 1.45;
      color: #4b5563;
      opacity: 0.9;
    }
    .module-layer-group-grid {
      display: grid;
      gap: 0.65rem;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }
    .module-layer-main-children {
      position: relative;
      margin-top: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding: 0.75rem;
      border-radius: 0.65rem;
      background: rgba(255,255,255,0.7);
      border: 1px dashed rgba(148,163,184,0.45);
      --module-connector-color: rgba(148,163,184,0.45);
    }
    .module-layer-main-children::before {
      content: '';
      position: absolute;
      left: 1.35rem;
      top: -0.6rem;
      width: 2px;
      height: 0.6rem;
      background: var(--module-connector-color);
    }
    .module-layer-main-children-label {
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #1f2937;
      opacity: 0.8;
    }
    .module-layer-main-children-stack {
      display: grid;
      gap: 0.65rem;
    }
    .module-layer-group--nested {
      background: rgba(255,255,255,0.85);
      border-style: dashed;
      border-color: rgba(148,163,184,0.5);
      box-shadow: none;
    }
    .module-layer-subgroups {
      display: grid;
      gap: 0.65rem;
    }
    .module-layer-subtree {
      padding: 0.75rem;
      border-radius: 0.65rem;
      background: rgba(148,163,184,0.08);
      border: 1px dashed rgba(148,163,184,0.45);
      position: relative;
    }
    .module-layer-subtree::before {
      content: '';
      position: absolute;
      left: 1.2rem;
      top: -0.6rem;
      width: 2px;
      height: 0.6rem;
      background: var(--module-connector-color, rgba(148,163,184,0.45));
    }
    .module-layer-subtree-label {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #1f2937;
      opacity: 0.8;
      margin-bottom: 0.35rem;
    }
    .module-layer-subgroup {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 0.75rem;
      border-radius: 0.65rem;
      background: rgba(148,163,184,0.08);
      border: 1px solid rgba(148,163,184,0.35);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
    }
    .module-layer-subgroup-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .module-layer-subgroup-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: #1f2937;
      opacity: 0.85;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .module-layer-subgroup-description {
      margin: 0;
      font-size: 0.78rem;
      line-height: 1.5;
      color: #4b5563;
      opacity: 0.9;
    }
    .module-sub-layer-delete {
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      font-size: 0.9rem;
      line-height: 1;
      padding: 0.125rem 0.25rem;
      border-radius: 0.375rem;
      transition: color 0.15s ease, background 0.15s ease;
    }
    .module-sub-layer-delete:hover {
      color: #ef4444;
      background: rgba(255,255,255,0.08);
    }
    .module-layer-color {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: #4b5563;
    }
    .module-layer-subgroup-children {
      display: grid;
      gap: 0.6rem;
      margin-top: 0.6rem;
      padding-left: 1rem;
      border-left: 2px dashed rgba(148,163,184,0.35);
    }
    .module-layer-color input[type="color"] {
      display: none;
    }
    .module-layer-color .hsla-picker-trigger {
      border-radius: 0.65rem;
      padding: 0.45rem 0.75rem;
    }
    .module-layer-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .module-layer-actions button {
      border: 1px solid var(--border-color);
      background: #f3f4f6;
      border-radius: 0.5rem;
      padding: 0.4rem 0.85rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: #1f2937;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .module-layer-actions button:hover:not(:disabled) {
      background: #e5e7eb;
    }
    .module-layer-actions button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .module-layer-hint {
      font-size: 0.75rem;
      color: #6b7280;
    }
    @media (max-width: 768px) {
      .module-color-layer {
        padding: 1rem;
      }
    }

    /* Simple fade-in animation for startup and loading */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .fade-in {
      animation: fadeIn 0.5s ease-out;
    }

    /* Attachment text style in sidebar module cards */
    #module-list .sidebar-module-attachment {
      color: var(--sidebar-module-card-attachment-color);
      font-size: 0.75rem;
    }

    /* Ensure module names in the sidebar wrap rather than truncate */
    #module-list .module-card .font-semibold {
      word-break: break-word;
      white-space: normal;
    }
    .gs-remove {
      position: absolute;
      top: .35rem;
      right: .35rem;
    }

    .changelog-overlay {
      position: fixed;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      background: rgba(0,0,0,0.45);
      z-index: 60;
    }

    .changelog-overlay.open {
      display: flex;
    }

    .changelog-modal {
      position: relative;
      width: min(720px, 100%);
      max-height: 85vh;
      background: #ffffff;
      color: var(--body-text);
      border-radius: 0.75rem;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .changelog-header {
      padding: 1rem 1.25rem 0.75rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .changelog-controls {
      padding: 0.75rem 1.25rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      background: #f9fafb;
    }

    .changelog-controls.hidden {
      display: none;
    }

    .changelog-controls label {
      font-size: 0.85rem;
      color: #4b5563;
    }

    .changelog-select {
      flex: 1 1 220px;
      min-width: 180px;
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid #d1d5db;
      background: #ffffff;
      color: inherit;
    }

    .changelog-controls button {
      background: #2563eb;
      color: #ffffff;
      border: none;
      border-radius: 0.5rem;
      padding: 0.35rem 0.85rem;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background-color 0.15s ease;
    }

    .changelog-controls button:hover {
      background: #1d4ed8;
    }

    .changelog-controls button:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }

    .changelog-title {
      font-size: 1.15rem;
      font-weight: 600;
    }

    .changelog-subtitle {
      font-size: 0.85rem;
      color: #6b7280;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .changelog-body {
      padding: 1rem 1.25rem;
      overflow-y: auto;
    }

    .changelog-section + .changelog-section {
      margin-top: 1.5rem;
    }

    .changelog-section h3 {
      margin: 0 0 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      color: var(--body-text);
    }

    .changelog-pre {
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
      font-size: 0.875rem;
      line-height: 1.4;
      font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 0.75rem;
      color: #1f2937;
    }

    .changelog-empty {
      font-size: 0.9rem;
      color: #6b7280;
    }

    .changelog-loading {
      font-size: 0.9rem;
      color: #374151;
    }

    .changelog-error {
      color: var(--danger-bg);
      font-weight: 500;
      font-size: 0.95rem;
    }

    .changelog-close {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      border: none;
      background: transparent;
      font-size: 1.5rem;
      line-height: 1;
      color: #6b7280;
      cursor: pointer;
    }

    .changelog-close:hover {
      color: #111827;
    }
  </style>
  <style id="dynamic-layers"></style>
  <style id="custom-styles"></style>
</head>
<body>
  <!-- Top bar with tabs and buttons -->
  <header id="top-bar" class="flex items-center gap-1 px-3 py-2 shadow" style="height:40px">
    <div id="tabs-container" class="flex items-center gap-1 flex-wrap"></div>
    <button id="add-tab" title="Neuen Tab erstellen" class="text-xl px-2 py-1 leading-none hover:opacity-80">➕</button>
    <div class="ml-auto flex items-center gap-2">
      <div id="history-menu" class="relative">
        <button
          id="history-menu-toggle"
          type="button"
          class="flex items-center justify-center w-9 h-9 rounded-full border border-gray-300 bg-white text-gray-600 shadow-sm hover:text-gray-900 hover:bg-gray-100 transition focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-haspopup="true"
          aria-expanded="false"
          aria-controls="history-menu-dropdown"
          title="Verlauf"
        >
          <span class="sr-only">Verlauf öffnen</span>
          <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M12 8v4l2.5 2.5" />
            <path d="M21 12a9 9 0 11-9-9" />
            <path d="M7 3L3 7" />
            <path d="M3 7h4" />
          </svg>
        </button>
        <div
          id="history-menu-dropdown"
          class="absolute right-0 mt-2 w-48 bg-white border border-gray-200 rounded-xl shadow-lg py-2 hidden z-50"
          role="menu"
          aria-labelledby="history-menu-toggle"
        >
          <button id="undo-action" type="button" role="menuitem" class="history-menu-item flex items-center gap-2 w-full text-left text-sm px-3 py-2 text-gray-700 hover:bg-gray-100 transition" disabled>
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <path d="M9 15L3 9l6-6" />
              <path d="M3 9h12a6 6 0 010 12h-3" />
            </svg>
            <span>Rückgängig</span>
          </button>
          <button id="redo-action" type="button" role="menuitem" class="history-menu-item flex items-center gap-2 w-full text-left text-sm px-3 py-2 text-gray-700 hover:bg-gray-100 transition" disabled>
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <path d="M15 9l6 6-6 6" />
              <path d="M21 15H9a6 6 0 010-12h3" />
            </svg>
            <span>Wiederholen</span>
          </button>
        </div>
      </div>
      <button id="update-status" class="text-sm px-3 py-1 rounded hidden">Update prüfen</button>
      <button id="select-root" class="text-sm px-3 py-1 rounded">Ordner wählen</button>
      <button id="open-settings" title="Einstellungen" class="bg-gray-300 hover:bg-gray-400 text-gray-800 text-sm px-3 py-1 rounded">⚙️</button>
      <span id="save-indicator" class="bg-green-500" title="Gespeichert"></span>
    </div>
  </header>
  <div class="flex" style="height: calc(100% - 40px);">
    <aside id="sidebar" class="w-72 min-h-full p-3 relative transition-all duration-300 ease-in-out">
      <button id="sidebar-toggle" class="absolute top-2 right-2 text-xl collapse-icon" title="Liste ein-/ausblenden">⬅️</button>
      <h2 class="font-semibold mb-2 list-content">Module</h2>
      <div class="list-content mb-3">
        <div class="flex items-center gap-2">
          <input id="module-search" type="text" placeholder="Module suchen…" class="w-full text-sm border border-gray-300 rounded px-2 py-1" />
          <button id="module-search-clear" type="button" class="text-lg px-2 py-1 hidden" title="Suche löschen">❌</button>
        </div>
      </div>
      <div id="module-list" class="list-content flex flex-col gap-2 text-sm">
        <div class="text-gray-400">Wähle oben einen Ordner…</div>
      </div>
    </aside>
    <main class="flex-1 min-h-full overflow-auto">
      <div id="grids" class="relative w-full h-full"></div>
    </main>
  </div>
  <input type="file" id="folder-input" webkitdirectory directory multiple hidden />
  <!-- Settings Modal -->
  <div id="settings-modal" class="modal-overlay hidden">
    <div class="modal">
      <div class="flex items-center justify-between mb-4">
        <h2 class="text-lg font-semibold">Einstellungen</h2>
        <button
          id="close-settings"
          type="button"
          class="flex h-9 w-9 items-center justify-center rounded-full text-gray-400 transition hover:bg-gray-100 hover:text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-label="Einstellungen schließen"
        >
          <svg class="w-4 h-4" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M4 4l8 8M12 4l-8 8" />
          </svg>
        </button>
      </div>
      <div class="settings-nav flex gap-2 mb-3">
        <button data-section="general" class="active">Allgemein</button>
        <button data-section="topbar">Topbar</button>
        <button data-section="sidebar">Sidebar</button>
        <button data-section="modules">Module</button>
        <button data-section="updates">Updates</button>
      </div>
      <div class="settings-content mt-1 pr-1">
        <!-- Allgemein section -->
        <div id="section-general" class="settings-section active">
          <div class="field-grid">
            <div class="form-field">
              <label>App Hintergrundfarbe</label>
              <input type="color" id="setting-app-bg" value="#f3f4f6" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Border Farbe</label>
            <input type="color" id="setting-border-color" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Primäre Buttonfarbe</label>
            <input type="color" id="setting-button-bg" value="#2563eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Primäre Buttontextfarbe</label>
            <input type="color" id="setting-button-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field col-span-2">
            <div class="flex items-center justify-between gap-4">
              <div>
                <label for="setting-grid-auto-arrange">Automatisches Nachrücken</label>
                <p class="text-xs text-gray-500">Module rücken Lücken automatisch nach oben, wenn diese Option aktiv ist.</p>
              </div>
              <label for="setting-grid-auto-arrange" class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="setting-grid-auto-arrange" class="sr-only peer">
                <div class="w-11 h-6 bg-gray-300 rounded-full transition peer-focus:ring-2 peer-focus:ring-blue-300 peer-checked:bg-blue-600"></div>
                <span class="absolute left-1 top-1 h-4 w-4 rounded-full bg-white transition-transform peer-checked:translate-x-5"></span>
              </label>
            </div>
          </div>
        </div>
      </div>
        <div class="profile-manager">
          <h3 class="profile-manager-title">Farbprofile</h3>
          <p class="profile-manager-hint">Speichere unterschiedliche Farbschemata und lade sie bei Bedarf wieder.</p>
          <div class="profile-manager-controls">
            <select id="theme-profile-select"></select>
            <input type="text" id="theme-profile-name" placeholder="Profilname eingeben">
          </div>
          <div class="profile-manager-buttons">
            <button id="theme-profile-save" type="button" class="profile-btn profile-save">Profil speichern</button>
            <button id="theme-profile-load" type="button" class="profile-btn profile-load">Profil laden</button>
            <button id="theme-profile-delete" type="button" class="profile-btn profile-delete">Profil löschen</button>
          </div>
        </div>
        <!-- Topbar section -->
        <div id="section-topbar" class="settings-section">
          <div class="field-grid">
            <div class="form-field">
              <label>Topbar Hintergrundfarbe</label>
              <input type="color" id="setting-topbar-bg" value="#ffffff" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Aktiver Tab Hintergrund</label>
            <input type="color" id="setting-tab-active-bg" value="#2563eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Aktiver Tab Text</label>
            <input type="color" id="setting-tab-active-text" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Inaktiver Tab Hintergrund</label>
            <input type="color" id="setting-tab-inactive-bg" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Inaktiver Tab Text</label>
            <input type="color" id="setting-tab-inactive-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
        <!-- Sidebar section -->
        <div id="section-sidebar" class="settings-section">
          <div class="field-grid">
            <div class="form-field">
              <label>Sidebar Hintergrundfarbe</label>
              <input type="color" id="setting-sidebar-bg" value="#f3f4f6" class="w-full border rounded p-1">
            </div>
          <div class="form-field">
            <label>Sidebar Textfarbe</label>
            <input type="color" id="setting-sidebar-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Drag &amp; Drop Hinweisfarbe</label>
            <input type="color" id="setting-grid-hint" value="#60a5fa" class="w-full border rounded p-1">
          </div>
          <!-- New sidebar module card settings -->
          <div class="form-field">
            <label>Sidebar Modul Hintergrundfarbe</label>
            <input type="color" id="setting-sidebar-module-bg" value="#ffffff" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Sidebar Modul Textfarbe</label>
            <input type="color" id="setting-sidebar-module-text" value="#1f2937" class="w-full border rounded p-1">
          </div>
          <div class="form-field">
            <label>Sidebar Modul Rahmenfarbe</label>
            <input type="color" id="setting-sidebar-module-border" value="#e5e7eb" class="w-full border rounded p-1">
          </div>
        </div>
      </div>
        <!-- Modules section -->
        <div id="section-modules" class="settings-section">
          <div class="space-y-6">
            <div class="field-grid">
              <div class="form-field">
                <label>Modul Rundung (px)</label>
                <input type="number" id="setting-border-radius" value="20" class="w-full border rounded p-1" min="0">
              </div>
              <div class="form-field">
                <label>Löschen-Button Hintergrundfarbe</label>
                <input type="color" id="setting-danger-bg" value="#ef4444" class="w-full border rounded p-1">
              </div>
              <div class="form-field">
                <label>Löschen-Button Textfarbe</label>
                <input type="color" id="setting-danger-text" value="#ffffff" class="w-full border rounded p-1">
              </div>
            </div>
            <div class="module-layer-manager">
              <div class="module-layer-header">
                <div>
                  <h3 class="module-layer-title">Unter-Layer für Module</h3>
                  <p class="module-layer-subtitle">Definiere kombinierbare Farbsets für Modulflächen, Überschrift-Bubbles und Unterelemente.</p>
                </div>
                <button id="add-module-color-layer" type="button" class="module-layer-add">Unter-Layer hinzufügen</button>
              </div>
              <div id="module-color-layers" class="module-color-layers space-y-3"></div>
              <p class="module-layer-hint">Bis zu 8 Unter-Layer möglich. Die Farbkombinationen kannst du später in Modulen über ein Dropdown auswählen.</p>
            </div>
          </div>
        </div>
        <div id="section-updates" class="settings-section">
          <div class="space-y-4">
            <div class="text-sm space-y-2">
              <div class="update-settings-row">
                <div class="update-folder-info">
                  <span class="font-medium">Update-Ordner:</span>
                  <span id="update-folder-name" class="px-2 py-1 bg-gray-100 rounded">Keiner gewählt</span>
                  <button id="select-update-folder" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded">Ordner wählen</button>
                  <button id="clear-update-folder" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded">Zurücksetzen</button>
                  <span id="update-check-status" class="text-gray-500"></span>
                </div>
                <div class="update-controls">
                  <div class="update-toggle-stack">
                    <div class="update-toggle-group">
                      <span class="update-toggle-label text-sm text-gray-700 select-none">Update-Hinweis anzeigen</span>
                      <label class="update-toggle" title="Update-Hinweis im Hauptfenster anzeigen">
                        <span class="sr-only">Update-Hinweis im Hauptfenster anzeigen</span>
                        <input type="checkbox" id="setting-show-update-button">
                        <span class="update-toggle-track"></span>
                        <span class="update-toggle-thumb"></span>
                      </label>
                    </div>
                    <div class="update-toggle-group">
                      <span class="update-toggle-label text-sm text-gray-700 select-none">Automatisch nach Updates suchen</span>
                      <label class="update-toggle" title="Automatische Update-Prüfung alle 5 Sekunden durchführen">
                        <span class="sr-only">Automatische Update-Prüfung aktivieren</span>
                        <input type="checkbox" id="setting-update-auto-poll">
                        <span class="update-toggle-track"></span>
                        <span class="update-toggle-thumb"></span>
                      </label>
                    </div>
                    <div class="update-toggle-group">
                      <span class="update-toggle-label text-sm text-gray-700 select-none">Downgrade-Hinweis ausblenden</span>
                      <label class="update-toggle" title="Downgrade-Benachrichtigung im Hauptfenster ausblenden">
                        <span class="sr-only">Downgrade-Hinweis im Hauptfenster ausblenden</span>
                        <input type="checkbox" id="setting-hide-downgrade-button">
                        <span class="update-toggle-track"></span>
                        <span class="update-toggle-thumb"></span>
                      </label>
                    </div>
                  </div>
                  <div id="update-all-container" class="update-all-container hidden">
                    <button id="update-all" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded">Alle aktualisieren</button>
                  </div>
                </div>
              </div>
            </div>
            <div id="updates-empty-state" class="text-sm text-gray-500">Keine Updates erforderlich.</div>
            <div class="updates-table-container overflow-x-auto">
              <table class="min-w-full text-sm border border-gray-200 rounded" id="updates-table">
                <thead class="bg-gray-100">
                  <tr>
                    <th class="text-left px-3 py-2">Datei</th>
                    <th class="text-left px-3 py-2">Version</th>
                    <th class="text-right px-3 py-2">Aktion</th>
                  </tr>
                </thead>
                <tbody id="updates-table-body"></tbody>
              </table>
            </div>
            <div id="downgrade-section" class="border border-gray-200 rounded hidden">
              <button id="downgrade-toggle" type="button" class="w-full flex items-center justify-between px-3 py-2 text-sm font-semibold text-left">
                <span id="downgrade-heading">Downgrades (0)</span>
                <span id="downgrade-toggle-icon" class="text-xs">▼</span>
              </button>
              <div id="downgrade-content" class="hidden border-t border-gray-200">
                <table class="min-w-full text-sm">
                  <thead class="bg-yellow-200 text-yellow-900">
                    <tr>
                      <th class="text-left px-3 py-2">Datei</th>
                      <th class="text-left px-3 py-2">Version</th>
                      <th class="text-right px-3 py-2">Aktion</th>
                    </tr>
                  </thead>
                  <tbody id="downgrade-table-body"></tbody>
                </table>
              </div>
            </div>
            <div id="update-version-overview" class="border border-gray-200 rounded p-3 text-sm space-y-3">
              <div class="flex flex-wrap items-center justify-between gap-2">
                <div class="font-semibold text-gray-700">Versionsübersicht</div>
                <button id="show-latest-changelog" type="button" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-sm">
                  Neuester Changelog
                </button>
              </div>
              <div id="update-version-rows" class="version-overview-grid"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="changelog-modal" class="changelog-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="changelog-modal">
      <button id="close-changelog" class="changelog-close" type="button" aria-label="Changelog schließen">×</button>
      <div class="changelog-header">
        <div id="changelog-title" class="changelog-title">Changelog</div>
        <div id="changelog-subtitle" class="changelog-subtitle"></div>
      </div>
      <div id="changelog-controls" class="changelog-controls hidden">
        <label for="changelog-version-select">Version auswählen:</label>
        <select id="changelog-version-select" class="changelog-select"></select>
        <button id="changelog-show-full" type="button">Ganzen Changelog anzeigen</button>
      </div>
      <div id="changelog-body" class="changelog-body">
        <div class="changelog-loading">Lade Changelog…</div>
      </div>
    </div>
  </div>
  <script>
const COLOR_PICKER_REGISTRY = new WeakMap();
const COLOR_PICKER_INSTANCES = new Set();
let colorPickerListenersAttached = false;

// Hier werden Unter-Layer-Variablen automatisch initialisiert.
// Standardwerte können später im Color-Manager überschrieben werden.
function initGlobalLayers() {
  const root = document.documentElement;
  const styleEl = document.getElementById('dynamic-layers');
  if (!root || !styleEl) return;

  const computed = getComputedStyle(root);
  const defaults = [];

  for (let layerIndex = 1; layerIndex <= 15; layerIndex += 1) {
    const base = `--layer${layerIndex}`;
    const hueVar = `${base}-h`;
    const satVar = `${base}-s`;
    const lightVar = `${base}-l`;
    const alphaVar = `${base}-a`;

    if (!computed.getPropertyValue(hueVar).trim()) {
      defaults.push(`  ${hueVar}: 0;`);
    }
    if (!computed.getPropertyValue(satVar).trim()) {
      defaults.push(`  ${satVar}: 0%;`);
    }
    if (!computed.getPropertyValue(lightVar).trim()) {
      defaults.push(`  ${lightVar}: 100%;`);
    }
    if (!computed.getPropertyValue(alphaVar).trim()) {
      defaults.push(`  ${alphaVar}: 1;`);
    }
  }

  if (!defaults.length) return;

  const existingContent = styleEl.textContent || '';
  const separator = existingContent.trim().length ? '\n' : '';
  const newBlock = `:root {\n${defaults.join('\n')}\n}`;
  styleEl.textContent = `${existingContent}${separator}${newBlock}\n`;
}

window.addEventListener('load', initGlobalLayers, { once: true });

function clamp(value, min, max) {
  if (Number.isNaN(value)) return min;
  return Math.min(Math.max(value, min), max);
}

function normalizeHue(value) {
  if (!Number.isFinite(value)) return 0;
  const normalized = value % 360;
  return normalized < 0 ? normalized + 360 : normalized;
}

function parseRgbComponent(token) {
  if (typeof token !== 'string') return 0;
  const trimmed = token.trim();
  if (!trimmed) return 0;
  if (trimmed.endsWith('%')) {
    const percent = parseFloat(trimmed.slice(0, -1));
    if (Number.isNaN(percent)) return 0;
    return clamp(percent, 0, 100) * 255 / 100;
  }
  const value = parseFloat(trimmed);
  if (Number.isNaN(value)) return 0;
  return clamp(value, 0, 255);
}

function parseAlphaComponent(token) {
  if (typeof token !== 'string') {
    const num = Number(token);
    return clamp(Number.isNaN(num) ? 1 : num, 0, 1);
  }
  const trimmed = token.trim();
  if (!trimmed) return 1;
  if (trimmed.endsWith('%')) {
    const percent = parseFloat(trimmed.slice(0, -1));
    if (Number.isNaN(percent)) return 1;
    return clamp(percent / 100, 0, 1);
  }
  const value = parseFloat(trimmed);
  if (Number.isNaN(value)) return 1;
  return clamp(value, 0, 1);
}

function rgbaToHsla(r, g, b, a = 1) {
  const rn = clamp(r / 255, 0, 1);
  const gn = clamp(g / 255, 0, 1);
  const bn = clamp(b / 255, 0, 1);
  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  const delta = max - min;
  let h = 0;
  if (delta !== 0) {
    switch (max) {
      case rn:
        h = ((gn - bn) / delta) % 6;
        break;
      case gn:
        h = (bn - rn) / delta + 2;
        break;
      default:
        h = (rn - gn) / delta + 4;
        break;
    }
    h *= 60;
  }
  if (h < 0) h += 360;
  const l = (max + min) / 2;
  let s = 0;
  if (delta !== 0) {
    s = delta / (1 - Math.abs(2 * l - 1));
  }
  return {
    h: normalizeHue(h),
    s: clamp(s * 100, 0, 100),
    l: clamp(l * 100, 0, 100),
    a: clamp(a, 0, 1)
  };
}

function hslaToRgba({ h, s, l, a }) {
  const hue = normalizeHue(Number(h) || 0);
  const sat = clamp((Number(s) || 0) / 100, 0, 1);
  const lig = clamp((Number(l) || 0) / 100, 0, 1);
  const chroma = (1 - Math.abs(2 * lig - 1)) * sat;
  const scaledHue = hue / 60;
  const x = chroma * (1 - Math.abs((scaledHue % 2) - 1));
  let r1 = 0, g1 = 0, b1 = 0;
  if (scaledHue >= 0 && scaledHue < 1) {
    r1 = chroma; g1 = x;
  } else if (scaledHue >= 1 && scaledHue < 2) {
    r1 = x; g1 = chroma;
  } else if (scaledHue >= 2 && scaledHue < 3) {
    g1 = chroma; b1 = x;
  } else if (scaledHue >= 3 && scaledHue < 4) {
    g1 = x; b1 = chroma;
  } else if (scaledHue >= 4 && scaledHue < 5) {
    r1 = x; b1 = chroma;
  } else {
    r1 = chroma;
    b1 = x;
  }
  const m = lig - chroma / 2;
  const r = clamp(Math.round((r1 + m) * 255), 0, 255);
  const g = clamp(Math.round((g1 + m) * 255), 0, 255);
  const b = clamp(Math.round((b1 + m) * 255), 0, 255);
  return { r, g, b, a: clamp(a, 0, 1) };
}

function hexToHsla(hex) {
  const match = /^#([0-9a-f]{3,8})$/i.exec(hex.trim());
  if (!match) return null;
  let value = match[1];
  if (value.length === 3 || value.length === 4) {
    value = value.split('').map(ch => ch + ch).join('');
  }
  if (value.length === 6) {
    value += 'ff';
  }
  const intVal = parseInt(value, 16);
  const r = (intVal >> 24) & 255;
  const g = (intVal >> 16) & 255;
  const b = (intVal >> 8) & 255;
  const a = (intVal & 255) / 255;
  return rgbaToHsla(r, g, b, a);
}

function parseColor(color) {
  if (!color) return null;
  if (typeof color === 'object' && color !== null && 'h' in color) {
    return {
      h: normalizeHue(Number(color.h) || 0),
      s: clamp(Number(color.s) || 0, 0, 100),
      l: clamp(Number(color.l) || 0, 0, 100),
      a: clamp(Number(color.a ?? 1), 0, 1)
    };
  }
  if (typeof color !== 'string') return null;
  const value = color.trim();
  if (!value) return null;
  if (value.startsWith('#')) {
    return hexToHsla(value);
  }
  const rgbaMatch = /^rgba?\(([^)]+)\)$/i.exec(value);
  if (rgbaMatch) {
    const parts = rgbaMatch[1].replace(/\//g, ',').split(',').map(part => part.trim()).filter(Boolean);
    if (parts.length < 3) return null;
    const r = parseRgbComponent(parts[0]);
    const g = parseRgbComponent(parts[1]);
    const b = parseRgbComponent(parts[2]);
    const a = parts.length >= 4 ? parseAlphaComponent(parts[3]) : 1;
    return rgbaToHsla(r, g, b, a);
  }
  const hslaMatch = /^hsla?\(([^)]+)\)$/i.exec(value);
  if (hslaMatch) {
    const parts = hslaMatch[1].replace(/\//g, ',').split(',').map(part => part.trim()).filter(Boolean);
    if (parts.length < 3) return null;
    const h = normalizeHue(parseFloat(parts[0]));
    const s = clamp(parseFloat(parts[1]), 0, 100);
    const l = clamp(parseFloat(parts[2]), 0, 100);
    const a = parts.length >= 4 ? parseAlphaComponent(parts[3]) : 1;
    return { h, s, l, a };
  }
  return null;
}

function hslaToString({ h, s, l, a }) {
  const hue = Math.round(normalizeHue(h));
  const sat = Math.round(clamp(s, 0, 100));
  const lig = Math.round(clamp(l, 0, 100));
  const alpha = clamp(a, 0, 1);
  const alphaStr = (() => {
    const fixed = Math.round(alpha * 100) / 100;
    return fixed % 1 === 0 ? fixed.toFixed(0) : fixed.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
  })();
  return `hsla(${hue}, ${sat}%, ${lig}%, ${alphaStr})`;
}

function normalizeColorValue(value, fallback) {
  const parsed = parseColor(value) || parseColor(fallback);
  if (!parsed) {
    return 'hsla(210, 14%, 95%, 1)';
  }
  return hslaToString(parsed);
}

function ensureColorPickerGlobals() {
  if (colorPickerListenersAttached) return;
  document.addEventListener('click', () => closeAllColorPickers());
  document.addEventListener('keydown', event => {
    if (event.key === 'Escape') {
      closeAllColorPickers();
    }
  });
  colorPickerListenersAttached = true;
}

function closeAllColorPickers(except) {
  COLOR_PICKER_INSTANCES.forEach(instance => {
    if (instance !== except) {
      instance.close();
    }
  });
}

function upgradeColorInput(input) {
  if (!(input instanceof HTMLInputElement) || input.type !== 'color') return null;
  if (input.dataset.hslaUpgraded === '1') {
    return COLOR_PICKER_REGISTRY.get(input) || null;
  }
  ensureColorPickerGlobals();
  const picker = new HSLAColorPicker(input);
  COLOR_PICKER_REGISTRY.set(input, picker);
  COLOR_PICKER_INSTANCES.add(picker);
  input.dataset.hslaUpgraded = '1';
  return picker;
}

function initializeColorPickersIn(root = document) {
  root.querySelectorAll('input[type="color"]:not([data-hsla-upgraded="1"])').forEach(upgradeColorInput);
}

function getColorInputValue(input) {
  if (!input) return '';
  const picker = COLOR_PICKER_REGISTRY.get(input) || upgradeColorInput(input);
  if (picker) {
    return picker.getValue();
  }
  return normalizeColorValue(input.value);
}

function setColorInputValue(input, value, options = {}) {
  if (!input) return;
  const picker = COLOR_PICKER_REGISTRY.get(input) || upgradeColorInput(input);
  if (picker) {
    const provided = (typeof value === 'string' && value.trim()) || (typeof value === 'object' && value !== null)
      ? value
      : input.value;
    const { setBaseline, ...pickerOptions } = options || {};
    picker.setValue(provided, pickerOptions);
    if (setBaseline) {
      picker.initialValue = picker.getValue();
    }
  } else {
    input.value = normalizeColorValue(value, input.value);
    if (!options?.silent) {
      const eventType = options?.dispatch === 'both' ? ['input', 'change'] : [options?.dispatch];
      eventType.filter(Boolean).forEach(type => {
        input.dispatchEvent(new Event(type, { bubbles: true }));
      });
    }
  }
}

class HSLAColorPicker {
  constructor(input) {
    this.input = input;
    this.input.classList.add('hsla-native-input');
    this.input.style.display = 'none';
    this.input.setAttribute('aria-hidden', 'true');
    this.input.tabIndex = -1;
    this.value = { h: 0, s: 0, l: 100, a: 1 };
    this.cssValue = 'hsla(0, 0%, 100%, 1)';
    this.sliderValues = {};
    this.sliders = {};
    this.build();
    const initial = normalizeColorValue(this.input.value, this.cssValue);
    this.setValue(initial, { silent: true });
    this.initialValue = this.cssValue;
  }

  build() {
    this.container = document.createElement('div');
    this.container.className = 'hsla-picker';
    this.input.insertAdjacentElement('afterend', this.container);

    this.trigger = document.createElement('button');
    this.trigger.type = 'button';
    this.trigger.className = 'hsla-picker-trigger';
    this.trigger.setAttribute('aria-haspopup', 'dialog');
    this.trigger.setAttribute('aria-expanded', 'false');

    this.chip = document.createElement('span');
    this.chip.className = 'hsla-chip';

    const summary = document.createElement('span');
    summary.className = 'hsla-summary';
    const summaryLabel = document.createElement('span');
    summaryLabel.className = 'hsla-summary-label';
    summaryLabel.textContent = 'HSLA';
    this.valueEl = document.createElement('span');
    this.valueEl.className = 'hsla-value';
    summary.append(summaryLabel, this.valueEl);

    this.caret = document.createElement('span');
    this.caret.className = 'hsla-caret';
    this.caret.innerHTML = '<svg width="14" height="14" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 8l5 5 5-5" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>';

    this.trigger.append(this.chip, summary, this.caret);
    this.container.append(this.trigger);

    this.popover = document.createElement('div');
    this.popover.className = 'hsla-popover';
    this.popover.setAttribute('role', 'dialog');
    this.popover.setAttribute('aria-label', 'Farbregler');
    this.container.append(this.popover);

    const sliderWrapper = document.createElement('div');
    sliderWrapper.className = 'hsla-sliders';
    this.popover.append(sliderWrapper);

    const sliderConfigs = [
      { key: 'h', label: 'Farbton', min: 0, max: 360, step: 1, unit: '°', className: 'hsla-slider-hue' },
      { key: 's', label: 'Saturation', min: 0, max: 100, step: 1, unit: '%'},
      { key: 'l', label: 'Lightness', min: 0, max: 100, step: 1, unit: '%' },
      { key: 'a', label: 'Alpha', min: 0, max: 1, step: 0.01, unit: '' , className: 'hsla-slider-alpha'}
    ];

    sliderConfigs.forEach(config => {
      const row = document.createElement('div');
      row.className = 'hsla-slider-row';

      const label = document.createElement('span');
      label.className = 'hsla-slider-label';
      label.textContent = config.label;

      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = String(config.min);
      slider.max = String(config.max);
      slider.step = String(config.step);
      slider.dataset.channel = config.key;
      if (config.className) slider.classList.add(config.className);

      const value = document.createElement('input');
      value.type = 'number';
      value.className = 'hsla-slider-value';
      value.min = String(config.min);
      value.max = String(config.max);
      value.step = String(config.step);
      value.dataset.channel = config.key;
      value.inputMode = config.key === 'a' ? 'decimal' : 'numeric';
      value.setAttribute('aria-label', `${config.label} Wert`);
      value.title = `${config.label} (${config.min}${config.unit ?? ''} – ${config.max}${config.unit ?? ''})`;

      slider.addEventListener('input', () => {
        this.updateFromSliders('input');
      });
      slider.addEventListener('change', () => {
        this.updateFromSliders('change');
      });

      value.addEventListener('input', () => {
        this.handleNumberInput(config.key, 'input');
      });
      value.addEventListener('change', () => {
        this.handleNumberInput(config.key, 'change');
      });

      this.sliders[config.key] = slider;
      this.sliderValues[config.key] = { element: value, unit: config.unit };

      row.append(label, slider, value);
      sliderWrapper.append(row);
    });

    const actions = document.createElement('div');
    actions.className = 'hsla-inline-actions';
    this.popover.append(actions);

    const resetBtn = document.createElement('button');
    resetBtn.type = 'button';
    resetBtn.textContent = 'Zurücksetzen';
    resetBtn.addEventListener('click', () => {
      this.setValue(this.initialValue, { dispatch: 'both' });
      this.close();
    });

    const doneBtn = document.createElement('button');
    doneBtn.type = 'button';
    doneBtn.textContent = 'Fertig';
    doneBtn.addEventListener('click', () => this.close());

    actions.append(resetBtn, doneBtn);

    this.trigger.addEventListener('click', event => {
      event.preventDefault();
      event.stopPropagation();
      if (this.container.classList.contains('open')) {
        this.close();
      } else {
        closeAllColorPickers(this);
        this.open();
      }
    });

    ['pointerdown', 'mousedown', 'click'].forEach(evt => {
      this.popover.addEventListener(evt, event => event.stopPropagation());
    });

    this.popover.addEventListener('keydown', event => {
      if (event.key === 'Escape') {
        event.stopPropagation();
        this.close();
      }
    });
  }

  open() {
    this.container.classList.add('open');
    this.trigger.setAttribute('aria-expanded', 'true');
  }

  close() {
    this.container.classList.remove('open');
    this.trigger.setAttribute('aria-expanded', 'false');
  }

  setValue(value, options = {}) {
    const parsed = parseColor(value);
    if (!parsed) return;
    this.value = parsed;
    this.cssValue = hslaToString(parsed);
    this.input.value = this.cssValue;
    this.container.style.setProperty('--hsla-color', this.cssValue);
    if (this.valueEl) {
      this.valueEl.textContent = this.cssValue;
    }
    Object.entries(this.sliders).forEach(([channel, slider]) => {
      const numeric = channel === 'a'
        ? clamp(parsed.a, 0, 1)
        : channel === 'h'
          ? normalizeHue(parsed.h)
          : clamp(parsed[channel], 0, 100);
      const sliderValue = channel === 'a'
        ? String(Math.round(numeric * 100) / 100)
        : String(Math.round(numeric));
      slider.value = sliderValue;
      const info = this.sliderValues[channel];
      if (info?.element) {
        info.element.value = this.formatChannelValue(channel, numeric);
      }
    });
    this.updateSliderBackgrounds();
    if (!options?.silent) {
      const dispatch = options?.dispatch || 'input';
      const types = dispatch === 'both' ? ['input', 'change'] : [dispatch];
      types.filter(Boolean).forEach(type => this.dispatch(type));
    }
  }

  formatChannelValue(channel, numeric) {
    if (channel === 'a') {
      const rounded = Math.round(clamp(numeric, 0, 1) * 100) / 100;
      return rounded.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
    }
    if (channel === 'h') {
      return String(Math.round(normalizeHue(numeric)));
    }
    return String(Math.round(clamp(numeric, 0, 100)));
  }

  handleNumberInput(channel, eventType) {
    const info = this.sliderValues[channel];
    if (!info?.element) return;
    const displayRaw = info.element.value;
    const normalized = displayRaw.trim().replace(',', '.');
    if (!normalized) {
      if (eventType === 'change') {
        info.element.value = this.formatChannelValue(channel, this.value[channel]);
      }
      return;
    }
    const numeric = Number(normalized);
    if (Number.isNaN(numeric)) return;
    const next = { ...this.value, [channel]: numeric };
    this.setValue(next, { dispatch: eventType === 'change' ? 'change' : 'input' });
    if (eventType === 'input') {
      info.element.value = displayRaw;
    }
  }

  updateSliderBackgrounds() {
    const { h, s, l } = this.value;
    if (this.sliders.h) {
      this.sliders.h.style.background = 'linear-gradient(90deg,' +
        ' hsl(0, 100%, 50%),' +
        ' hsl(45, 100%, 50%),' +
        ' hsl(90, 100%, 50%),' +
        ' hsl(135, 100%, 50%),' +
        ' hsl(180, 100%, 50%),' +
        ' hsl(225, 100%, 50%),' +
        ' hsl(270, 100%, 50%),' +
        ' hsl(315, 100%, 50%),' +
        ' hsl(360, 100%, 50%)' +
      ')';
      this.sliders.h.style.backgroundSize = '100% 100%';
      this.sliders.h.style.backgroundRepeat = 'no-repeat';
    }
    if (this.sliders.s) {
      this.sliders.s.style.background = `linear-gradient(to right, hsla(${h}, 0%, ${l}%, 1), hsla(${h}, 100%, ${l}%, 1))`;
    }
    if (this.sliders.l) {
      this.sliders.l.style.background = `linear-gradient(to right, hsla(${h}, ${s}%, 0%, 1), hsla(${h}, ${s}%, 50%, 1), hsla(${h}, ${s}%, 100%, 1))`;
    }
    if (this.sliders.a) {
      this.sliders.a.style.backgroundImage = `linear-gradient(to right, hsla(${h}, ${s}%, ${l}%, 0), hsla(${h}, ${s}%, ${l}%, 1)), ` +
        `linear-gradient(45deg, #e2e8f0 25%, transparent 25%, transparent 75%, #e2e8f0 75%), ` +
        `linear-gradient(45deg, transparent 25%, #e2e8f0 25%, #e2e8f0 75%, transparent 75%)`;
      this.sliders.a.style.backgroundSize = '100% 100%, 12px 12px, 12px 12px';
      this.sliders.a.style.backgroundPosition = 'center, 0 0, 6px 6px';
      this.sliders.a.style.backgroundRepeat = 'no-repeat, repeat, repeat';
    }
  }

  updateFromSliders(eventType) {
    const h = Number(this.sliders.h?.value ?? this.value.h);
    const s = Number(this.sliders.s?.value ?? this.value.s);
    const l = Number(this.sliders.l?.value ?? this.value.l);
    const a = Number(this.sliders.a?.value ?? this.value.a);
    const dispatchType = eventType === 'change' ? 'change' : 'input';
    this.setValue({ h, s, l, a }, { dispatch: dispatchType });
  }

  dispatch(type) {
    if (!type) return;
    this.input.dispatchEvent(new Event(type, { bubbles: true }));
  }

  getValue() {
    return this.cssValue;
  }
}

const MAX_MODULE_COLOR_LAYERS = 8;
const DEFAULT_SUB_LAYER_COUNT = 1;
const MAX_MODULE_SUB_LAYERS = 8;

function generateLayerId() {
  return 'layer-' + Math.random().toString(36).slice(2, 10);
}

function hexToRgba(color, alpha) {
  const parsed = parseColor(color);
  if (!parsed) return '';
  const rgba = hslaToRgba(parsed);
  const finalAlpha = typeof alpha === 'number' ? clamp(alpha, 0, 1) : rgba.a;
  return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${finalAlpha})`;
}

function normalizeSubLayerEntries(subLayers, targetCount, moduleBg, moduleText) {
  const fallbackBg = typeof moduleBg === 'string' && moduleBg ? moduleBg : '#1f2937';
  const fallbackText = typeof moduleText === 'string' && moduleText ? moduleText : '#ffffff';
  const source = Array.isArray(subLayers) && subLayers.length
    ? subLayers
    : [{
        bg: fallbackBg,
        text: fallbackText,
        border: fallbackBg
      }];
  const normalized = source.map(entry => {
    const bg = typeof entry.bg === 'string' && entry.bg ? entry.bg : fallbackBg;
    const text = typeof entry.text === 'string' && entry.text ? entry.text : fallbackText;
    const border = typeof entry.border === 'string' && entry.border
      ? entry.border
      : bg;
    return { bg, text, border };
  });
  while (normalized.length < targetCount) {
    const last = normalized[normalized.length - 1] || { bg: fallbackBg, text: fallbackText, border: fallbackBg };
    normalized.push({ ...last });
  }
  if (normalized.length > targetCount) {
    normalized.length = targetCount;
  }
  return normalized;
}

function createColorLayer(
  name,
  moduleBg,
  moduleText,
  moduleBorder,
  headerBg,
  headerText,
  headerBorder,
  subLayerConfig,
  maybeSubText,
  maybeSubBorder
) {
  const baseSubLayers = Array.isArray(subLayerConfig)
    ? subLayerConfig
    : [{
        bg: subLayerConfig,
        text: typeof maybeSubText === 'string' && maybeSubText ? maybeSubText : '#ffffff',
        border: typeof maybeSubBorder === 'string' && maybeSubBorder ? maybeSubBorder : (typeof subLayerConfig === 'string' && subLayerConfig ? subLayerConfig : moduleBg)
      }];
  const subLayers = normalizeSubLayerEntries(baseSubLayers, DEFAULT_SUB_LAYER_COUNT, moduleBg, moduleText);
  const firstSubLayer = subLayers[0] || { bg: moduleBg, text: moduleText, border: moduleBg };
  return {
    id: generateLayerId(),
    name,
    moduleBg,
    moduleText,
    moduleBorder,
    headerBg,
    headerText,
    headerBorder,
    subLayers,
    subBg: firstSubLayer.bg,
    subText: firstSubLayer.text,
    subBorder: firstSubLayer.border
  };
}

function getDefaultModuleColorLayers() {
  return [
    createColorLayer('Unter-Layer 1', '#005983', '#ffffff', '#0f6ab4', '#0f6ab4', '#ffffff', '#0a487a', '#07365b', '#ffffff', '#052b47')
  ];
}

function normalizeModuleColorLayers(layers, subLayerCount = DEFAULT_SUB_LAYER_COUNT) {
  const count = Math.min(Math.max(Number(subLayerCount) || DEFAULT_SUB_LAYER_COUNT, 1), MAX_MODULE_SUB_LAYERS);
  const source = Array.isArray(layers) && layers.length ? layers : getDefaultModuleColorLayers();
  return source
    .slice(0, MAX_MODULE_COLOR_LAYERS)
    .map((layer, index) => {
      const moduleBg = typeof layer.moduleBg === 'string' && layer.moduleBg ? layer.moduleBg : '#005983';
      const moduleText = typeof layer.moduleText === 'string' && layer.moduleText ? layer.moduleText : '#ffffff';
      const moduleBorder = typeof layer.moduleBorder === 'string' && layer.moduleBorder
        ? layer.moduleBorder
        : (typeof layer.moduleText === 'string' && layer.moduleText ? layer.moduleText : '#ffffff');
      const headerBg = typeof layer.headerBg === 'string' && layer.headerBg ? layer.headerBg : moduleBg;
      const headerText = typeof layer.headerText === 'string' && layer.headerText ? layer.headerText : moduleText;
      const headerBorder = typeof layer.headerBorder === 'string' && layer.headerBorder ? layer.headerBorder : headerBg;
      const baseSubLayers = Array.isArray(layer.subLayers) && layer.subLayers.length
        ? layer.subLayers
        : [{
            bg: typeof layer.subBg === 'string' && layer.subBg ? layer.subBg : moduleBg,
            text: typeof layer.subText === 'string' && layer.subText ? layer.subText : moduleText,
            border: typeof layer.subBorder === 'string' && layer.subBorder ? layer.subBorder : (typeof layer.subBg === 'string' && layer.subBg ? layer.subBg : moduleBg)
          }];
      const subLayers = normalizeSubLayerEntries(baseSubLayers, count, moduleBg, moduleText);
      const firstSubLayer = subLayers[0] || { bg: moduleBg, text: moduleText, border: moduleBg };
      return {
        id: typeof layer.id === 'string' && layer.id.trim() ? layer.id : generateLayerId(),
        name: typeof layer.name === 'string' ? layer.name : `Unter-Layer ${index + 1}`,
        moduleBg,
        moduleText,
        moduleBorder,
        headerBg,
        headerText,
        headerBorder,
        subLayers,
        subBg: firstSubLayer.bg,
        subText: firstSubLayer.text,
        subBorder: firstSubLayer.border
      };
    });
}

/*
 * Global settings object; defaults correspond to CSS variables defined above.
 * New properties for border colour and sidebar text are included.
 */
let appSettings = {
  appBgColor: '#f3f4f6',
  sidebarBg: '#f3f4f6',
  sidebarText: '#1f2937',
  topBarBg: '#ffffff',
  buttonBg: '#2563eb',
  buttonText: '#ffffff',
  borderColor: '#e5e7eb',
  autoArrangeModules: true,
  moduleBorderRadius: '1.25rem',
  dangerBg: '#ef4444',
  dangerText: '#ffffff',
  tabActiveBg: '#2563eb',
  tabActiveText: '#ffffff',
  tabInactiveBg: '#e5e7eb',
  tabInactiveText: '#1f2937',
  gridHint: '#60a5fa',
  sidebarModuleCardBg: '#ffffff',
  sidebarModuleCardText: '#1f2937',
  sidebarModuleCardBorder: '#e5e7eb',
  showUpdateStatusButton: true,
  autoUpdatePolling: false,
  hideDowngradeStatusButton: false,
  moduleSubLayerCount: DEFAULT_SUB_LAYER_COUNT,
  moduleColorLayers: normalizeModuleColorLayers([], DEFAULT_SUB_LAYER_COUNT)
};

const CSS_PROFILE_VARIABLES = [
  '--app-bg',
  '--sidebar-bg',
  '--sidebar-text',
  '--top-bar-bg',
  '--button-bg',
  '--button-text',
  '--border-color',
  '--module-border-radius',
  '--danger-bg',
  '--danger-text',
  '--tab-active-bg',
  '--tab-active-text',
  '--tab-inactive-bg',
  '--tab-inactive-text',
  '--grid-hint',
  '--sidebar-module-card-bg',
  '--sidebar-module-card-text',
  '--sidebar-module-card-border',
  '--module-bg',
  '--text-color',
  '--module-border-color',
  '--module-header-bg',
  '--module-header-text'
];

const CSS_VARIABLE_SETTERS = {
  '--app-bg': value => { appSettings.appBgColor = value; },
  '--sidebar-bg': value => { appSettings.sidebarBg = value; },
  '--sidebar-text': value => { appSettings.sidebarText = value; },
  '--top-bar-bg': value => { appSettings.topBarBg = value; },
  '--button-bg': value => { appSettings.buttonBg = value; },
  '--button-text': value => { appSettings.buttonText = value; },
  '--border-color': value => { appSettings.borderColor = value; },
  '--module-border-radius': value => { appSettings.moduleBorderRadius = value; },
  '--danger-bg': value => { appSettings.dangerBg = value; },
  '--danger-text': value => { appSettings.dangerText = value; },
  '--tab-active-bg': value => { appSettings.tabActiveBg = value; },
  '--tab-active-text': value => { appSettings.tabActiveText = value; },
  '--tab-inactive-bg': value => { appSettings.tabInactiveBg = value; },
  '--tab-inactive-text': value => { appSettings.tabInactiveText = value; },
  '--grid-hint': value => { appSettings.gridHint = value; },
  '--sidebar-module-card-bg': value => { appSettings.sidebarModuleCardBg = value; },
  '--sidebar-module-card-text': value => { appSettings.sidebarModuleCardText = value; },
  '--sidebar-module-card-border': value => { appSettings.sidebarModuleCardBorder = value; },
  '--module-bg': value => { const layer = ensurePrimaryModuleLayer(); if (layer) layer.moduleBg = value; },
  '--text-color': value => { const layer = ensurePrimaryModuleLayer(); if (layer) layer.moduleText = value; },
  '--module-border-color': value => { const layer = ensurePrimaryModuleLayer(); if (layer) layer.moduleBorder = value; },
  '--module-header-bg': value => { const layer = ensurePrimaryModuleLayer(); if (layer) layer.headerBg = value; },
  '--module-header-text': value => { const layer = ensurePrimaryModuleLayer(); if (layer) layer.headerText = value; }
};

const THEME_PROFILE_STORAGE_KEY = 'appThemeProfiles';
let themeProfiles = {};
let cssVariableState = {};
let customStylesWriteHandle = null;
const requestCustomFrame = typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function'
  ? window.requestAnimationFrame.bind(window)
  : callback => setTimeout(callback, 16);
const cancelCustomFrame = typeof window !== 'undefined' && typeof window.cancelAnimationFrame === 'function'
  ? window.cancelAnimationFrame.bind(window)
  : handle => clearTimeout(handle);

function getPrimaryModuleLayer(createIfMissing = false) {
  if (!Array.isArray(appSettings.moduleColorLayers)) {
    if (!createIfMissing) return null;
    appSettings.moduleColorLayers = normalizeModuleColorLayers([], appSettings.moduleSubLayerCount || DEFAULT_SUB_LAYER_COUNT);
  }
  if (!appSettings.moduleColorLayers.length) {
    if (!createIfMissing) return null;
    appSettings.moduleColorLayers = normalizeModuleColorLayers([], appSettings.moduleSubLayerCount || DEFAULT_SUB_LAYER_COUNT);
  }
  return appSettings.moduleColorLayers[0] || null;
}

function ensurePrimaryModuleLayer() {
  return getPrimaryModuleLayer(true);
}

function scheduleCustomStylesWrite() {
  if (!customStylesEl) return;
  if (customStylesWriteHandle !== null) {
    cancelCustomFrame(customStylesWriteHandle);
  }
  customStylesWriteHandle = requestCustomFrame(() => {
    customStylesWriteHandle = null;
    const entries = Object.keys(cssVariableState).sort((a, b) => a.localeCompare(b));
    const lines = entries.map(name => `  ${name}: ${cssVariableState[name]};`);
    customStylesEl.textContent = lines.length ? `:root {\n${lines.join('\n')}\n}` : '';
  });
}

function updateCssVariables(assignments = {}) {
  let changed = false;
  Object.entries(assignments).forEach(([name, value]) => {
    if (typeof name !== 'string' || !name.startsWith('--')) return;
    const normalized = typeof value === 'string' ? value.trim() : value;
    if (!normalized) {
      if (Object.prototype.hasOwnProperty.call(cssVariableState, name)) {
        delete cssVariableState[name];
        changed = true;
      }
      return;
    }
    if (cssVariableState[name] !== normalized) {
      cssVariableState[name] = normalized;
      changed = true;
    }
  });
  if (changed) scheduleCustomStylesWrite();
}

function getCssVariableValue(name) {
  if (Object.prototype.hasOwnProperty.call(cssVariableState, name)) {
    return cssVariableState[name];
  }
  const computed = getComputedStyle(document.documentElement).getPropertyValue(name);
  return (computed || '').trim();
}

function loadThemeProfiles() {
  try {
    const stored = localStorage.getItem(THEME_PROFILE_STORAGE_KEY);
    if (!stored) return {};
    const parsed = JSON.parse(stored);
    if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
      return parsed;
    }
  } catch (err) {
    console.warn('Konnte Profile nicht laden', err);
  }
  return {};
}

function saveThemeProfiles() {
  try {
    localStorage.setItem(THEME_PROFILE_STORAGE_KEY, JSON.stringify(themeProfiles));
  } catch (err) {
    console.warn('Konnte Profile nicht speichern', err);
  }
}

function updateProfileActionState() {
  const hasSelection = !!(themeProfileSelect && themeProfileSelect.value && themeProfiles?.[themeProfileSelect.value]);
  if (themeProfileLoadBtn) themeProfileLoadBtn.disabled = !hasSelection;
  if (themeProfileDeleteBtn) themeProfileDeleteBtn.disabled = !hasSelection;
}

function refreshProfileOptions(selectedName) {
  if (!themeProfileSelect) return;
  const options = Object.keys(themeProfiles || {}).sort((a, b) => a.localeCompare(b, 'de', { sensitivity: 'base' }));
  themeProfileSelect.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'Profil wählen…';
  themeProfileSelect.appendChild(placeholder);
  options.forEach(name => {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    if (selectedName && selectedName === name) option.selected = true;
    themeProfileSelect.appendChild(option);
  });
  if (selectedName && !options.includes(selectedName)) {
    themeProfileSelect.value = '';
  }
  if (themeProfileNameInput) {
    themeProfileNameInput.value = selectedName && options.includes(selectedName) ? selectedName : '';
  }
  updateProfileActionState();
}

function collectCurrentCssProfile() {
  const profile = {};
  CSS_PROFILE_VARIABLES.forEach(varName => {
    const value = getCssVariableValue(varName);
    if (value) profile[varName] = value;
  });
  return profile;
}

function applyProfileVariables(profile) {
  if (!profile || typeof profile !== 'object') return;
  const extras = {};
  const knownKeys = new Set(CSS_PROFILE_VARIABLES);
  Object.entries(profile).forEach(([varName, value]) => {
    const setter = CSS_VARIABLE_SETTERS[varName];
    if (setter) {
      setter(value);
    } else {
      extras[varName] = value;
    }
  });
  Object.keys(cssVariableState).forEach(varName => {
    if (!knownKeys.has(varName) && !Object.prototype.hasOwnProperty.call(profile, varName)) {
      extras[varName] = '';
    }
  });
  if (Object.keys(extras).length) {
    updateCssVariables(extras);
  }
  populateInputsFromSettings();
  applySettings();
  renderTabs();
  scheduleSettingsSave();
}

const layoutFileName = 'layout.json';
const settingsFileName = 'settings.json';
const HTML_FILE_NAME = 'ShopguideV3.html';
const HTML_CHANGELOG_FILE = 'ShopguideChangelog.txt';
const ACTIVE_TAB_STORAGE_KEY = 'modulesLayoutActiveTab';
let rootDirHandle = null;
let updateDirHandle = null;
let modulesDirHandle = null;
let liveModuleTemplates = [];
let tabs = [];
let activeTabIndex = 0;
let tabContextMenu = null;
let tabsSortable = null;
// Start with sidebar closed by default
let isSidebarOpen = false;
let pendingUpdates = [];
let updateCheckInProgress = false;
let currentUpgradeItems = [];
let currentDowngradeItems = [];
let updateStatusHasStableAppearance = false;
let updateStatusShouldRemainHidden = false;
let settingsSaveTimeoutId = null;
let historyMenuOpen = false;
let lastUpdateError = false;
let updatePollingIntervalId = null;
let versionOverview = {
  html: {
    type: 'html',
    displayName: HTML_FILE_NAME,
    name: HTML_FILE_NAME,
    localVersion: null,
    updateVersion: null,
    currentVersion: null,
    newVersion: null,
    localFileName: HTML_FILE_NAME,
    updateFileName: null,
    updateDirHandle: null,
    localDirHandle: null,
    changelogHandle: null,
    changelogFileName: HTML_CHANGELOG_FILE,
    changelogPath: HTML_CHANGELOG_FILE,
    changelogRelativePath: null
  },
  modules: []
};

if (typeof window !== 'undefined') {
  window.rootDirHandle = null;
  window.updateDirHandle = null;
}

function setGlobalHandle(type, handle) {
  if (typeof window === 'undefined') return;
  const prop = type === 'root' ? 'rootDirHandle' : 'updateDirHandle';
  window[prop] = handle || null;
  try {
    window.dispatchEvent(new CustomEvent(`shopguide:${type}-handle-changed`, {
      detail: { hasHandle: !!handle }
    }));
  } catch (err) {
    console.warn(`Konnte ${type}-Handle-Ereignis nicht senden`, err);
  }
}
let rerunUpdateCheckWhenUnlocked = false;
let changelogRequestToken = 0;
let lastChangelogTrigger = null;
let htmlUpdateChangelogHandle = null;
let htmlUpdateChangelogFileName = null;
let cachedHtmlChangelogSections = null;
let htmlChangelogSourceLabel = null;
let currentGlobalChangelogMode = 'single';
let currentGlobalChangelogIndex = 0;
let currentChangelogContext = 'none';
let moduleChangelogSections = null;
let moduleChangelogFilteredSections = null;
let moduleChangelogNotice = null;
let moduleChangelogShowFull = false;
let sidebarTreeData = [];
let sidebarSearchTerm = '';
let undoStack = [];
let redoStack = [];
let layoutRecordingSuppressCount = 0;
let saveIndicatorPending = 0;
let downgradeCollapsed = true;
let historyInProgress = false;

/* ==== UNIQUE IDs ==== */
let usedInstanceIds = new Set();
let nextModuleInstanceId = 1;
function generateInstanceId() {
  if (window.crypto?.randomUUID) {
    let id;
    do { id = 'mod-' + crypto.randomUUID(); }
    while (usedInstanceIds.has(id));
    usedInstanceIds.add(id);
    return id;
  }
  let id;
  do { id = 'mod-' + (nextModuleInstanceId++); }
  while (usedInstanceIds.has(id));
  usedInstanceIds.add(id);
  return id;
}

// Cache DOM elements
const moduleSearchInput = document.getElementById('module-search');
const moduleSearchClearBtn = document.getElementById('module-search-clear');
const listEl = document.getElementById('module-list');
const gridsContainer = document.getElementById('grids');
const tabsContainer = document.getElementById('tabs-container');
const addTabBtn = document.getElementById('add-tab');
const sidebarEl = document.getElementById('sidebar');
const sidebarToggle = document.getElementById('sidebar-toggle');
const undoBtn = document.getElementById('undo-action');
const redoBtn = document.getElementById('redo-action');
const historyMenu = document.getElementById('history-menu');
const historyMenuToggle = document.getElementById('history-menu-toggle');
const historyMenuDropdown = document.getElementById('history-menu-dropdown');
const updateStatusBtn = document.getElementById('update-status');
const rootBtn = document.getElementById('select-root');
const settingsBtn = document.getElementById('open-settings');
const settingsModal = document.getElementById('settings-modal');
const customStylesEl = document.getElementById('custom-styles');
const closeSettingsBtn = document.getElementById('close-settings');
const updateFolderNameEl = document.getElementById('update-folder-name');
const selectUpdateFolderBtn = document.getElementById('select-update-folder');
const clearUpdateFolderBtn = document.getElementById('clear-update-folder');
const updatesTableBody = document.getElementById('updates-table-body');
const updatesEmptyState = document.getElementById('updates-empty-state');
const updateCheckStatus = document.getElementById('update-check-status');
const versionOverviewContainer = document.getElementById('update-version-overview');
const versionOverviewRowsEl = document.getElementById('update-version-rows');
const changelogOverlay = document.getElementById('changelog-modal');
const changelogTitleEl = document.getElementById('changelog-title');
const changelogSubtitleEl = document.getElementById('changelog-subtitle');
const changelogBodyEl = document.getElementById('changelog-body');
const closeChangelogBtn = document.getElementById('close-changelog');
const showLatestChangelogBtn = document.getElementById('show-latest-changelog');
const changelogControlsEl = document.getElementById('changelog-controls');
const changelogVersionSelect = document.getElementById('changelog-version-select');
const changelogShowFullBtn = document.getElementById('changelog-show-full');
const changelogVersionLabel = changelogControlsEl?.querySelector('label[for="changelog-version-select"]') || null;
const updateAllContainer = document.getElementById('update-all-container');
const updateAllBtn = document.getElementById('update-all');
const saveIndicator = document.getElementById('save-indicator');
const downgradeSection = document.getElementById('downgrade-section');
const downgradeToggle = document.getElementById('downgrade-toggle');
const downgradeContent = document.getElementById('downgrade-content');
const downgradeTableBody = document.getElementById('downgrade-table-body');
const downgradeHeading = document.getElementById('downgrade-heading');
const downgradeToggleIcon = document.getElementById('downgrade-toggle-icon');
// Settings inputs
const inputAppBg = document.getElementById('setting-app-bg');
const inputBorderColor = document.getElementById('setting-border-color');
const inputButtonBg = document.getElementById('setting-button-bg');
const inputButtonText = document.getElementById('setting-button-text');
const inputTopBarBg = document.getElementById('setting-topbar-bg');
const inputTabActiveBg = document.getElementById('setting-tab-active-bg');
const inputTabActiveText = document.getElementById('setting-tab-active-text');
const inputTabInactiveBg = document.getElementById('setting-tab-inactive-bg');
const inputTabInactiveText = document.getElementById('setting-tab-inactive-text');
const inputSidebarBg = document.getElementById('setting-sidebar-bg');
const inputSidebarText = document.getElementById('setting-sidebar-text');
const inputGridHint = document.getElementById('setting-grid-hint');
const inputAutoArrange = document.getElementById('setting-grid-auto-arrange');
const inputBorderRadius = document.getElementById('setting-border-radius');
const inputDangerBg = document.getElementById('setting-danger-bg');
const inputDangerText = document.getElementById('setting-danger-text');

// Sidebar module card inputs
const inputSidebarModuleBg = document.getElementById('setting-sidebar-module-bg');
const inputSidebarModuleText = document.getElementById('setting-sidebar-module-text');
const inputSidebarModuleBorder = document.getElementById('setting-sidebar-module-border');
const moduleColorLayersContainer = document.getElementById('module-color-layers');
const addModuleColorLayerBtn = document.getElementById('add-module-color-layer');
const inputShowUpdateButton = document.getElementById('setting-show-update-button');
const inputUpdateAutoPoll = document.getElementById('setting-update-auto-poll');
const inputHideDowngradeButton = document.getElementById('setting-hide-downgrade-button');
const themeProfileSelect = document.getElementById('theme-profile-select');
const themeProfileNameInput = document.getElementById('theme-profile-name');
const themeProfileSaveBtn = document.getElementById('theme-profile-save');
const themeProfileLoadBtn = document.getElementById('theme-profile-load');
const themeProfileDeleteBtn = document.getElementById('theme-profile-delete');

// Navigation buttons for settings
const settingsNavButtons = document.querySelectorAll('.settings-nav button');

// Remember the selected root folder across sessions
const FS_HANDLE_KEY = 'rootDirHandle';
const ROOT_HANDLE_NAME_KEY = 'rootDirDisplayName';
const UPDATE_HANDLE_KEY = 'updateDirHandle';
const UPDATE_HANDLE_NAME_KEY = 'updateDirDisplayName';
const DOWNGRADE_COLLAPSE_KEY = 'downgradeSectionCollapsed';
const MAX_HISTORY_ENTRIES = 50;
const UPDATE_POLL_INTERVAL_MS = 5 * 1000;
const UPDATE_STATUS_BASE_CLASSES = 'text-sm px-3 py-1 rounded transition-colors duration-200 font-medium border border-transparent';
const IGNORED_DOWNGRADES_STORAGE_KEY = 'ignoredDowngradeVersions';
const MAX_IGNORED_DOWNGRADE_VERSIONS = 20;

let pendingRootPermission = false;
let pendingUpdatePermission = false;
let ignoredDowngradeEntries = loadIgnoredDowngrades();

const storedRootFolderName = (() => {
  try {
    return localStorage.getItem(ROOT_HANDLE_NAME_KEY);
  } catch (e) {
    console.warn('Konnte Arbeitsordnernamen nicht aus dem localStorage lesen', e);
    return null;
  }
})();

const storedDowngradeCollapsed = (() => {
  try {
    return localStorage.getItem(DOWNGRADE_COLLAPSE_KEY);
  } catch (e) {
    return null;
  }
})();
if (storedDowngradeCollapsed === '0') {
  downgradeCollapsed = false;
} else if (storedDowngradeCollapsed === '1') {
  downgradeCollapsed = true;
}
if (storedRootFolderName && rootBtn) {
  rootBtn.textContent = storedRootFolderName;
  rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
}

const storedUpdateFolderName = (() => {
  try {
    return localStorage.getItem(UPDATE_HANDLE_NAME_KEY);
  } catch (e) {
    console.warn('Konnte Update-Ordnernamen nicht aus dem localStorage lesen', e);
    return null;
  }
})();
if (storedUpdateFolderName && updateFolderNameEl) {
  updateFolderNameEl.textContent = storedUpdateFolderName;
}

function idbOpen() {
  return new Promise((res, rej) => {
    const req = indexedDB.open('modulesApp', 1);
    req.onupgradeneeded = () => req.result.createObjectStore('fs-handles');
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}
async function idbSet(key, val){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction('fs-handles','readwrite');
    tx.objectStore('fs-handles').put(val, key);
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction('fs-handles','readonly');
    const req = tx.objectStore('fs-handles').get(key);
    req.onsuccess = () => res(req.result || null);
    req.onerror = () => rej(req.error);
  });
}
async function idbDel(key){
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction('fs-handles','readwrite');
    tx.objectStore('fs-handles').delete(key);
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function ensureRWPermission(handle, opts = {}){
  if (typeof handle?.queryPermission !== 'function') return true;
  const mode = opts.mode || 'readwrite';
  const q = await handle.queryPermission({ mode });
  if (q === 'granted') return true;
  if (opts.request === false) return false;
  try {
    const r = await handle.requestPermission({ mode });
    return r === 'granted';
  } catch (err) {
    console.warn('requestPermission failed', err);
    return false;
  }
}
async function tryRestoreRootHandle(){
  if (!('showDirectoryPicker' in window)) return false;
  try {
    const h = await idbGet(FS_HANDLE_KEY);
    if (!h) return false;
    let ok = await ensureRWPermission(h, { mode: 'readwrite', request: false });
    if (!ok) {
      try {
        ok = await ensureRWPermission(h, { mode: 'readwrite' });
      } catch (permErr) {
        console.warn('requestPermission für Arbeitsordner fehlgeschlagen:', permErr);
      }
    }

    rootDirHandle = h;
    setGlobalHandle('root', rootDirHandle);
    const displayName = storedRootFolderName || h.name;
    rootBtn.textContent = displayName;
    try { localStorage.setItem(ROOT_HANDLE_NAME_KEY, h.name); } catch (e) {
      console.warn('Konnte Arbeitsordnernamen nicht speichern', e);
    }

    if (!ok) {
      pendingRootPermission = true;
      rootBtn.classList.remove('bg-gray-300','hover:bg-gray-400','text-gray-800');
      rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
      rootBtn.classList.add('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
      rootBtn.title = 'Bitte Zugriff auf den gespeicherten Arbeitsordner erlauben oder einen neuen wählen.';
      setUpdateStatusButton();
      renderUpdateList();
      return false;
    }

    pendingRootPermission = false;
    rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
    rootBtn.classList.remove('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
    rootBtn.title = '';
    rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');

    await loadModulesFromRoot(h);
    await loadAppSettings();
    applySettings();
    await loadAndInitTabs();
    return true;
  } catch (e) {
    console.warn('Restore root handle failed:', e);
    return false;
  }
}

async function tryRestoreUpdateHandle(){
  if (!('showDirectoryPicker' in window)) return false;
  try {
    const h = await idbGet(UPDATE_HANDLE_KEY);
    if (!h) return false;
    let ok = await ensureRWPermission(h, { request: false, mode: 'read' });
    if (!ok) {
      try {
        ok = await ensureRWPermission(h, { mode: 'read' });
      } catch (permErr) {
        console.warn('requestPermission für Update-Ordner fehlgeschlagen:', permErr);
      }
    }
    updateDirHandle = h;
    setGlobalHandle('update', updateDirHandle);
    if (updateFolderNameEl) updateFolderNameEl.textContent = h.name;
    try { localStorage.setItem(UPDATE_HANDLE_NAME_KEY, h.name); } catch (e) {
      console.warn('Konnte Update-Ordnernamen nicht speichern', e);
    }
    if (!ok) {
      pendingUpdatePermission = true;
      if (updateCheckStatus) {
        updateCheckStatus.textContent = 'Bitte Zugriff auf den Update-Ordner erlauben.';
      }
      setUpdateStatusButton();
      renderUpdateList();
      return false;
    }
    pendingUpdatePermission = false;
    return true;
  } catch (e) {
    console.warn('Restore update handle failed:', e);
    return false;
  }
}

function formatVersionDisplay(val) {
  if (val === null || typeof val === 'undefined') return '–';
  if (typeof val === 'string' && val.trim() === '') return '–';
  return String(val);
}

function normalizeVersionValue(value) {
  if (value === null || typeof value === 'undefined') return null;
  const str = String(value).trim();
  if (!str) return null;
  if (/^unreleased$/i.test(str)) return null;
  return str.replace(/^[vV]\s*/, '').trim();
}

function compareVersions(a, b) {
  const normA = normalizeVersionValue(a);
  const normB = normalizeVersionValue(b);
  if (normA === null && normB === null) return 0;
  if (normA === null) return -1;
  if (normB === null) return 1;

  const partsA = normA.split(/[^0-9A-Za-z]+/).filter(Boolean);
  const partsB = normB.split(/[^0-9A-Za-z]+/).filter(Boolean);
  const len = Math.max(partsA.length, partsB.length);

  for (let i = 0; i < len; i++) {
    const segA = partsA[i] ?? '0';
    const segB = partsB[i] ?? '0';
    const numA = Number(segA);
    const numB = Number(segB);

    const bothNumeric = !Number.isNaN(numA) && !Number.isNaN(numB);
    if (bothNumeric) {
      if (numA > numB) return 1;
      if (numA < numB) return -1;
      continue;
    }

    const cmp = segA.localeCompare(segB, undefined, { numeric: true, sensitivity: 'base' });
    if (cmp > 0) return 1;
    if (cmp < 0) return -1;
  }

  return 0;
}

function loadIgnoredDowngrades() {
  const map = new Map();
  try {
    const raw = localStorage.getItem(IGNORED_DOWNGRADES_STORAGE_KEY);
    if (!raw) return map;
    const parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object') {
      Object.entries(parsed).forEach(([identity, value]) => {
        if (!identity) return;
        const versions = Array.isArray(value)
          ? value
          : (value && Array.isArray(value.versions) ? value.versions : []);
        if (!versions.length) return;
        const normalized = versions
          .map(entry => {
            if (typeof entry === 'string') return entry.trim() || '__null__';
            if (entry === null || typeof entry === 'undefined') return '__null__';
            return String(entry).trim() || '__null__';
          })
          .filter((entry, index, arr) => entry && arr.indexOf(entry) === index);
        if (normalized.length) {
          map.set(identity, normalized.slice(-MAX_IGNORED_DOWNGRADE_VERSIONS));
        }
      });
    }
  } catch (e) {
    console.warn('Konnte Liste ignorierter Downgrades nicht laden', e);
  }
  return map;
}

function persistIgnoredDowngrades() {
  try {
    const plain = {};
    ignoredDowngradeEntries.forEach((versions, identity) => {
      if (!Array.isArray(versions) || !versions.length) return;
      plain[identity] = versions.slice(-MAX_IGNORED_DOWNGRADE_VERSIONS);
    });
    localStorage.setItem(IGNORED_DOWNGRADES_STORAGE_KEY, JSON.stringify(plain));
  } catch (e) {
    console.warn('Konnte ignorierte Downgrades nicht speichern', e);
  }
}

function getDowngradeIdentity(item) {
  if (!item || typeof item !== 'object') return null;
  if (item.type === 'module') {
    if (item.moduleId) return `module:${item.moduleId}`;
    if (item.targetRelPath) return `module-target:${item.targetRelPath}`;
    if (item.sourceRelPath) return `module-source:${item.sourceRelPath}`;
  } else if (item.type === 'html') {
    const target = item.targetPath || item.path || item.displayName || HTML_FILE_NAME;
    return `html:${target}`;
  }
  if (item.path) return `path:${item.path}`;
  if (item.targetPath) return `target:${item.targetPath}`;
  if (item.displayName) return `name:${item.displayName}`;
  return null;
}

function getDowngradeVersionKey(version) {
  const normalized = normalizeVersionValue(version);
  return normalized === null ? '__null__' : String(normalized);
}

function isDowngradeIgnored(item) {
  const identity = getDowngradeIdentity(item);
  if (!identity) return false;
  const versions = ignoredDowngradeEntries.get(identity);
  if (!Array.isArray(versions) || !versions.length) return false;
  const versionKey = getDowngradeVersionKey(item?.newVersion);
  return versions.includes(versionKey);
}

function markDowngradeIgnored(item) {
  const identity = getDowngradeIdentity(item);
  if (!identity) return;
  const versionKey = getDowngradeVersionKey(item?.newVersion);
  let versions = ignoredDowngradeEntries.get(identity) || [];
  if (!Array.isArray(versions)) versions = [];
  if (!versions.includes(versionKey)) {
    versions = versions.concat(versionKey).slice(-MAX_IGNORED_DOWNGRADE_VERSIONS);
    ignoredDowngradeEntries.set(identity, versions);
    persistIgnoredDowngrades();
  }
}

function beginSuppressLayoutRecording() {
  layoutRecordingSuppressCount++;
}

function endSuppressLayoutRecording() {
  if (layoutRecordingSuppressCount > 0) {
    layoutRecordingSuppressCount--;
  }
}

function isLayoutRecordingSuppressed() {
  return layoutRecordingSuppressCount > 0;
}

function cloneModuleEntry(entry) {
  return { ...entry };
}

function captureLayoutSnapshot() {
  return {
    activeTabIndex,
    tabs: tabs.map(tab => ({
      name: tab.name,
      modules: Array.isArray(tab.modules) ? tab.modules.map(cloneModuleEntry) : []
    }))
  };
}

function layoutsEqual(a, b) {
  try {
    return JSON.stringify(a) === JSON.stringify(b);
  } catch (e) {
    return false;
  }
}

function updateUndoRedoButtons() {
  if (undoBtn) {
    undoBtn.disabled = !undoStack.length;
    undoBtn.classList.toggle('opacity-60', !undoStack.length);
    undoBtn.classList.toggle('cursor-not-allowed', !undoStack.length);
  }
  if (redoBtn) {
    redoBtn.disabled = !redoStack.length;
    redoBtn.classList.toggle('opacity-60', !redoStack.length);
    redoBtn.classList.toggle('cursor-not-allowed', !redoStack.length);
  }
  if (historyMenuToggle) {
    const hasActions = undoStack.length || redoStack.length;
    historyMenuToggle.disabled = !hasActions;
    historyMenuToggle.classList.toggle('opacity-60', !hasActions);
    historyMenuToggle.classList.toggle('text-gray-600', !!hasActions);
    historyMenuToggle.classList.toggle('text-gray-400', !hasActions);
    historyMenuToggle.setAttribute('aria-disabled', hasActions ? 'false' : 'true');
    historyMenuToggle.title = hasActions ? 'Verlauf' : 'Keine Verlaufsschritte verfügbar';
    if (!hasActions) {
      closeHistoryMenu();
    }
  }
}

function pushUndoState(snapshot) {
  if (!snapshot) return;
  undoStack.push(JSON.parse(JSON.stringify(snapshot)));
  if (undoStack.length > MAX_HISTORY_ENTRIES) {
    undoStack.shift();
  }
  redoStack = [];
  updateUndoRedoButtons();
}

async function restoreLayoutFromSnapshot(snapshot) {
  if (!snapshot || !Array.isArray(snapshot.tabs)) return;
  beginSuppressLayoutRecording();
  try {
    resetTabs();
    snapshot.tabs.forEach(tabData => {
      createTab(tabData.name, tabData.modules || []);
    });
    const readiness = tabs.map(tab => tab?.readyPromise || Promise.resolve());
    await Promise.all(readiness);
    if (!tabs.length) {
      createTab('Standard');
    }
    let targetIndex = typeof snapshot.activeTabIndex === 'number' ? snapshot.activeTabIndex : 0;
    if (targetIndex < 0 || targetIndex >= tabs.length) {
      targetIndex = Math.min(Math.max(targetIndex, 0), Math.max(0, tabs.length - 1));
    }
    activateTab(targetIndex);
    updateModuleDraggable();
    updateGridDraggable();
    updateGridAutoArrange();
  } finally {
    endSuppressLayoutRecording();
  }
  await saveLayout();
}

function parseChangelogSections(text) {
  if (!text) return [];
  const normalized = text.replace(/\r\n/g, '\n');
  const lines = normalized.split('\n');
  const sections = [];
  let current = null;

  for (const line of lines) {
    const headingMatch = line.match(/^##(?!#)\s*(?:\[(.+?)\]|([^\s]+))(.*)$/);
    if (headingMatch) {
      if (current) {
        sections.push({
          version: current.version,
          rawVersion: current.rawVersion,
          heading: current.heading,
          content: current.lines.join('\n').trim()
        });
      }
      const versionCandidate = (headingMatch[1] || headingMatch[2] || '').trim();
      const headingText = line.replace(/^##\s*/, '').trim();
      current = {
        rawVersion: versionCandidate,
        version: normalizeVersionValue(versionCandidate) || null,
        heading: headingText,
        lines: []
      };
    } else if (current) {
      current.lines.push(line);
    }
  }

  if (current) {
    sections.push({
      version: current.version,
      rawVersion: current.rawVersion,
      heading: current.heading,
      content: current.lines.join('\n').trim()
    });
  }

  return sections;
}

function filterChangelogSections(sections, currentVersion, targetVersion) {
  const current = normalizeVersionValue(currentVersion);
  const target = normalizeVersionValue(targetVersion);

  return sections.filter(section => {
    if (!section.version) return false;
    if (target && compareVersions(section.version, target) === 1) return false;
    if (current && compareVersions(section.version, current) <= 0) return false;
    return true;
  });
}

function appendChangelogSections(targetEl, sections) {
  if (!targetEl || !Array.isArray(sections)) return;
  sections.forEach(section => {
    const sectionEl = document.createElement('section');
    sectionEl.className = 'changelog-section';

    const headingEl = document.createElement('h3');
    headingEl.textContent = section.heading || (section.rawVersion ? `Version ${section.rawVersion}` : 'Changelog-Eintrag');
    sectionEl.appendChild(headingEl);

    const pre = document.createElement('pre');
    pre.className = 'changelog-pre';
    pre.textContent = section.content || 'Keine Details vorhanden.';
    sectionEl.appendChild(pre);

    targetEl.appendChild(sectionEl);
  });
}

function escapeRegExp(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function formatChangelogOptionLabel(section, index) {
  const heading = (section?.heading || '').trim();
  const rawVersion = (section?.rawVersion || '').trim();
  if (rawVersion && heading) {
    const pattern = new RegExp(`^\\s*\\[?${escapeRegExp(rawVersion)}\\]?\\s*[-–—:\\s]*`, 'i');
    const rest = heading.replace(pattern, '').trim();
    if (rest) {
      return `${rawVersion} – ${rest}`;
    }
  }
  if (rawVersion) {
    return rawVersion;
  }
  if (heading) {
    return heading;
  }
  return `Eintrag ${index + 1}`;
}

function populateChangelogVersionSelect(sections, selectedIndex = 0) {
  if (!changelogVersionSelect) return;
  changelogVersionSelect.innerHTML = '';
  if (!Array.isArray(sections) || !sections.length) {
    changelogVersionSelect.disabled = true;
    if (changelogShowFullBtn) changelogShowFullBtn.disabled = true;
    return;
  }

  sections.forEach((section, index) => {
    const option = document.createElement('option');
    option.value = String(index);
    option.textContent = formatChangelogOptionLabel(section, index);
    changelogVersionSelect.appendChild(option);
  });

  const safeIndex = Math.max(0, Math.min(sections.length - 1, selectedIndex));
  changelogVersionSelect.value = String(safeIndex);
  changelogVersionSelect.disabled = sections.length <= 1;
  if (changelogShowFullBtn) {
    changelogShowFullBtn.disabled = sections.length === 0;
  }
}

function updateGlobalChangelogSubtitle(mode, section = null, total = 0) {
  if (!changelogSubtitleEl) return;
  const parts = [];
  if (htmlChangelogSourceLabel) {
    parts.push(`Quelle: ${htmlChangelogSourceLabel}`);
  }

  if (mode === 'all') {
    parts.push(total ? `${total} Einträge` : 'Gesamter Verlauf');
  } else if (section) {
    if (section.rawVersion) {
      parts.push(`Version: ${section.rawVersion}`);
    } else if (section.heading) {
      parts.push(section.heading);
    }
  }

  changelogSubtitleEl.textContent = parts.join(' • ');
}

function displayGlobalChangelogSections(sections, mode = 'single', index = 0) {
  if (!changelogBodyEl) return;
  changelogBodyEl.innerHTML = '';
  if (!Array.isArray(sections) || !sections.length) {
    changelogBodyEl.innerHTML = '<div class="changelog-empty">Keine Changelog-Daten verfügbar.</div>';
    updateGlobalChangelogSubtitle('all', null, 0);
    return;
  }

  if (mode === 'all') {
    appendChangelogSections(changelogBodyEl, sections);
    updateGlobalChangelogSubtitle('all', null, sections.length);
  } else {
    const safeIndex = Math.max(0, Math.min(sections.length - 1, index));
    appendChangelogSections(changelogBodyEl, [sections[safeIndex]]);
    updateGlobalChangelogSubtitle('single', sections[safeIndex], sections.length);
  }
  changelogBodyEl.scrollTop = 0;
}

async function loadHtmlChangelogSections({ forceReload = false } = {}) {
  if (!forceReload && Array.isArray(cachedHtmlChangelogSections)) {
    return cachedHtmlChangelogSections;
  }

  let text = null;
  if (htmlUpdateChangelogHandle) {
    try {
      const file = await htmlUpdateChangelogHandle.getFile();
      text = await file.text();
      htmlChangelogSourceLabel = htmlUpdateChangelogFileName || HTML_CHANGELOG_FILE;
    } catch (err) {
      console.warn('HTML-Changelog konnte nicht gelesen werden', err);
    }
  }

  if (!text) {
    try {
      const response = await fetch(HTML_CHANGELOG_FILE, { cache: 'no-store' });
      if (response.ok) {
        text = await response.text();
        htmlChangelogSourceLabel = HTML_CHANGELOG_FILE;
      }
    } catch (err) {
      console.warn('Fallback-Changelog konnte nicht geladen werden', err);
    }
  }

  if (!text) {
    cachedHtmlChangelogSections = null;
    return null;
  }

  cachedHtmlChangelogSections = parseChangelogSections(text);
  return cachedHtmlChangelogSections;
}

function resetGlobalChangelogState() {
  currentGlobalChangelogMode = 'single';
  currentGlobalChangelogIndex = 0;
  if (changelogVersionSelect) {
    changelogVersionSelect.innerHTML = '';
    changelogVersionSelect.value = '';
    changelogVersionSelect.disabled = false;
  }
  if (changelogShowFullBtn) {
    changelogShowFullBtn.disabled = false;
    changelogShowFullBtn.textContent = 'Ganzen Changelog anzeigen';
  }
}

function resetModuleChangelogState() {
  moduleChangelogSections = null;
  moduleChangelogFilteredSections = null;
  moduleChangelogNotice = null;
  moduleChangelogShowFull = false;
}

function hideChangelogVersionControls() {
  if (changelogVersionLabel) changelogVersionLabel.classList.add('hidden');
  if (changelogVersionSelect) {
    changelogVersionSelect.classList.add('hidden');
    changelogVersionSelect.disabled = true;
  }
}

function showChangelogVersionControls() {
  if (changelogVersionLabel) changelogVersionLabel.classList.remove('hidden');
  if (changelogVersionSelect) {
    changelogVersionSelect.classList.remove('hidden');
    changelogVersionSelect.disabled = false;
  }
}

function updateModuleChangelogButtonState() {
  if (!changelogShowFullBtn) return;
  const hasSections = Array.isArray(moduleChangelogSections) && moduleChangelogSections.length > 0;
  changelogShowFullBtn.disabled = !hasSections;
  changelogShowFullBtn.textContent = moduleChangelogShowFull
    ? 'Nur neueste Version anzeigen'
    : 'Ganzen Changelog anzeigen';
}

function displayModuleChangelogSections(mode = 'filtered') {
  if (!changelogBodyEl) return;
  const sectionsToShow = mode === 'all' ? moduleChangelogSections : moduleChangelogFilteredSections;
  changelogBodyEl.innerHTML = '';

  if (mode !== 'all' && moduleChangelogNotice) {
    const notice = document.createElement('div');
    notice.className = 'changelog-empty';
    notice.textContent = moduleChangelogNotice;
    changelogBodyEl.appendChild(notice);
  }

  if (!Array.isArray(sectionsToShow) || !sectionsToShow.length) {
    const empty = document.createElement('div');
    empty.className = 'changelog-empty';
    empty.textContent = 'Keine Einträge für den Changelog verfügbar.';
    changelogBodyEl.appendChild(empty);
  } else {
    appendChangelogSections(changelogBodyEl, sectionsToShow);
  }

  changelogBodyEl.scrollTop = 0;
  moduleChangelogShowFull = mode === 'all';
  updateModuleChangelogButtonState();
}

async function openGlobalChangelogModal(initialMode = 'latest') {
  if (!changelogOverlay || !changelogBodyEl) return;

  currentChangelogContext = 'global';
  resetModuleChangelogState();
  showChangelogVersionControls();
  resetGlobalChangelogState();
  lastChangelogTrigger = document.activeElement instanceof HTMLElement ? document.activeElement : null;

  if (changelogTitleEl) {
    changelogTitleEl.textContent = 'Changelog – Shopguide';
  }
  if (changelogSubtitleEl) {
    changelogSubtitleEl.textContent = '';
  }

  if (changelogControlsEl) {
    changelogControlsEl.classList.remove('hidden');
  }
  if (changelogVersionSelect) {
    changelogVersionSelect.innerHTML = '';
  }
  if (changelogShowFullBtn) {
    changelogShowFullBtn.classList.remove('hidden');
  }

  changelogBodyEl.innerHTML = '<div class="changelog-loading">Lade Changelog…</div>';
  changelogOverlay.classList.add('open');
  changelogOverlay.setAttribute('aria-hidden', 'false');

  const requestId = ++changelogRequestToken;

  if (closeChangelogBtn && typeof closeChangelogBtn.focus === 'function') {
    closeChangelogBtn.focus();
  }

  try {
    const sections = await loadHtmlChangelogSections();
    if (requestId !== changelogRequestToken) return;

    if (!sections || !sections.length) {
      changelogBodyEl.innerHTML = '<div class="changelog-empty">Keine Changelog-Daten verfügbar.</div>';
      if (changelogControlsEl) changelogControlsEl.classList.add('hidden');
      updateGlobalChangelogSubtitle('all', null, 0);
      return;
    }

    populateChangelogVersionSelect(sections, 0);
    currentGlobalChangelogIndex = 0;

    if (initialMode === 'all') {
      currentGlobalChangelogMode = 'all';
      displayGlobalChangelogSections(sections, 'all');
    } else {
      currentGlobalChangelogMode = 'single';
      displayGlobalChangelogSections(sections, 'single', 0);
    }
  } catch (err) {
    console.error('Allgemeiner Changelog konnte nicht geladen werden', err);
    if (requestId !== changelogRequestToken) return;
    changelogBodyEl.innerHTML = '<div class="changelog-error">Der Changelog konnte nicht geladen werden.</div>';
    if (changelogControlsEl) changelogControlsEl.classList.add('hidden');
    if (changelogSubtitleEl) changelogSubtitleEl.textContent = '';
  }
}

async function findChangelogFile(dirHandle, relPath = '') {
  if (!dirHandle?.values) return null;
  const entries = [];

  try {
    for await (const entry of dirHandle.values()) {
      entries.push(entry);
    }
  } catch (err) {
    console.warn('Changelog-Dateien konnten nicht gelesen werden', err);
    return null;
  }

  const files = entries
    .filter(entry => entry.kind === 'file')
    .sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));

  for (const file of files) {
    if (file.name.toLowerCase().includes('changelog')) {
      return {
        handle: file,
        name: file.name,
        path: relPath ? `${relPath}/${file.name}` : file.name
      };
    }
  }

  for (const entry of entries) {
    if (entry.kind === 'directory') {
      const childRel = relPath ? `${relPath}/${entry.name}` : entry.name;
      const found = await findChangelogFile(entry, childRel);
      if (found) return found;
    }
  }

  return null;
}

function buildModuleChangelogDisplayPath(baseModulePath, relativeFilePath) {
  if (!relativeFilePath) return null;
  const cleanBase = (baseModulePath || '').replace(/^[\\/]+|[\\/]+$/g, '');
  const cleanFile = relativeFilePath.replace(/^[\\/]+/, '');
  const parts = ['modules'];
  if (cleanBase) parts.push(cleanBase);
  if (cleanFile) parts.push(cleanFile);
  return parts.join('/');
}

async function ensureChangelogHandle(item) {
  if (!item) return null;
  if (item.changelogHandle) return item.changelogHandle;
  if (item.type === 'html') {
    const fileName = item.changelogFileName || HTML_CHANGELOG_FILE;
    if (!fileName) return null;

    const handles = [];
    if (item.updateDirHandle) handles.push(item.updateDirHandle);
    if (updateDirHandle) handles.push(updateDirHandle);
    if (item.localDirHandle) handles.push(item.localDirHandle);
    if (rootDirHandle) handles.push(rootDirHandle);

    const uniqueHandles = [];
    const seenHandles = new Set();
    handles.forEach(handle => {
      if (handle && !seenHandles.has(handle)) {
        seenHandles.add(handle);
        uniqueHandles.push(handle);
      }
    });

    for (const dirHandle of uniqueHandles) {
      if (!dirHandle?.getFileHandle) continue;
      try {
        const handle = await dirHandle.getFileHandle(fileName, { create: false });
        item.changelogHandle = handle;
        item.changelogFileName = fileName;
        if (!item.changelogPath) item.changelogPath = fileName;
        item.changelogRelativePath = null;
        if (!item.updateDirHandle && dirHandle === updateDirHandle) {
          item.updateDirHandle = dirHandle;
        }
        if (!item.localDirHandle && dirHandle === rootDirHandle) {
          item.localDirHandle = dirHandle;
        }
        return handle;
      } catch (err) {
        if (err?.name !== 'NotFoundError') {
          console.warn('HTML-Changelog konnte nicht gelesen werden', err);
        }
      }
    }
    return null;
  }
  if (!item.updateDirHandle && !item.localDirHandle) return null;

  const targets = [];
  if (item.updateDirHandle) {
    targets.push({
      handle: item.updateDirHandle,
      basePath: item.sourceRelPath || item.updateRelPath || item.targetRelPath || ''
    });
  }
  if (item.localDirHandle) {
    const localBase = item.targetRelPath || item.localRelPath || item.sourceRelPath || '';
    targets.push({
      handle: item.localDirHandle,
      basePath: localBase
    });
  }

  for (const target of targets) {
    if (!target?.handle) continue;
    try {
      const info = await findChangelogFile(target.handle);
      if (info?.handle) {
        const relativePath = (info.path || info.name || '').replace(/^[\\/]+/, '');
        const moduleBasePath = target.basePath || item.sourceRelPath || item.targetRelPath || '';
        item.changelogHandle = info.handle;
        item.changelogFileName = info.name;
        item.changelogRelativePath = relativePath || null;
        item.changelogPath = relativePath
          ? buildModuleChangelogDisplayPath(moduleBasePath, relativePath)
          : item.changelogPath || null;
        return item.changelogHandle;
      }
    } catch (err) {
      console.warn('Changelog-Suche fehlgeschlagen', err);
    }
  }

  return null;
}

function updateChangelogSubtitle(item) {
  if (!changelogSubtitleEl) return;
  if (!item) {
    changelogSubtitleEl.textContent = '';
    return;
  }

  const parts = [];
  parts.push(`Versionen: ${formatVersionDisplay(item.currentVersion)} → ${formatVersionDisplay(item.newVersion)}`);
  const moduleBasePath = item.sourceRelPath || item.targetRelPath || '';
  const displayPath = item.changelogPath
    || (item.changelogRelativePath ? buildModuleChangelogDisplayPath(moduleBasePath, item.changelogRelativePath) : null);
  if (displayPath) {
    parts.push(`Datei: ${displayPath}`);
  } else if (item.changelogFileName) {
    parts.push(`Datei: ${item.changelogFileName}`);
  }
  changelogSubtitleEl.textContent = parts.join(' • ');
}

function closeChangelogModal() {
  if (!changelogOverlay) return;
  changelogOverlay.classList.remove('open');
  changelogOverlay.setAttribute('aria-hidden', 'true');
  changelogRequestToken++;
  if (changelogBodyEl) changelogBodyEl.innerHTML = '';
  if (changelogControlsEl) changelogControlsEl.classList.add('hidden');
  resetGlobalChangelogState();
  resetModuleChangelogState();
  currentChangelogContext = 'none';
  showChangelogVersionControls();
  if (lastChangelogTrigger && typeof lastChangelogTrigger.focus === 'function') {
    try { lastChangelogTrigger.focus(); } catch {}
  }
  lastChangelogTrigger = null;
}

async function openChangelogModal(item) {
  if (!item || !changelogOverlay || !changelogBodyEl) return;

  currentChangelogContext = 'module';
  resetGlobalChangelogState();
  resetModuleChangelogState();
  hideChangelogVersionControls();
  if (changelogControlsEl) changelogControlsEl.classList.add('hidden');
  if (changelogShowFullBtn) {
    changelogShowFullBtn.classList.remove('hidden');
    changelogShowFullBtn.disabled = true;
    changelogShowFullBtn.textContent = 'Ganzen Changelog anzeigen';
  }

  lastChangelogTrigger = document.activeElement instanceof HTMLElement ? document.activeElement : null;

  if (changelogTitleEl) {
    const title = item.displayName ? `Changelog – ${item.displayName}` : 'Changelog';
    changelogTitleEl.textContent = title;
  }

  updateChangelogSubtitle(item);

  changelogBodyEl.innerHTML = '<div class="changelog-loading">Lade Changelog…</div>';
  changelogOverlay.classList.add('open');
  changelogOverlay.setAttribute('aria-hidden', 'false');

  const requestId = ++changelogRequestToken;

  if (closeChangelogBtn && typeof closeChangelogBtn.focus === 'function') {
    closeChangelogBtn.focus();
  }

  try {
    const handle = await ensureChangelogHandle(item);
    if (requestId !== changelogRequestToken) return;

    updateChangelogSubtitle(item);

    if (!handle) {
      changelogBodyEl.innerHTML = '<div class="changelog-empty">Keine Changelog-Datei gefunden.</div>';
      return;
    }

    const file = await handle.getFile();
    const text = await file.text();
    if (requestId !== changelogRequestToken) return;

    const sections = parseChangelogSections(text);
    if (requestId !== changelogRequestToken) return;

    moduleChangelogSections = sections;
    moduleChangelogFilteredSections = [];
    moduleChangelogNotice = null;
    moduleChangelogShowFull = false;

    changelogBodyEl.innerHTML = '';

    if (!sections.length) {
      const empty = document.createElement('div');
      empty.className = 'changelog-empty';
      empty.textContent = 'Die Changelog-Datei enthält keine Einträge.';
      changelogBodyEl.appendChild(empty);
      updateModuleChangelogButtonState();
      return;
    }

    let relevantSections = filterChangelogSections(sections, item.currentVersion, item.newVersion);
    if (!Array.isArray(relevantSections)) relevantSections = [];

    if (!relevantSections.length) {
      const normalizedTargetVersion = normalizeVersionValue(item.newVersion);
      const matchingSection = normalizedTargetVersion
        ? sections.find(sec => sec.version === normalizedTargetVersion)
        : null;

      if (matchingSection) {
        relevantSections = [matchingSection];
      } else {
        moduleChangelogNotice = 'Keine Einträge für den Versionsbereich gefunden. Vollständiger Changelog wird angezeigt.';
        relevantSections = sections;
      }
    }

    moduleChangelogFilteredSections = relevantSections;

    if (changelogControlsEl) {
      changelogControlsEl.classList.remove('hidden');
    }
    hideChangelogVersionControls();
    if (changelogShowFullBtn) {
      changelogShowFullBtn.classList.remove('hidden');
    }

    displayModuleChangelogSections('filtered');
  } catch (err) {
    console.error('Changelog konnte nicht geladen werden', err);
    if (requestId !== changelogRequestToken) return;
    changelogBodyEl.innerHTML = '<div class="changelog-error">Der Changelog konnte nicht gelesen werden.</div>';
  }
}

if (closeChangelogBtn) {
  closeChangelogBtn.addEventListener('click', closeChangelogModal);
}
if (changelogOverlay) {
  changelogOverlay.addEventListener('click', event => {
    if (event.target === changelogOverlay) {
      closeChangelogModal();
    }
  });
}
document.addEventListener('keydown', event => {
  if (event.key !== 'Escape') return;
  let handled = false;

  if (historyMenuOpen) {
    handled = closeHistoryMenu() || handled;
  }

  if (settingsModal && !settingsModal.classList.contains('hidden')) {
    handled = hideSettingsModal() || handled;
  }

  if (changelogOverlay?.classList.contains('open')) {
    closeChangelogModal();
    handled = true;
  }

  if (handled) {
    event.preventDefault();
    event.stopPropagation();
  }
});

if (showLatestChangelogBtn) {
  showLatestChangelogBtn.addEventListener('click', () => {
    openGlobalChangelogModal('latest');
  });
}

if (changelogVersionSelect) {
  changelogVersionSelect.addEventListener('change', () => {
    if (!Array.isArray(cachedHtmlChangelogSections) || !cachedHtmlChangelogSections.length) return;
    const index = Number(changelogVersionSelect.value);
    if (Number.isNaN(index)) return;
    currentGlobalChangelogIndex = Math.max(0, Math.min(cachedHtmlChangelogSections.length - 1, index));
    currentGlobalChangelogMode = 'single';
    displayGlobalChangelogSections(cachedHtmlChangelogSections, 'single', currentGlobalChangelogIndex);
  });
}

if (changelogShowFullBtn) {
  changelogShowFullBtn.addEventListener('click', () => {
    if (currentChangelogContext === 'module') {
      if (!Array.isArray(moduleChangelogSections) || !moduleChangelogSections.length) return;
      const nextMode = moduleChangelogShowFull ? 'filtered' : 'all';
      displayModuleChangelogSections(nextMode);
      return;
    }

    if (!Array.isArray(cachedHtmlChangelogSections) || !cachedHtmlChangelogSections.length) return;
    currentGlobalChangelogMode = 'all';
    displayGlobalChangelogSections(cachedHtmlChangelogSections, 'all');
  });
}

function setUpdateStatusButton(state) {
  if (!updateStatusBtn) return;

  if (state === 'checking') {
    if (appSettings.showUpdateStatusButton === false || updateStatusShouldRemainHidden) {
      return;
    }
    updateStatusBtn.classList.remove('hidden');
    updateStatusBtn.removeAttribute('aria-hidden');
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('cursor-wait');
    updateStatusBtn.setAttribute('aria-busy', 'true');
    if (!updateStatusHasStableAppearance) {
      updateStatusBtn.className = UPDATE_STATUS_BASE_CLASSES;
      updateStatusBtn.textContent = 'Prüfe…';
      updateStatusBtn.title = '';
      updateStatusBtn.classList.add('bg-gray-300','text-gray-700');
    }
    return;
  }

  updateStatusBtn.removeAttribute('aria-busy');
  updateStatusBtn.classList.remove('cursor-wait');
  updateStatusBtn.disabled = false;
  updateStatusBtn.title = '';
  updateStatusBtn.className = UPDATE_STATUS_BASE_CLASSES;

  updateStatusHasStableAppearance = true;
  updateStatusShouldRemainHidden = false;

  if (appSettings.showUpdateStatusButton === false) {
    updateStatusShouldRemainHidden = true;
    updateStatusHasStableAppearance = false;
    updateStatusBtn.classList.add('hidden');
    updateStatusBtn.setAttribute('aria-hidden', 'true');
    updateStatusBtn.disabled = true;
    updateStatusBtn.textContent = '';
    return;
  }

  updateStatusBtn.classList.remove('hidden');
  updateStatusBtn.removeAttribute('aria-hidden');

  if (pendingRootPermission) {
    updateStatusBtn.textContent = 'Arbeitsordner entsperren';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-yellow-500','text-gray-900','cursor-not-allowed');
    return;
  }

  if (pendingUpdatePermission) {
    updateStatusBtn.textContent = 'Update-Ordner entsperren';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-yellow-500','text-gray-900','cursor-not-allowed');
    return;
  }

  if (!rootDirHandle) {
    updateStatusBtn.textContent = 'Kein Arbeitsordner';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-gray-300','text-gray-700','cursor-not-allowed');
    return;
  }

  if (!updateDirHandle) {
    updateStatusBtn.textContent = 'Kein Update-Ordner';
    updateStatusBtn.disabled = true;
    updateStatusBtn.classList.add('bg-gray-300','text-gray-700','cursor-not-allowed');
    return;
  }

  if (lastUpdateError) {
    updateStatusBtn.textContent = 'Prüfung fehlgeschlagen';
    updateStatusBtn.classList.add('bg-yellow-500','hover:bg-yellow-600','text-white');
    return;
  }

  let upgradeCount = currentUpgradeItems.length;
  let downgradeCount = currentDowngradeItems.length;

  if (!upgradeCount && !downgradeCount && pendingUpdates.length) {
    pendingUpdates.forEach(item => {
      const comparison = compareVersions(item.currentVersion, item.newVersion);
      if (comparison === 1) {
        if (!isDowngradeIgnored(item)) downgradeCount += 1;
      } else {
        upgradeCount += 1;
      }
    });
  }

  if (upgradeCount) {
    updateStatusBtn.textContent = 'Update available!';
    if (downgradeCount) {
      updateStatusBtn.title = `${upgradeCount} Upgrade${upgradeCount === 1 ? '' : 's'} und ${downgradeCount} Downgrade${downgradeCount === 1 ? '' : 's'} verfügbar.`;
    } else if (upgradeCount > 1) {
      updateStatusBtn.title = `${upgradeCount} Updates verfügbar.`;
    }
    updateStatusBtn.classList.add('bg-red-600','hover:bg-red-700','text-white');
    return;
  }

  if (downgradeCount) {
    if (appSettings.hideDowngradeStatusButton) {
      updateStatusShouldRemainHidden = true;
      updateStatusHasStableAppearance = false;
      updateStatusBtn.classList.add('hidden');
      updateStatusBtn.setAttribute('aria-hidden', 'true');
      updateStatusBtn.disabled = true;
      updateStatusBtn.textContent = '';
      updateStatusBtn.title = '';
      return;
    }
    updateStatusBtn.textContent = 'Nur Downgrades verfügbar';
    updateStatusBtn.title = downgradeCount === 1 ? 'Ein Downgrade verfügbar.' : `${downgradeCount} Downgrades verfügbar.`;
    updateStatusBtn.classList.add('bg-yellow-400','hover:bg-yellow-500','text-gray-900','border-yellow-500');
    return;
  }

  updateStatusBtn.textContent = 'Up to date!';
  updateStatusBtn.classList.add('bg-green-600','hover:bg-green-700','text-white');
}

function renderUpdateList() {
  if (!updatesTableBody || !updatesEmptyState) return;
  updatesTableBody.innerHTML = '';
  if (downgradeTableBody) downgradeTableBody.innerHTML = '';
  currentUpgradeItems = [];
  currentDowngradeItems = [];
  if (downgradeSection) downgradeSection.classList.add('hidden');
  if (updateAllContainer) updateAllContainer.classList.add('hidden');
  if (updateAllBtn) {
    updateAllBtn.disabled = true;
    updateAllBtn.textContent = 'Alle aktualisieren';
    updateAllBtn.classList.remove('opacity-60','cursor-wait','cursor-not-allowed');
  }
  if (pendingRootPermission) {
    updatesEmptyState.textContent = 'Bitte erlauben Sie den Zugriff auf den Arbeitsordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    setUpdateStatusButton();
    return;
  }
  if (pendingUpdatePermission) {
    updatesEmptyState.textContent = 'Bitte erlauben Sie den Zugriff auf den Update-Ordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    setUpdateStatusButton();
    return;
  }
  if (!rootDirHandle) {
    updatesEmptyState.textContent = 'Bitte wählen Sie einen Arbeitsordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    renderVersionOverview();
    setUpdateStatusButton();
    return;
  }

  if (!updateDirHandle) {
    updatesEmptyState.textContent = 'Bitte wählen Sie einen Update-Ordner.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    renderVersionOverview();
    setUpdateStatusButton();
    return;
  }

  if (!pendingUpdates.length) {
    updatesEmptyState.textContent = 'Keine Updates erforderlich.';
    updatesEmptyState.classList.remove('hidden');
    if (updateCheckStatus && !lastUpdateError) updateCheckStatus.textContent = 'Keine Updates erforderlich.';
    renderVersionOverview();
    setUpdateStatusButton();
    return;
  }

  const upgrades = [];
  const downgrades = [];
  pendingUpdates.forEach(item => {
    const comparison = compareVersions(item.currentVersion, item.newVersion);
    if (comparison === 1) {
      if (!isDowngradeIgnored(item)) {
        downgrades.push(item);
      }
    } else {
      upgrades.push(item);
    }
  });

  currentUpgradeItems = upgrades;
  currentDowngradeItems = downgrades;

  const upgradeCount = upgrades.length;
  const downgradeCount = downgrades.length;

  if (updateCheckStatus && !lastUpdateError) {
    if (upgradeCount && downgradeCount) {
      updateCheckStatus.textContent = `${upgradeCount} Upgrade${upgradeCount === 1 ? '' : 's'} und ${downgradeCount} Downgrade${downgradeCount === 1 ? '' : 's'} gefunden.`;
    } else if (upgradeCount) {
      updateCheckStatus.textContent = `${upgradeCount} Upgrade${upgradeCount === 1 ? '' : 's'} verfügbar.`;
    } else {
      updateCheckStatus.textContent = `${downgradeCount} Downgrade${downgradeCount === 1 ? '' : 's'} gefunden.`;
    }
  }

  if (upgradeCount) {
    updatesEmptyState.classList.add('hidden');
  } else {
    updatesEmptyState.textContent = downgradeCount
      ? 'Keine Upgrades erforderlich. Downgrades siehe unten.'
      : 'Keine Updates erforderlich.';
    updatesEmptyState.classList.remove('hidden');
  }

  if (updateAllContainer) updateAllContainer.classList.toggle('hidden', !upgradeCount);
  if (updateAllBtn) {
    updateAllBtn.disabled = !upgradeCount;
    updateAllBtn.textContent = 'Alle aktualisieren';
  }

  upgrades.forEach((item, index) => {
    const tr = document.createElement('tr');
    tr.className = index % 2 ? 'bg-white' : 'bg-gray-50';

    const tdPath = document.createElement('td');
    tdPath.className = 'px-3 py-2 align-top';
    tdPath.textContent = item.displayName || item.path;

    const tdVersion = document.createElement('td');
    tdVersion.className = 'px-3 py-2 align-top whitespace-nowrap';
    tdVersion.textContent = `${formatVersionDisplay(item.currentVersion)} → ${formatVersionDisplay(item.newVersion)}`;

    const tdAction = document.createElement('td');
    tdAction.className = 'px-3 py-2 align-top';
    const actionWrapper = document.createElement('div');
    actionWrapper.className = 'flex justify-end flex-wrap gap-2';

    if (item.type === 'module' || item.type === 'html') {
      const changelogBtn = document.createElement('button');
      changelogBtn.type = 'button';
      changelogBtn.className = 'bg-white border border-gray-300 text-gray-800 px-3 py-1 rounded hover:bg-gray-100';
      changelogBtn.textContent = 'Changelog';
      changelogBtn.addEventListener('click', () => {
        openChangelogModal(item);
      });
      actionWrapper.appendChild(changelogBtn);
    }

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded';
    btn.textContent = 'sync';
    btn.addEventListener('click', async () => {
      btn.disabled = true;
      btn.classList.add('opacity-60','cursor-wait');
      try {
        await applySingleUpdate(item);
      } catch (err) {
        console.error('Fehler beim Aktualisieren', err);
        alert('Die Datei konnte nicht aktualisiert werden.');
      } finally {
        btn.disabled = false;
        btn.classList.remove('opacity-60','cursor-wait');
      }
    });
    actionWrapper.appendChild(btn);

    tdAction.appendChild(actionWrapper);

    tr.appendChild(tdPath);
    tr.appendChild(tdVersion);
    tr.appendChild(tdAction);
    updatesTableBody.appendChild(tr);
  });

  if (downgradeSection) {
    if (downgradeCount) {
      downgradeSection.classList.remove('hidden');
      if (downgradeHeading) downgradeHeading.textContent = `Downgrades (${downgradeCount})`;
      downgrades.forEach(item => {
        const tr = document.createElement('tr');
        tr.className = 'bg-yellow-100';

        const tdPath = document.createElement('td');
        tdPath.className = 'px-3 py-2 align-top';
        tdPath.textContent = item.displayName || item.path;

        const tdVersion = document.createElement('td');
        tdVersion.className = 'px-3 py-2 align-top whitespace-nowrap';
        tdVersion.textContent = `${formatVersionDisplay(item.currentVersion)} → ${formatVersionDisplay(item.newVersion)}`;

        const tdAction = document.createElement('td');
        tdAction.className = 'px-3 py-2 align-top';
        const actionWrapper = document.createElement('div');
        actionWrapper.className = 'flex justify-end flex-wrap gap-2';

        if (item.type === 'module' || item.type === 'html') {
          const changelogBtn = document.createElement('button');
          changelogBtn.type = 'button';
          changelogBtn.className = 'bg-white border border-yellow-300 text-yellow-900 px-3 py-1 rounded hover:bg-yellow-200';
          changelogBtn.textContent = 'Changelog';
          changelogBtn.addEventListener('click', () => {
            openChangelogModal(item);
          });
          actionWrapper.appendChild(changelogBtn);
        }

        const ignoreBtn = document.createElement('button');
        ignoreBtn.type = 'button';
        ignoreBtn.className = 'bg-white border border-yellow-300 text-yellow-900 px-3 py-1 rounded hover:bg-yellow-200';
        ignoreBtn.textContent = 'Ignorieren';
        ignoreBtn.addEventListener('click', () => {
          markDowngradeIgnored(item);
          renderUpdateList();
        });
        actionWrapper.appendChild(ignoreBtn);

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'bg-yellow-500 hover:bg-yellow-600 text-yellow-900 px-3 py-1 rounded';
        btn.textContent = 'sync';
        btn.addEventListener('click', async () => {
          if (!confirm('Diese Version ist älter. Trotzdem synchronisieren?')) return;
          btn.disabled = true;
          btn.classList.add('opacity-60','cursor-wait');
          try {
            await applySingleUpdate(item);
          } catch (err) {
            console.error('Fehler beim Aktualisieren', err);
            alert('Die Datei konnte nicht aktualisiert werden.');
          } finally {
            btn.disabled = false;
            btn.classList.remove('opacity-60','cursor-wait');
          }
        });
        actionWrapper.appendChild(btn);

        tdAction.appendChild(actionWrapper);

        tr.appendChild(tdPath);
        tr.appendChild(tdVersion);
        tr.appendChild(tdAction);
        downgradeTableBody?.appendChild(tr);
      });
      updateDowngradeCollapseUI();
    } else {
      downgradeSection.classList.add('hidden');
      if (downgradeHeading) downgradeHeading.textContent = 'Downgrades (0)';
    }
  }

  renderVersionOverview();
  setUpdateStatusButton();
}

function updateDowngradeCollapseUI() {
  if (!downgradeContent || !downgradeToggleIcon) return;
  downgradeContent.classList.toggle('hidden', downgradeCollapsed);
  downgradeToggleIcon.textContent = downgradeCollapsed ? '▼' : '▲';
}

function prepareHtmlChangelogItem(info) {
  if (!info) return null;
  const prepared = info;
  prepared.type = 'html';
  if (!prepared.displayName) {
    prepared.displayName = info.updateFileName || info.localFileName || HTML_FILE_NAME;
  }
  if (!prepared.name) {
    prepared.name = prepared.displayName;
  }
  const resolvedCurrent = (typeof info.localVersion === 'undefined')
    ? (prepared.currentVersion ?? null)
    : (info.localVersion ?? null);
  prepared.currentVersion = resolvedCurrent;
  const hasUpdateVersion = typeof info.updateVersion !== 'undefined' && info.updateVersion !== null;
  const resolvedTarget = hasUpdateVersion ? info.updateVersion : resolvedCurrent;
  prepared.newVersion = resolvedTarget;
  if (!prepared.sourcePath) {
    prepared.sourcePath = info.updateFileName || info.localFileName || HTML_FILE_NAME;
  }
  if (!prepared.targetPath) {
    prepared.targetPath = info.localFileName || HTML_FILE_NAME;
  }
  if (!prepared.updateDirHandle && updateDirHandle) {
    prepared.updateDirHandle = updateDirHandle;
  }
  if (!prepared.localDirHandle && rootDirHandle) {
    prepared.localDirHandle = rootDirHandle;
  }
  if (!prepared.changelogHandle && htmlUpdateChangelogHandle) {
    prepared.changelogHandle = htmlUpdateChangelogHandle;
    if (!prepared.changelogFileName) {
      prepared.changelogFileName = htmlUpdateChangelogFileName || HTML_CHANGELOG_FILE;
    }
  }
  if (!prepared.changelogFileName) {
    prepared.changelogFileName = HTML_CHANGELOG_FILE;
  }
  if (!prepared.changelogPath) {
    prepared.changelogPath = prepared.changelogFileName;
  }
  prepared.changelogRelativePath = null;
  return prepared;
}

function prepareModuleChangelogItem(mod) {
  if (!mod) return null;
  const prepared = mod;
  if (!prepared.type) prepared.type = 'module';
  if (!prepared.displayName) prepared.displayName = prepared.name || prepared.moduleId || 'Modul';
  prepared.currentVersion = typeof prepared.localVersion === 'undefined' ? null : prepared.localVersion;
  prepared.newVersion = typeof prepared.updateVersion === 'undefined' || prepared.updateVersion === null
    ? (prepared.localVersion ?? null)
    : prepared.updateVersion;
  if (!prepared.sourceRelPath) {
    prepared.sourceRelPath = prepared.updateRelPath || prepared.localRelPath || null;
  }
  if (!prepared.targetRelPath) {
    prepared.targetRelPath = prepared.localRelPath || prepared.updateRelPath || null;
  }
  return prepared;
}

function createHtmlOverviewChangelogButton(htmlInfo) {
  if (!htmlInfo) return null;
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'version-overview-button';
  const label = htmlInfo.displayName || htmlInfo.updateFileName || htmlInfo.localFileName || HTML_FILE_NAME;
  btn.textContent = 'Changelog';
  btn.title = `Changelog für ${label} anzeigen`;
  btn.addEventListener('click', () => {
    const item = prepareHtmlChangelogItem(htmlInfo);
    if (!item) return;
    openChangelogModal(item);
  });
  return btn;
}

function createModuleOverviewChangelogButton(mod) {
  if (!mod) return null;
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'version-overview-button';
  btn.textContent = 'Changelog';
  btn.title = `Changelog für ${mod.name || mod.moduleId || 'Modul'} anzeigen`;
  btn.addEventListener('click', () => {
    const item = prepareModuleChangelogItem(mod);
    if (!item) return;
    openChangelogModal(item);
  });
  return btn;
}

function renderVersionOverview() {
  if (!versionOverviewContainer || !versionOverviewRowsEl) return;
  const htmlInfo = versionOverview?.html || { localVersion: null, updateVersion: null };
  const modulesInfo = Array.isArray(versionOverview?.modules) ? versionOverview.modules : [];

  versionOverviewRowsEl.innerHTML = '';

  const headerName = document.createElement('div');
  headerName.className = 'version-overview-header';
  headerName.textContent = 'Datei';
  const headerLocal = document.createElement('div');
  headerLocal.className = 'version-overview-header text-right';
  headerLocal.textContent = 'Aktuell';
  const headerUpdate = document.createElement('div');
  headerUpdate.className = 'version-overview-header text-right';
  headerUpdate.textContent = 'Update';
  const headerActions = document.createElement('div');
  headerActions.className = 'version-overview-header text-right';
  headerActions.textContent = 'Changelog';
  versionOverviewRowsEl.append(headerName, headerLocal, headerUpdate, headerActions);

  const addRow = (label, localValue, updateValue, actionElement = null) => {
    const nameEl = document.createElement('div');
    nameEl.className = 'version-overview-name';
    nameEl.textContent = label;

    const localEl = document.createElement('div');
    localEl.className = 'version-overview-value';
    localEl.textContent = localValue;

    const updateEl = document.createElement('div');
    updateEl.className = 'version-overview-value';
    updateEl.textContent = updateValue;

    const actionEl = document.createElement('div');
    actionEl.className = 'version-overview-action';
    if (actionElement) {
      actionEl.appendChild(actionElement);
    }

    versionOverviewRowsEl.append(nameEl, localEl, updateEl, actionEl);
  };

  const htmlLabel = htmlInfo.updateFileName || htmlInfo.localFileName || HTML_FILE_NAME;
  const htmlButton = createHtmlOverviewChangelogButton(htmlInfo);
  addRow(
    `HTML (${htmlLabel})`,
    formatVersionDisplay(htmlInfo.localVersion),
    formatVersionDisplay(htmlInfo.updateVersion),
    htmlButton
  );

  if (!modulesInfo.length) {
    const emptyEl = document.createElement('div');
    emptyEl.className = 'version-overview-empty';
    emptyEl.textContent = 'Keine Module gefunden.';
    versionOverviewRowsEl.appendChild(emptyEl);
    return;
  }

  modulesInfo.forEach(mod => {
    const actionButton = createModuleOverviewChangelogButton(mod);
    addRow(
      mod.name,
      formatVersionDisplay(mod.localVersion),
      formatVersionDisplay(mod.updateVersion),
      actionButton
    );
  });
}

async function readHtmlVersion(rootHandle) {
  if (!rootHandle) return null;

  const readFromHandle = async (fileHandle, fileName) => {
    const file = await fileHandle.getFile();
    const text = await file.text();
    const match = text.match(/<!--\s*Version:\s*([^>]+?)\s*-->/i);
    const version = match ? match[1].trim() : null;
    return { version, fileHandle, fileName };
  };

  try {
    const fileHandle = await rootHandle.getFileHandle(HTML_FILE_NAME, { create: false });
    return await readFromHandle(fileHandle, HTML_FILE_NAME);
  } catch (e) {
    if (e?.name !== 'NotFoundError') {
      console.warn('HTML-Version konnte nicht gelesen werden', e);
      return null;
    }
  }

  const htmlCandidates = [];
  try {
    for await (const entry of rootHandle.values()) {
      if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.html')) {
        htmlCandidates.push(entry.name);
        if (htmlCandidates.length > 1) break;
      }
    }
  } catch (err) {
    console.warn('HTML-Dateien konnten nicht ermittelt werden', err);
    return null;
  }

  if (htmlCandidates.length === 1) {
    const fallbackName = htmlCandidates[0];
    try {
      const fileHandle = await rootHandle.getFileHandle(fallbackName, { create: false });
      return await readFromHandle(fileHandle, fallbackName);
    } catch (err) {
      console.warn('Fallback-HTML-Version konnte nicht gelesen werden', err);
      return null;
    }
  }

  return null;
}

async function gatherModulesMetadata(rootHandle) {
  const modules = new Map();
  if (!rootHandle) return { modules };
  let modulesRoot;
  try {
    modulesRoot = await rootHandle.getDirectoryHandle('modules', { create: false });
  } catch {
    return { modules };
  }

  async function walk(dirHandle, relPath) {
    const entries = [];
    for await (const entry of dirHandle.values()) entries.push(entry);

    let moduleData = null;
    for (const entry of entries) {
      if (entry.kind === 'file' && entry.name.endsWith('.json')) {
        try {
          const file = await entry.getFile();
          const parsed = JSON.parse(await file.text());
          if (parsed && typeof parsed === 'object') {
            const moduleId = parsed.moduleId || parsed.id || parsed.name || relPath;
            if (moduleId) {
              moduleData = {
                moduleId,
                version: parsed.version ?? null,
                name: parsed.name || moduleId,
                relPath,
                dirHandle,
                raw: parsed
              };
              break;
            }
          }
        } catch (e) {
          console.warn('Modul-Metadaten konnten nicht gelesen werden', e);
        }
      }
    }

    if (moduleData) {
      const versionValue = moduleData.version;
      modules.set(moduleData.moduleId, {
        moduleId: moduleData.moduleId,
        version: versionValue === null || typeof versionValue === 'undefined' ? null : String(versionValue),
        name: moduleData.name,
        relPath,
        dirHandle
      });
    }

    for (const entry of entries) {
      if (entry.kind === 'directory') {
        const childRel = relPath ? `${relPath}/${entry.name}` : entry.name;
        await walk(entry, childRel);
      }
    }
  }

  await walk(modulesRoot, '');
  return { modules };
}

async function collectVersionDiffs(updateHandle, localHandle) {
  const overview = {
    html: {
      localVersion: null,
      updateVersion: null,
      localFileName: HTML_FILE_NAME,
      updateFileName: null
    },
    modules: []
  };
  const diffs = [];

  let localHtml = null;
  let updateHtml = null;
  let htmlChangelogHandle = null;
  try { localHtml = await readHtmlVersion(localHandle); } catch {}
  try { updateHtml = await readHtmlVersion(updateHandle); } catch {}

  if (updateHandle?.getFileHandle) {
    try {
      htmlChangelogHandle = await updateHandle.getFileHandle(HTML_CHANGELOG_FILE, { create: false });
    } catch (err) {
      if (err?.name !== 'NotFoundError') {
        console.warn('HTML-Changelog konnte nicht gelesen werden', err);
      }
    }
  }

  if (localHtml) {
    overview.html.localVersion = localHtml.version || null;
    overview.html.localFileName = localHtml.fileName || HTML_FILE_NAME;
  }
  if (updateHtml) {
    overview.html.updateVersion = updateHtml.version || null;
    overview.html.updateFileName = updateHtml.fileName || null;
  }

  const htmlDisplayName = updateHtml?.fileName || overview.html.updateFileName || overview.html.localFileName || HTML_FILE_NAME;
  Object.assign(overview.html, {
    type: 'html',
    name: htmlDisplayName,
    displayName: htmlDisplayName,
    currentVersion: overview.html.localVersion ?? null,
    newVersion: (typeof overview.html.updateVersion !== 'undefined' && overview.html.updateVersion !== null)
      ? overview.html.updateVersion
      : (overview.html.localVersion ?? null),
    sourcePath: updateHtml?.fileName || overview.html.updateFileName || overview.html.localFileName || HTML_FILE_NAME,
    targetPath: localHtml?.fileName || overview.html.localFileName || HTML_FILE_NAME,
    updateDirHandle: updateHandle || null,
    localDirHandle: localHandle || null,
    changelogHandle: htmlChangelogHandle || null,
    changelogFileName: HTML_CHANGELOG_FILE,
    changelogPath: HTML_CHANGELOG_FILE,
    changelogRelativePath: null
  });

  if (updateHtml && (updateHtml.version || !localHtml)) {
    const localVersion = localHtml?.version || null;
    if (localVersion !== updateHtml.version) {
      const sourceFileName = updateHtml.fileName || HTML_FILE_NAME;
      diffs.push({
        type: 'html',
        path: sourceFileName,
        displayName: sourceFileName,
        currentVersion: localVersion,
        newVersion: updateHtml.version || null,
        sourcePath: sourceFileName,
        targetPath: localHtml?.fileName || HTML_FILE_NAME,
        updateDirHandle: updateHandle || null,
        changelogHandle: htmlChangelogHandle || null,
        changelogFileName: htmlChangelogHandle ? HTML_CHANGELOG_FILE : null,
        changelogPath: htmlChangelogHandle ? HTML_CHANGELOG_FILE : null,
        changelogRelativePath: null
      });
    }
  }

  const localModules = await gatherModulesMetadata(localHandle);
  const updateModules = await gatherModulesMetadata(updateHandle);
  const moduleIds = new Set([
    ...Array.from(localModules.modules.keys()),
    ...Array.from(updateModules.modules.keys())
  ]);

  const modulesList = [];
  for (const moduleId of moduleIds) {
    const localMeta = localModules.modules.get(moduleId) || null;
    const updateMeta = updateModules.modules.get(moduleId) || null;
    const name = updateMeta?.name || localMeta?.name || moduleId;
    const localVersion = localMeta?.version || null;
    const updateVersion = updateMeta?.version || null;
    const moduleEntry = {
      type: 'module',
      moduleId,
      name,
      displayName: name,
      localVersion,
      updateVersion,
      currentVersion: localVersion,
      newVersion: updateVersion ?? localVersion,
      updateRelPath: updateMeta?.relPath || null,
      localRelPath: localMeta?.relPath || null,
      sourceRelPath: updateMeta?.relPath || null,
      targetRelPath: localMeta?.relPath || updateMeta?.relPath || null,
      updateDirHandle: updateMeta?.dirHandle || null,
      localDirHandle: localMeta?.dirHandle || null,
      changelogHandle: null,
      changelogFileName: null,
      changelogPath: null,
      changelogRelativePath: null
    };
    modulesList.push(moduleEntry);

    if (updateMeta && (localVersion !== updateVersion)) {
      const changelogInfo = updateMeta?.dirHandle ? await findChangelogFile(updateMeta.dirHandle) : null;
      const changelogRelativePath = (changelogInfo?.path || changelogInfo?.name || '').replace(/^[\\/]+/, '');
      const changelogDisplayPath = changelogInfo && changelogRelativePath
        ? buildModuleChangelogDisplayPath(updateMeta?.relPath || '', changelogRelativePath)
        : null;
      if (changelogInfo?.handle) {
        moduleEntry.changelogHandle = changelogInfo.handle;
        moduleEntry.changelogFileName = changelogInfo.name || null;
        moduleEntry.changelogRelativePath = changelogRelativePath || null;
        moduleEntry.changelogPath = changelogDisplayPath;
      }
      diffs.push({
        type: 'module',
        moduleId,
        path: updateMeta.relPath ? `modules/${updateMeta.relPath}` : `modules/${moduleId}`,
        displayName: name,
        currentVersion: localVersion,
        newVersion: updateVersion,
        sourceRelPath: updateMeta.relPath,
        targetRelPath: localMeta?.relPath || updateMeta.relPath,
        updateDirHandle: updateMeta.dirHandle,
        localDirHandle: localMeta?.dirHandle || null,
        changelogHandle: changelogInfo?.handle || null,
        changelogFileName: changelogInfo?.name || null,
        changelogPath: changelogDisplayPath,
        changelogRelativePath: changelogRelativePath || null
      });
    }
  }

  modulesList.sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));
  overview.modules = modulesList;

  diffs.sort((a, b) => {
    const nameA = (a.displayName || a.path || '').toLowerCase();
    const nameB = (b.displayName || b.path || '').toLowerCase();
    return nameA.localeCompare(nameB, 'de', { sensitivity: 'base' });
  });

  return {
    diffs,
    overview,
    htmlChangelogHandle: htmlChangelogHandle || null,
    htmlChangelogFileName: htmlChangelogHandle ? HTML_CHANGELOG_FILE : null
  };
}

async function ensureDirectoryChain(root, parts, { create = true } = {}) {
  let current = root;
  for (const part of parts) {
    if (!part) continue;
    current = await current.getDirectoryHandle(part, { create });
  }
  return current;
}

async function applySingleUpdate(item, { skipRecheck = false } = {}) {
  if (!rootDirHandle) return;
  if (!item) return;

  try {
    if (item.type === 'html') {
      if (!updateDirHandle) throw new Error('Kein Update-Ordner vorhanden.');
      const sourceFileName = item.sourcePath || HTML_FILE_NAME;
      const updateFileHandle = await updateDirHandle.getFileHandle(sourceFileName, { create: false });
      const updateFile = await updateFileHandle.getFile();
      const targetFileHandle = await rootDirHandle.getFileHandle(sourceFileName, { create: true });
      const writable = await targetFileHandle.createWritable();
      await writable.write(await updateFile.arrayBuffer());
      await writable.close();
      await removeOtherHtmlFiles(rootDirHandle, sourceFileName);
    } else if (item.type === 'module') {
      if (!updateDirHandle) throw new Error('Kein Update-Ordner vorhanden.');
      const sourceSegments = ['modules', ...(item.sourceRelPath ? item.sourceRelPath.split('/') : [])];
      const targetSegments = ['modules', ...(item.targetRelPath ? item.targetRelPath.split('/') : [])];
      const sourceDir = await ensureDirectoryChain(updateDirHandle, sourceSegments, { create: false });
      const targetDir = await ensureDirectoryChain(rootDirHandle, targetSegments, { create: true });
      await syncDirectoryContents(sourceDir, targetDir);
    } else if (item.sourcePath) {
      if (!updateDirHandle) throw new Error('Kein Update-Ordner vorhanden.');
      const segments = item.sourcePath.split('/');
      const fileName = segments.pop();
      const sourceDir = await ensureDirectoryChain(updateDirHandle, segments, { create: false });
      const updateFileHandle = await sourceDir.getFileHandle(fileName, { create: false });
      const targetDir = await ensureDirectoryChain(rootDirHandle, segments, { create: true });
      const targetFileHandle = await targetDir.getFileHandle(fileName, { create: true });
      const updateFile = await updateFileHandle.getFile();
      const writable = await targetFileHandle.createWritable();
      await writable.write(await updateFile.arrayBuffer());
      await writable.close();
    }
  } catch (err) {
    console.error('Fehler beim Synchronisieren', err);
    throw err;
  }

  if (!skipRecheck) {
    await runUpdateCheck();
  }
}

async function syncDirectoryContents(sourceDir, targetDir) {
  const sourceEntries = new Map();
  for await (const entry of sourceDir.values()) {
    sourceEntries.set(entry.name, entry);
  }

  const targetEntries = [];
  for await (const entry of targetDir.values()) {
    targetEntries.push(entry);
  }

  for (const entry of targetEntries) {
    if (!sourceEntries.has(entry.name)) {
      try {
        await targetDir.removeEntry(entry.name, { recursive: true });
      } catch (err) {
        if (err?.name !== 'NotFoundError') {
          console.warn('Eintrag konnte nicht entfernt werden', err);
        }
      }
    }
  }

  for (const [name, entry] of sourceEntries.entries()) {
    if (entry.kind === 'file') {
      const file = await entry.getFile();
      const targetFileHandle = await targetDir.getFileHandle(name, { create: true });
      const writable = await targetFileHandle.createWritable();
      await writable.write(await file.arrayBuffer());
      await writable.close();
    } else if (entry.kind === 'directory') {
      const subTarget = await targetDir.getDirectoryHandle(name, { create: true });
      await syncDirectoryContents(entry, subTarget);
    }
  }
}

async function removeOtherHtmlFiles(rootHandle, keepFileName) {
  if (!rootHandle) return;
  const toRemove = [];
  for await (const entry of rootHandle.values()) {
    if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.html') && entry.name !== keepFileName) {
      toRemove.push(entry.name);
    }
  }

  for (const name of toRemove) {
    try {
      await rootHandle.removeEntry(name);
    } catch (err) {
      if (err?.name !== 'NotFoundError') {
        console.warn(`Konnte HTML-Datei ${name} nicht entfernen`, err);
      }
    }
  }
}

async function runUpdateCheck() {
  if (updateCheckInProgress) {
    rerunUpdateCheckWhenUnlocked = true;
    return;
  }
  lastUpdateError = false;

  if (pendingRootPermission || pendingUpdatePermission) {
    rerunUpdateCheckWhenUnlocked = true;
    renderUpdateList();
    setUpdateStatusButton();
    return;
  }

  if (!rootDirHandle && !updateDirHandle) {
    versionOverview = {
      html: {
        localVersion: null,
        updateVersion: null,
        localFileName: HTML_FILE_NAME,
        updateFileName: null
      },
      modules: []
    };
    htmlUpdateChangelogHandle = null;
    htmlUpdateChangelogFileName = null;
    cachedHtmlChangelogSections = null;
    htmlChangelogSourceLabel = null;
    pendingUpdates = [];
    rerunUpdateCheckWhenUnlocked = false;
    if (updateCheckStatus) updateCheckStatus.textContent = '';
    renderUpdateList();
    return;
  }

  if (rootDirHandle && updateDirHandle) {
    updateCheckInProgress = true;
    rerunUpdateCheckWhenUnlocked = false;
    setUpdateStatusButton('checking');
    if (updateCheckStatus) updateCheckStatus.textContent = 'Prüfung läuft…';
  } else {
    rerunUpdateCheckWhenUnlocked = false;
  }

  try {
    const result = await collectVersionDiffs(updateDirHandle, rootDirHandle);
    versionOverview = result.overview;
    pendingUpdates = rootDirHandle && updateDirHandle ? result.diffs : [];
    htmlUpdateChangelogHandle = result.htmlChangelogHandle || null;
    htmlUpdateChangelogFileName = result.htmlChangelogFileName || null;
    cachedHtmlChangelogSections = null;
    htmlChangelogSourceLabel = null;
    lastUpdateError = false;
    if (updateCheckStatus && rootDirHandle && updateDirHandle) {
      if (!pendingUpdates.length) {
        updateCheckStatus.textContent = 'Letzte Prüfung abgeschlossen.';
      } else {
        updateCheckStatus.textContent = `${pendingUpdates.length} Update${pendingUpdates.length === 1 ? '' : 's'} verfügbar.`;
      }
    }
    if (updateCheckStatus && (!rootDirHandle || !updateDirHandle)) {
      updateCheckStatus.textContent = '';
    }
  } catch (err) {
    console.error('Update-Prüfung fehlgeschlagen', err);
    pendingUpdates = [];
    htmlUpdateChangelogHandle = null;
    htmlUpdateChangelogFileName = null;
    cachedHtmlChangelogSections = null;
    htmlChangelogSourceLabel = null;
    lastUpdateError = true;
    if (updateCheckStatus && rootDirHandle && updateDirHandle) {
      updateCheckStatus.textContent = 'Fehler bei der Prüfung.';
    }
    try {
      const fallback = await collectVersionDiffs(null, rootDirHandle);
      versionOverview = fallback.overview;
      htmlUpdateChangelogHandle = fallback.htmlChangelogHandle || null;
      htmlUpdateChangelogFileName = fallback.htmlChangelogFileName || null;
    } catch {}
  } finally {
    updateCheckInProgress = false;
    renderUpdateList();
    if (rerunUpdateCheckWhenUnlocked && !pendingRootPermission && !pendingUpdatePermission) {
      rerunUpdateCheckWhenUnlocked = false;
      await runUpdateCheck();
    }
  }
}

function stopAutomaticUpdatePolling() {
  if (updatePollingIntervalId !== null) {
    window.clearInterval(updatePollingIntervalId);
    updatePollingIntervalId = null;
  }
}

async function triggerAutomaticUpdateCheck() {
  if (!appSettings.autoUpdatePolling) return;
  if (typeof document !== 'undefined' && document.hidden) return;
  try {
    await runUpdateCheck();
  } catch (err) {
    console.error('Automatische Update-Prüfung fehlgeschlagen', err);
  }
}

function startAutomaticUpdatePolling({ immediate = false } = {}) {
  stopAutomaticUpdatePolling();
  if (!appSettings.autoUpdatePolling) return;

  if (immediate) {
    void triggerAutomaticUpdateCheck();
  }

  updatePollingIntervalId = window.setInterval(() => {
    if (!appSettings.autoUpdatePolling) {
      stopAutomaticUpdatePolling();
      return;
    }
    void triggerAutomaticUpdateCheck();
  }, UPDATE_POLL_INTERVAL_MS);
}

function updateAutoPollingState(options = {}) {
  if (appSettings.autoUpdatePolling) {
    startAutomaticUpdatePolling(options);
  } else {
    stopAutomaticUpdatePolling();
  }
}

function activateSettingsSection(section) {
  document.querySelectorAll('.settings-nav button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.section === section);
  });
  document.querySelectorAll('.settings-section').forEach(sec => {
    sec.classList.toggle('active', sec.id === `section-${section}`);
  });
}

function openSettings(section = 'general') {
  if (!settingsModal) return;
  populateInputsFromSettings();
  activateSettingsSection(section);
  closeHistoryMenu();
  settingsModal.classList.remove('hidden');
}

function renderModuleColorLayers(layers = appSettings.moduleColorLayers) {
  if (!moduleColorLayersContainer) return;
  const subLayerCount = typeof appSettings.moduleSubLayerCount === 'number' && appSettings.moduleSubLayerCount > 0
    ? Math.min(appSettings.moduleSubLayerCount, MAX_MODULE_SUB_LAYERS)
    : DEFAULT_SUB_LAYER_COUNT;
  appSettings.moduleSubLayerCount = subLayerCount;
  const normalized = normalizeModuleColorLayers(layers, subLayerCount);
  appSettings.moduleColorLayers = normalized;
  moduleColorLayersContainer.innerHTML = '';
  normalized.forEach((layer, index) => {
    const layerEl = createModuleColorLayerElement(layer, index);
    moduleColorLayersContainer.appendChild(layerEl);
  });
  updateModuleColorLayerAddState();
  updateModuleColorLayerRemoveStates();
  syncModuleLayerCssVariables();
}

function createModuleColorLayerElement(layer, index) {
  layer = layer || {};
  const wrapper = document.createElement('div');
  wrapper.className = 'module-color-layer';
  wrapper.dataset.index = String(index);
  wrapper.dataset.id = layer.id;
  wrapper.innerHTML = `
    <div class="layer-content">
      <div class="module-layer-controls">
        <div class="module-layer-name-field">
          <label>Unter-Layer Name</label>
          <input type="text" class="module-layer-name border rounded px-2 py-1 text-sm w-full" maxlength="40">
        </div>
        <div class="module-layer-groups">
          <div class="module-layer-group module-layer-group--main" data-group="module">
            <div>
              <div class="module-layer-group-title">Hauptmodul</div>
              <p class="module-layer-group-description">Beinhaltet Überschrift und Unter-Layer.</p>
            </div>
            <div class="module-layer-group-grid">
              <label class="module-layer-color">
                <span>Hintergrund</span>
                <input type="color" data-field="moduleBg" class="border rounded">
              </label>
              <label class="module-layer-color">
                <span>Text</span>
                <input type="color" data-field="moduleText" class="border rounded">
              </label>
              <label class="module-layer-color">
                <span>Rahmen</span>
                <input type="color" data-field="moduleBorder" class="border rounded">
              </label>
            </div>
            <div class="module-layer-main-children">
              <div class="module-layer-main-children-label">Enthaltene Bereiche</div>
              <div class="module-layer-main-children-stack">
                <div class="module-layer-group module-layer-group--nested" data-group="header">
                  <div class="module-layer-group-title">Überschrift Unter-Layer</div>
                  <div class="module-layer-group-grid">
                    <label class="module-layer-color">
                      <span>Hintergrund</span>
                      <input type="color" data-field="headerBg" class="border rounded">
                    </label>
                    <label class="module-layer-color">
                      <span>Text</span>
                      <input type="color" data-field="headerText" class="border rounded">
                    </label>
                    <label class="module-layer-color">
                      <span>Rahmen</span>
                      <input type="color" data-field="headerBorder" class="border rounded">
                    </label>
                  </div>
                </div>
                <div class="module-layer-subtree" data-sub-shell>
                  <div class="module-layer-subtree-label">Unter-Layer</div>
                  <div class="module-layer-subgroups" data-sub-controls></div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="module-layer-actions">
          <button type="button" class="module-layer-duplicate">Duplizieren</button>
          <button type="button" class="module-layer-remove">Entfernen</button>
        </div>
      </div>
    </div>
  `;
  const badge = wrapper.querySelector('.module-layer-badge');
  if (badge) badge.textContent = `Unter-Layer ${index + 1}`;
  const nameInput = wrapper.querySelector('.module-layer-name');
  if (nameInput) nameInput.value = layer.name || '';
  const moduleBgInput = wrapper.querySelector('input[data-field="moduleBg"]');
  const moduleTextInput = wrapper.querySelector('input[data-field="moduleText"]');
  const moduleBorderInput = wrapper.querySelector('input[data-field="moduleBorder"]');
  const headerBgInput = wrapper.querySelector('input[data-field="headerBg"]');
  const headerTextInput = wrapper.querySelector('input[data-field="headerText"]');
  const headerBorderInput = wrapper.querySelector('input[data-field="headerBorder"]');

  const resolvedLayer = { ...layer };
  if (moduleBgInput) {
    setColorInputValue(moduleBgInput, layer.moduleBg, { silent: true, setBaseline: true });
    resolvedLayer.moduleBg = getColorInputValue(moduleBgInput);
  }
  if (moduleTextInput) {
    setColorInputValue(moduleTextInput, layer.moduleText, { silent: true, setBaseline: true });
    resolvedLayer.moduleText = getColorInputValue(moduleTextInput);
  }
  if (moduleBorderInput) {
    setColorInputValue(moduleBorderInput, layer.moduleBorder, { silent: true, setBaseline: true });
    resolvedLayer.moduleBorder = getColorInputValue(moduleBorderInput);
  }
  if (headerBgInput) {
    setColorInputValue(headerBgInput, layer.headerBg, { silent: true, setBaseline: true });
    resolvedLayer.headerBg = getColorInputValue(headerBgInput);
  }
  if (headerTextInput) {
    setColorInputValue(headerTextInput, layer.headerText, { silent: true, setBaseline: true });
    resolvedLayer.headerText = getColorInputValue(headerTextInput);
  }
  if (headerBorderInput) {
    setColorInputValue(headerBorderInput, layer.headerBorder, { silent: true, setBaseline: true });
    resolvedLayer.headerBorder = getColorInputValue(headerBorderInput);
  }

  renderModuleColorLayerSubSections(wrapper, resolvedLayer);
  applyModuleColorLayerPreview(wrapper, resolvedLayer);
  return wrapper;
}

function renderModuleColorLayerSubSections(wrapper, layer) {
  if (!wrapper) return;
  const subLayerCount = typeof appSettings.moduleSubLayerCount === 'number' && appSettings.moduleSubLayerCount > 0
    ? Math.min(appSettings.moduleSubLayerCount, MAX_MODULE_SUB_LAYERS)
    : DEFAULT_SUB_LAYER_COUNT;
  const normalizedLayer = {
    ...layer,
    subLayers: normalizeSubLayerEntries(
      Array.isArray(layer?.subLayers) && layer.subLayers.length ? layer.subLayers : [{
        bg: layer?.subBg,
        text: layer?.subText,
        border: layer?.subBorder
      }],
      subLayerCount,
      layer?.moduleBg,
      layer?.moduleText
    )
  };
  const subLayers = normalizedLayer.subLayers;
  const controls = wrapper.querySelector('[data-sub-controls]');
  if (controls) {
    controls.innerHTML = '';
    const descriptions = [
      'Primärer Inhaltsbereich für Listen, Tabellen oder Widgets.',
      'Weitere Inhalte, Detailansichten oder ergänzende Module.'
    ];
    let parentContainer = controls;
    let lastSubgroup = null;
    subLayers.forEach((subLayer, subIndex) => {
      const subgroup = document.createElement('div');
      subgroup.className = 'module-layer-subgroup';
      subgroup.dataset.subIndex = String(subIndex);
      const headerRow = document.createElement('div');
      headerRow.className = 'module-layer-subgroup-header';
      const title = document.createElement('div');
      title.className = 'module-layer-subgroup-title';
      title.textContent = subIndex === 0 ? 'Unter-Layer' : `Unter-Layer ${subIndex + 1}`;
      headerRow.appendChild(title);
      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.className = 'module-sub-layer-delete';
      deleteBtn.textContent = '❌';
      deleteBtn.title = 'Unter-Layer entfernen';
      deleteBtn.setAttribute('aria-label', 'Unter-Layer entfernen');
      headerRow.appendChild(deleteBtn);
      subgroup.appendChild(headerRow);
      const description = document.createElement('p');
      const descText = descriptions[subIndex] || descriptions[descriptions.length - 1] || '';
      description.className = 'module-layer-subgroup-description';
      description.textContent = descText;
      subgroup.appendChild(description);
      const grid = document.createElement('div');
      grid.className = 'module-layer-group-grid';
      const fields = [
        { key: 'bg', label: 'Hintergrund' },
        { key: 'text', label: 'Text' },
        { key: 'border', label: 'Rahmen' }
      ];
      fields.forEach(field => {
        const fieldLabel = document.createElement('label');
        fieldLabel.className = 'module-layer-color';
        const span = document.createElement('span');
        span.textContent = field.label;
        const input = document.createElement('input');
        input.type = 'color';
        input.className = 'border rounded';
        input.dataset.subField = field.key;
        input.dataset.subIndex = String(subIndex);
        const value = typeof subLayer?.[field.key] === 'string' && subLayer[field.key]
          ? subLayer[field.key]
          : (field.key === 'text' ? '#ffffff' : (layer?.moduleBg || '#1f2937'));
        fieldLabel.appendChild(span);
        fieldLabel.appendChild(input);
        grid.appendChild(fieldLabel);
        setColorInputValue(input, value, { silent: true, setBaseline: true });
        subLayer[field.key] = getColorInputValue(input);
      });
      subgroup.appendChild(grid);
      const childrenContainer = document.createElement('div');
      childrenContainer.className = 'module-layer-subgroup-children';
      subgroup.appendChild(childrenContainer);

      if (subIndex === 0 || !lastSubgroup) {
        parentContainer = controls;
      } else {
        parentContainer = lastSubgroup.querySelector('.module-layer-subgroup-children') || lastSubgroup;
      }

      parentContainer.appendChild(subgroup);
      lastSubgroup = subgroup;
    });
  }
}

// Verbindet die Farbeditor-Steuerelemente der Unter-Layer mit den globalen CSS-Variablen.
function bindLayerColorSync() {
  const manager = document.querySelector('.module-layer-manager');
  const layersContainer = document.getElementById('module-color-layers');
  const docEl = document.documentElement;
  if (!manager || !layersContainer || !docEl) return;

  const style = docEl.style;
  const lastValues = new Map();

  const getSubgroups = () => Array.from(manager.querySelectorAll('.module-layer-subgroup'));

  const applyLayerVariables = (layerId, colorValue) => {
    const parsed = parseColor(colorValue);
    if (!parsed) {
      if (lastValues.has(layerId)) {
        style.removeProperty(`--${layerId}-h`);
        style.removeProperty(`--${layerId}-s`);
        style.removeProperty(`--${layerId}-l`);
        style.removeProperty(`--${layerId}-a`);
        lastValues.delete(layerId);
      }
      return;
    }

    const h = Math.round(normalizeHue(parsed.h));
    const s = Math.round(clamp(parsed.s, 0, 100));
    const l = Math.round(clamp(parsed.l, 0, 100));
    const a = Math.round(clamp(parsed.a, 0, 1) * 100) / 100;
    const summary = hslaToString({ h, s, l, a });

    if (lastValues.get(layerId) === summary) {
      return;
    }

    style.setProperty(`--${layerId}-h`, String(h));
    style.setProperty(`--${layerId}-s`, `${s}%`);
    style.setProperty(`--${layerId}-l`, `${l}%`);
    style.setProperty(`--${layerId}-a`, String(a));

    lastValues.set(layerId, summary);
    console.log(`[LayerSync] ${layerId} → ${summary}`);
  };

  const syncAllSubgroups = () => {
    const subgroups = getSubgroups();
    const activeIds = new Set();

    subgroups.forEach((subgroup, index) => {
      const colorInput = subgroup.querySelector('input[data-sub-field="bg"]');
      if (!colorInput) return;
      const value = getColorInputValue(colorInput);
      if (!value) return;
      const layerId = `layer${index + 1}`;
      activeIds.add(layerId);
      applyLayerVariables(layerId, value);
    });

    Array.from(lastValues.keys()).forEach(layerId => {
      if (!activeIds.has(layerId)) {
        style.removeProperty(`--${layerId}-h`);
        style.removeProperty(`--${layerId}-s`);
        style.removeProperty(`--${layerId}-l`);
        style.removeProperty(`--${layerId}-a`);
        lastValues.delete(layerId);
      }
    });
  };

  manager.addEventListener('input', event => {
    if (!(event.target instanceof HTMLInputElement)) return;
    if (!event.target.closest('.module-layer-subgroup')) return;
    syncAllSubgroups();
  });

  const observer = new MutationObserver(mutations => {
    if (!mutations.some(mutation => mutation.type === 'childList')) return;
    window.requestAnimationFrame(syncAllSubgroups);
  });
  observer.observe(layersContainer, { childList: true, subtree: true });

  syncAllSubgroups();
}

function styleModuleLayerGroup(groupEl, bg, text, border) {
  if (!groupEl) return;
  groupEl.style.backgroundColor = bg;
  groupEl.style.borderColor = border;
  groupEl.style.color = text;
  groupEl.style.boxShadow = 'none';
  const title = groupEl.querySelector('.module-layer-group-title');
  if (title) {
    title.style.color = text;
    title.style.opacity = '1';
  }
  groupEl.querySelectorAll('.module-layer-color').forEach(label => {
    label.style.color = text;
    const span = label.querySelector('span');
    if (span) {
      span.style.color = text;
      span.style.opacity = '1';
    }
  });
}

function styleModuleLayerSubgroup(subgroupEl, bg, text, border) {
  if (!subgroupEl) return;
  subgroupEl.style.backgroundColor = bg;
  subgroupEl.style.borderColor = border;
  subgroupEl.style.color = text;
  subgroupEl.style.boxShadow = 'none';
  const title = subgroupEl.querySelector('.module-layer-subgroup-title');
  if (title) {
    title.style.color = text;
    title.style.opacity = '1';
  }
  const description = subgroupEl.querySelector('.module-layer-subgroup-description');
  if (description) {
    description.style.color = text;
    description.style.opacity = '1';
  }
  subgroupEl.querySelectorAll('.module-layer-color').forEach(label => {
    label.style.color = text;
    const span = label.querySelector('span');
    if (span) {
      span.style.color = text;
      span.style.opacity = '1';
    }
  });
  const childContainer = subgroupEl.querySelector('.module-layer-subgroup-children');
  if (childContainer) {
    const connectorColor = hexToRgba(border, 0.45) || border;
    childContainer.style.borderLeftColor = connectorColor;
  }
}

function applyModuleColorLayerPreview(layerEl, layer) {
  if (!layerEl || !layer) return;
  const ensureColor = (value, fallback) => (typeof value === 'string' && value.trim() ? value : fallback);
  const moduleBg = ensureColor(layer.moduleBg, '#005983');
  const moduleText = ensureColor(layer.moduleText, '#ffffff');
  const moduleBorder = ensureColor(layer.moduleBorder, moduleText);
  const headerBg = ensureColor(layer.headerBg, moduleBg);
  const headerText = ensureColor(layer.headerText, moduleText);
  const headerBorder = ensureColor(layer.headerBorder, headerBg);
  const subLayerCount = typeof appSettings.moduleSubLayerCount === 'number' && appSettings.moduleSubLayerCount > 0
    ? Math.min(appSettings.moduleSubLayerCount, MAX_MODULE_SUB_LAYERS)
    : DEFAULT_SUB_LAYER_COUNT;
  const subLayersData = normalizeSubLayerEntries(
    Array.isArray(layer.subLayers) && layer.subLayers.length ? layer.subLayers : [{
      bg: layer.subBg,
      text: layer.subText,
      border: layer.subBorder
    }],
    subLayerCount,
    moduleBg,
    moduleText
  );
  const paintSampleGroup = (groupKey, colors, contextBg) => {
    const groupEl = layerEl.querySelector(`[data-sample-group="${groupKey}"]`);
    if (!groupEl) return;
    const baseTint = hexToRgba(contextBg, 0.22) || hexToRgba(colors.text, 0.18) || 'rgba(148,163,184,0.18)';
    const outlineTint = hexToRgba(colors.text, 0.35) || hexToRgba(contextBg, 0.3) || 'rgba(15,23,42,0.24)';
    groupEl.querySelectorAll('.layer-sample').forEach(sample => {
      sample.style.backgroundColor = baseTint;
      sample.style.borderColor = outlineTint;
      sample.style.color = colors.text;
      const label = sample.querySelector('.layer-sample-label');
      if (label) {
        label.style.color = colors.text;
      }
    });
    const setChip = (type, fillColor, strokeColor, backgroundOverride) => {
      const sampleEl = groupEl.querySelector(`[data-sample-type="${type}"]`);
      if (!sampleEl) return;
      const chip = sampleEl.querySelector('.layer-sample-chip');
      if (!chip) return;
      const chipBg = backgroundOverride || fillColor;
      const chipBorder = strokeColor || fillColor;
      chip.style.backgroundColor = chipBg;
      chip.style.borderColor = chipBorder;
      const outline = hexToRgba(chipBorder, 0.38) || 'rgba(15,23,42,0.28)';
      chip.style.boxShadow = `0 0 0 1px ${outline}, inset 0 0 0 1px rgba(255,255,255,0.35)`;
    };
    setChip('bg', colors.bg, colors.border);
    setChip('text', colors.text, colors.text);
    const borderFill = hexToRgba(colors.border, 0.28) || colors.border;
    setChip('border', colors.border, colors.border, borderFill);
  };
  const moduleGroupBorder = hexToRgba(moduleBorder, 0.35) || moduleBorder;
  const headerGroupBorder = hexToRgba(headerBorder, 0.35) || headerBorder;
  styleModuleLayerGroup(
    layerEl.querySelector('.module-layer-group[data-group="module"]'),
    moduleBg,
    moduleText,
    moduleGroupBorder
  );
  styleModuleLayerGroup(
    layerEl.querySelector('.module-layer-group[data-group="header"]'),
    headerBg,
    headerText,
    headerGroupBorder
  );
  const mainChildren = layerEl.querySelector('.module-layer-main-children');
  if (mainChildren) {
    const connectorColor = hexToRgba(moduleBorder, 0.35) || moduleBorder;
    const fillTint = hexToRgba(moduleBg, 0.12) || 'rgba(148,163,184,0.18)';
    mainChildren.style.borderColor = connectorColor;
    mainChildren.style.backgroundColor = fillTint;
    mainChildren.style.setProperty('--module-connector-color', connectorColor);
    const label = mainChildren.querySelector('.module-layer-main-children-label');
    if (label) {
      label.style.color = moduleText;
      label.style.opacity = '0.85';
    }
    const nestedHeaderGroup = mainChildren.querySelector('.module-layer-group--nested');
    if (nestedHeaderGroup) {
      nestedHeaderGroup.style.borderColor = hexToRgba(headerBorder, 0.4) || headerBorder;
    }
  }
  const subsContainer = layerEl.querySelector('[data-sub-shell]');
  if (subsContainer) {
    const subsBg = hexToRgba(moduleBg, 0.08) || '#f9fafb';
    const subsBorder = hexToRgba(moduleBorder, 0.25) || moduleBorder;
    subsContainer.style.backgroundColor = subsBg;
    subsContainer.style.borderColor = subsBorder;
    subsContainer.style.boxShadow = 'none';
    subsContainer.style.color = moduleText;
    subsContainer.style.setProperty('--module-connector-color', hexToRgba(moduleBorder, 0.35) || moduleBorder);
    const subsTitle = subsContainer.querySelector('.module-layer-subtree-label');
    if (subsTitle) {
      subsTitle.style.color = moduleText;
      subsTitle.style.opacity = '0.9';
    }
  }
  const getSubLayerData = index => subLayersData[index] || subLayersData[subLayersData.length - 1] || {
    bg: moduleBg,
    text: moduleText,
    border: moduleBg
  };

  const preview = layerEl.querySelector('.layer-preview');
  if (preview) {
    const previewBorder = hexToRgba(moduleBorder, 0.6) || moduleBorder;
    const previewGlow = hexToRgba(moduleText, 0.1) || 'rgba(255,255,255,0.65)';
    const previewShadow = hexToRgba(moduleBorder, 0.18) || 'rgba(17,24,39,0.18)';
    preview.style.borderColor = previewBorder;
    preview.style.boxShadow = `0 18px 32px ${previewShadow}, inset 0 0 0 1px ${previewGlow}`;
  }
  const main = layerEl.querySelector('.layer-main');
  if (main) {
    main.style.backgroundColor = moduleBg;
    main.style.color = moduleText;
    main.style.borderColor = moduleBorder;
    const innerOutline = hexToRgba(moduleText, 0.12) || 'rgba(255,255,255,0.12)';
    main.style.boxShadow = `inset 0 0 0 1px ${innerOutline}`;
  }
  paintSampleGroup('module', { bg: moduleBg, text: moduleText, border: moduleBorder }, moduleBg);
  const badge = layerEl.querySelector('.module-layer-badge');
  if (badge) {
    badge.style.backgroundColor = moduleText;
    badge.style.color = moduleBg;
    badge.style.borderColor = moduleBorder;
  }
  const mainLabel = layerEl.querySelector('.layer-label--main');
  if (mainLabel) {
    mainLabel.style.backgroundColor = moduleText;
    mainLabel.style.color = moduleBg;
    mainLabel.style.borderColor = moduleBorder;
  }

  const header = layerEl.querySelector('.layer-header');
  if (header) {
    header.style.backgroundColor = headerBg;
    header.style.color = headerText;
    header.style.borderColor = headerBorder;
    header.style.boxShadow = 'none';
  }
  paintSampleGroup('header', { bg: headerBg, text: headerText, border: headerBorder }, headerBg);
  const headerLabel = layerEl.querySelector('.layer-label--header');
  if (headerLabel) {
    headerLabel.style.backgroundColor = headerText;
    headerLabel.style.color = headerBg;
    headerLabel.style.borderColor = headerBorder;
  }
  const headerDescription = layerEl.querySelector('.layer-header .layer-description');
  if (headerDescription) {
    headerDescription.style.color = headerText;
  }

  const subElements = layerEl.querySelectorAll('.layer-sub');
  const subLabels = layerEl.querySelectorAll('.layer-label--sub');
  subElements.forEach((subEl, index) => {
    const data = getSubLayerData(index);
    const subBg = ensureColor(data.bg, moduleBg);
    const subText = ensureColor(data.text, moduleText);
    const subBorder = ensureColor(data.border, subBg);
    subEl.style.backgroundColor = subBg;
    subEl.style.color = subText;
    subEl.style.borderColor = subBorder;
    subEl.style.boxShadow = 'none';
  });
  subLabels.forEach((label, index) => {
    const data = getSubLayerData(index);
    const subBg = ensureColor(data.bg, moduleBg);
    const subText = ensureColor(data.text, moduleText);
    const subBorder = ensureColor(data.border, subBg);
    label.style.backgroundColor = subText;
    label.style.color = subBg;
    label.style.borderColor = subBorder;
  });
  const subgroupControls = layerEl.querySelectorAll('.module-layer-subgroup');
  subgroupControls.forEach((subgroupEl, index) => {
    const data = getSubLayerData(index);
    const subBg = ensureColor(data.bg, moduleBg);
    const subText = ensureColor(data.text, moduleText);
    const subBorder = ensureColor(data.border, subBg);
    styleModuleLayerSubgroup(subgroupEl, subBg, subText, subBorder);
  });
}

function getActiveSubLayerOptions() {
  const primaryLayer = getPrimaryModuleLayer();
  if (!primaryLayer) return [];
  const subLayers = Array.isArray(primaryLayer.subLayers) ? primaryLayer.subLayers : [];
  return subLayers.map((subLayer, index) => {
    const fallbackName = index === 0 ? 'Unter-Layer' : `Unter-Layer ${index + 1}`;
    const resolvedName = typeof subLayer?.name === 'string' && subLayer.name.trim()
      ? subLayer.name.trim()
      : fallbackName;
    return {
      index,
      value: String(index),
      id: `${primaryLayer?.id || 'primary'}-sub-${index + 1}`,
      label: resolvedName,
      colors: {
        bg: typeof subLayer?.bg === 'string' ? subLayer.bg : '',
        text: typeof subLayer?.text === 'string' ? subLayer.text : '',
        border: typeof subLayer?.border === 'string' ? subLayer.border : ''
      }
    };
  });
}

getActiveSubLayerOptions.placeholder = 'Unter-Layer auswählen';

function broadcastActiveSubLayerOptions() {
  if (typeof window === 'undefined') return;
  try {
    window.dispatchEvent(new CustomEvent('shopguide:sub-layers-updated', {
      detail: {
        placeholder: getActiveSubLayerOptions.placeholder || 'Unter-Layer auswählen',
        options: getActiveSubLayerOptions()
      }
    }));
  } catch (err) {
    console.warn('Konnte Unter-Layer-Optionen nicht senden', err);
  }
}

function assignLayerColorTriplet(target, prefix, colors) {
  if (!target || typeof target !== 'object' || typeof prefix !== 'string' || !prefix) {
    return;
  }
  const safeValue = key => (typeof colors?.[key] === 'string' ? colors[key] : '');
  target[`${prefix}-bg`] = safeValue('bg');
  target[`${prefix}-text`] = safeValue('text');
  target[`${prefix}-border`] = safeValue('border');
}

function syncModuleLayerCssVariables() {
  const assignments = {};
  const layers = Array.isArray(appSettings.moduleColorLayers) ? appSettings.moduleColorLayers : [];
  for (let layerIndex = 0; layerIndex < MAX_MODULE_COLOR_LAYERS; layerIndex += 1) {
    const layer = layers[layerIndex];
    const basePrefix = `--module-layer-${layerIndex + 1}`;
    const moduleBg = typeof layer?.moduleBg === 'string' ? layer.moduleBg : '';
    const moduleText = typeof layer?.moduleText === 'string' ? layer.moduleText : '';
    const moduleBorder = typeof layer?.moduleBorder === 'string' ? layer.moduleBorder : '';
    const headerBg = typeof layer?.headerBg === 'string' ? layer.headerBg : '';
    const headerText = typeof layer?.headerText === 'string' ? layer.headerText : '';
    const headerBorder = typeof layer?.headerBorder === 'string' ? layer.headerBorder : '';
    assignments[`${basePrefix}-bg`] = moduleBg;
    assignments[`${basePrefix}-text`] = moduleText;
    assignments[`${basePrefix}-border`] = moduleBorder;
    assignments[`${basePrefix}-header-bg`] = headerBg;
    assignments[`${basePrefix}-header-text`] = headerText;
    assignments[`${basePrefix}-header-border`] = headerBorder;
    const subLayers = Array.isArray(layer?.subLayers) ? layer.subLayers : [];
    for (let subIndex = 0; subIndex < MAX_MODULE_SUB_LAYERS; subIndex += 1) {
      const subLayer = subLayers[subIndex];
      const subPrefix = `${basePrefix}-sub-${subIndex + 1}`;
      assignments[`${subPrefix}-bg`] = typeof subLayer?.bg === 'string' ? subLayer.bg : '';
      assignments[`${subPrefix}-text`] = typeof subLayer?.text === 'string' ? subLayer.text : '';
      assignments[`${subPrefix}-border`] = typeof subLayer?.border === 'string' ? subLayer.border : '';
      if (layerIndex === 0) {
        const globalPrefix = `--module-sub-layer-${subIndex + 1}`;
        assignments[`${globalPrefix}-bg`] = typeof subLayer?.bg === 'string' ? subLayer.bg : '';
        assignments[`${globalPrefix}-text`] = typeof subLayer?.text === 'string' ? subLayer.text : '';
        assignments[`${globalPrefix}-border`] = typeof subLayer?.border === 'string' ? subLayer.border : '';
      }
    }
    assignLayerColorTriplet(assignments, `--module-main-layer-${layerIndex + 1}`, {
      bg: moduleBg,
      text: moduleText,
      border: moduleBorder
    });
    assignLayerColorTriplet(assignments, `--module-header-layer-${layerIndex + 1}`, {
      bg: headerBg,
      text: headerText,
      border: headerBorder
    });
    if (layerIndex === 0) {
      assignLayerColorTriplet(assignments, '--module-main-layer', {
        bg: moduleBg,
        text: moduleText,
        border: moduleBorder
      });
      assignLayerColorTriplet(assignments, '--module-header-layer', {
        bg: headerBg,
        text: headerText,
        border: headerBorder
      });
    }
    if (layerIndex === 0 && subLayers.length === 0) {
      for (let subIndex = 0; subIndex < MAX_MODULE_SUB_LAYERS; subIndex += 1) {
        const globalPrefix = `--module-sub-layer-${subIndex + 1}`;
        assignments[`${globalPrefix}-bg`] = '';
        assignments[`${globalPrefix}-text`] = '';
        assignments[`${globalPrefix}-border`] = '';
      }
    }
  }
  updateCssVariables(assignments);
  broadcastActiveSubLayerOptions();
}

if (typeof window !== 'undefined') {
  window.getActiveSubLayerOptions = getActiveSubLayerOptions;
}

function updateModuleColorLayerAddState() {
  if (!addModuleColorLayerBtn) return;
  const currentCount = typeof appSettings.moduleSubLayerCount === 'number' && appSettings.moduleSubLayerCount > 0
    ? appSettings.moduleSubLayerCount
    : DEFAULT_SUB_LAYER_COUNT;
  const atLimit = currentCount >= MAX_MODULE_SUB_LAYERS;
  addModuleColorLayerBtn.disabled = atLimit;
}

function updateModuleColorLayerRemoveStates() {
  if (!moduleColorLayersContainer) return;
  const allowRemove = Array.isArray(appSettings.moduleColorLayers) && appSettings.moduleColorLayers.length > 1;
  moduleColorLayersContainer.querySelectorAll('.module-layer-remove').forEach(btn => {
    btn.disabled = !allowRemove;
  });
}

function collectModuleColorLayersFromDom() {
  if (!moduleColorLayersContainer) return [];
  const layers = [];
  moduleColorLayersContainer.querySelectorAll('.module-color-layer').forEach((layerEl, index) => {
    let id = typeof layerEl.dataset.id === 'string' && layerEl.dataset.id.trim() ? layerEl.dataset.id : '';
    if (!id) {
      id = generateLayerId();
      layerEl.dataset.id = id;
    }
    const nameInput = layerEl.querySelector('.module-layer-name');
    const getColor = field => {
      const input = layerEl.querySelector(`input[data-field="${field}"]`);
      return input ? getColorInputValue(input) : '';
    };
    const subLayerCount = typeof appSettings.moduleSubLayerCount === 'number' && appSettings.moduleSubLayerCount > 0
      ? Math.min(appSettings.moduleSubLayerCount, MAX_MODULE_SUB_LAYERS)
      : DEFAULT_SUB_LAYER_COUNT;
    const subLayers = [];
    layerEl.querySelectorAll('.module-layer-subgroup').forEach((groupEl, subIndex) => {
      const getSubColor = key => {
        const input = groupEl.querySelector(`input[data-sub-field="${key}"]`);
        return input ? getColorInputValue(input) : '';
      };
      subLayers[subIndex] = {
        bg: getSubColor('bg'),
        text: getSubColor('text'),
        border: getSubColor('border')
      };
    });
    const normalizedSubLayers = normalizeSubLayerEntries(subLayers, subLayerCount, getColor('moduleBg'), getColor('moduleText'));
    const firstSub = normalizedSubLayers[0] || { bg: '', text: '', border: '' };
    layers.push({
      id,
      name: nameInput ? nameInput.value : `Unter-Layer ${index + 1}`,
      moduleBg: getColor('moduleBg'),
      moduleText: getColor('moduleText'),
      moduleBorder: getColor('moduleBorder'),
      headerBg: getColor('headerBg'),
      headerText: getColor('headerText'),
      headerBorder: getColor('headerBorder'),
      subLayers: normalizedSubLayers,
      subBg: firstSub.bg,
      subText: firstSub.text,
      subBorder: firstSub.border
    });
  });
  return layers;
}

function handleModuleColorLayerInput(event) {
  if (!(event.target instanceof HTMLInputElement)) return;
  const layerEl = event.target.closest('.module-color-layer');
  if (!layerEl) return;
  appSettings.moduleColorLayers = collectModuleColorLayersFromDom();
  const index = Number(layerEl.dataset.index || '0');
  const layer = appSettings.moduleColorLayers[index];
  applyModuleColorLayerPreview(layerEl, layer);
  syncModuleLayerCssVariables();
  if (index === 0) {
    applySettings();
  }
  scheduleSettingsSave();
}

function handleModuleColorLayerClick(event) {
  const subDeleteBtn = event.target.closest('.module-sub-layer-delete');
  const removeBtn = event.target.closest('.module-layer-remove');
  const duplicateBtn = event.target.closest('.module-layer-duplicate');
  if (subDeleteBtn) {
    const subgroup = subDeleteBtn.closest('.module-layer-subgroup');
    if (!subgroup) return;
    const currentCount = typeof appSettings.moduleSubLayerCount === 'number' && appSettings.moduleSubLayerCount > 0
      ? appSettings.moduleSubLayerCount
      : DEFAULT_SUB_LAYER_COUNT;
    if (currentCount <= 1) {
      alert('Mindestens ein Unter-Layer muss bestehen.');
      return;
    }
    const targetIndex = Number(subgroup.dataset.subIndex || '0');
    appSettings.moduleColorLayers = collectModuleColorLayersFromDom();
    const updatedLayers = appSettings.moduleColorLayers.map(layer => {
      const copy = {
        ...layer,
        subLayers: Array.isArray(layer.subLayers) ? layer.subLayers.slice() : []
      };
      if (copy.subLayers.length > targetIndex) {
        copy.subLayers.splice(targetIndex, 1);
      }
      return copy;
    });
    const nextCount = Math.max(currentCount - 1, 1);
    appSettings.moduleSubLayerCount = nextCount;
    appSettings.moduleColorLayers = normalizeModuleColorLayers(updatedLayers, nextCount);
    renderModuleColorLayers(appSettings.moduleColorLayers);
    applySettings();
    scheduleSettingsSave();
    return;
  }
  if (removeBtn) {
    const layerEl = removeBtn.closest('.module-color-layer');
    if (!layerEl) return;
    if (!Array.isArray(appSettings.moduleColorLayers) || appSettings.moduleColorLayers.length <= 1) {
      return;
    }
    const index = Number(layerEl.dataset.index || '0');
    appSettings.moduleColorLayers.splice(index, 1);
    renderModuleColorLayers(appSettings.moduleColorLayers);
    if (index === 0) {
      applySettings();
    }
    scheduleSettingsSave();
    return;
  }
  if (duplicateBtn) {
    const layerEl = duplicateBtn.closest('.module-color-layer');
    if (!layerEl) return;
    if (!Array.isArray(appSettings.moduleColorLayers)) {
      appSettings.moduleColorLayers = [];
    }
    if (appSettings.moduleColorLayers.length >= MAX_MODULE_COLOR_LAYERS) {
      updateModuleColorLayerAddState();
      return;
    }
    const index = Number(layerEl.dataset.index || '0');
    const sourceLayer = appSettings.moduleColorLayers[index];
    const clone = {
      ...sourceLayer,
      id: generateLayerId(),
      name: `${sourceLayer.name || `Unter-Layer ${index + 1}`}-Kopie`,
      subLayers: Array.isArray(sourceLayer.subLayers)
        ? sourceLayer.subLayers.map(subLayer => ({ ...subLayer }))
        : undefined
    };
    if (Array.isArray(clone.subLayers) && clone.subLayers.length) {
      const firstSub = clone.subLayers[0];
      clone.subBg = firstSub.bg;
      clone.subText = firstSub.text;
      clone.subBorder = firstSub.border;
    }
    appSettings.moduleColorLayers.splice(index + 1, 0, clone);
    renderModuleColorLayers(appSettings.moduleColorLayers);
    if (index === 0) {
      applySettings();
    }
    scheduleSettingsSave();
  }
}

function scheduleSettingsSave() {
  if (settingsSaveTimeoutId !== null) {
    clearTimeout(settingsSaveTimeoutId);
  }
  settingsSaveTimeoutId = window.setTimeout(() => {
    settingsSaveTimeoutId = null;
    saveAppSettings();
  }, 400);
}

function flushSettingsSave() {
  if (settingsSaveTimeoutId !== null) {
    clearTimeout(settingsSaveTimeoutId);
    settingsSaveTimeoutId = null;
  }
  saveAppSettings();
}

function openHistoryMenu() {
  if (!historyMenuDropdown || !historyMenuToggle) return;
  historyMenuDropdown.classList.remove('hidden');
  historyMenuToggle.setAttribute('aria-expanded', 'true');
  historyMenuOpen = true;
}

function closeHistoryMenu() {
  if (!historyMenuDropdown || !historyMenuToggle) {
    historyMenuOpen = false;
    return false;
  }
  if (!historyMenuDropdown.classList.contains('hidden')) {
    historyMenuDropdown.classList.add('hidden');
  }
  historyMenuToggle.setAttribute('aria-expanded', 'false');
  historyMenuOpen = false;
  return true;
}

function toggleHistoryMenu() {
  if (historyMenuOpen) {
    closeHistoryMenu();
  } else {
    openHistoryMenu();
  }
}

function hideSettingsModal() {
  if (!settingsModal || settingsModal.classList.contains('hidden')) return false;
  settingsModal.classList.add('hidden');
  flushSettingsSave();
  return true;
}


document.addEventListener('DOMContentLoaded', async () => {
  initGlobalLayers();
  // Initialize sidebar collapsed state
  sidebarEl.classList.add('collapsed');
  // Trigger fade-in animation on initial load
  document.body.classList.add('fade-in');

  initializeColorPickersIn();
  bindLayerColorSync();

  themeProfiles = loadThemeProfiles();
  const defaultProfileName = 'Default Profil';
  if (!themeProfiles || !Object.keys(themeProfiles).length) {
    themeProfiles = { [defaultProfileName]: collectCurrentCssProfile() };
    saveThemeProfiles();
    refreshProfileOptions(defaultProfileName);
  } else {
    refreshProfileOptions(themeProfileSelect?.value || '');
  }

  if (themeProfileSelect) {
    themeProfileSelect.addEventListener('change', () => {
      updateProfileActionState();
      if (themeProfileNameInput) {
        themeProfileNameInput.value = themeProfileSelect.value || '';
      }
    });
  }

  if (themeProfileSaveBtn) {
    themeProfileSaveBtn.addEventListener('click', () => {
      const proposedName = (themeProfileNameInput?.value || themeProfileSelect?.value || '').trim();
      if (!proposedName) {
        alert('Bitte gib einen Profilnamen ein.');
        return;
      }
      themeProfiles[proposedName] = collectCurrentCssProfile();
      saveThemeProfiles();
      refreshProfileOptions(proposedName);
    });
  }

  if (themeProfileLoadBtn) {
    themeProfileLoadBtn.addEventListener('click', () => {
      const selected = themeProfileSelect?.value;
      if (!selected || !themeProfiles[selected]) return;
      applyProfileVariables(themeProfiles[selected]);
      refreshProfileOptions(selected);
    });
  }

  if (themeProfileDeleteBtn) {
    themeProfileDeleteBtn.addEventListener('click', () => {
      const selected = themeProfileSelect?.value;
      if (!selected || !themeProfiles[selected]) return;
      if (!confirm(`Profil "${selected}" löschen?`)) return;
      delete themeProfiles[selected];
      saveThemeProfiles();
      refreshProfileOptions('');
    });
  }

  updateProfileActionState();

  setUpdateStatusButton();
  renderUpdateList();
  updateUndoRedoButtons();
  updateDowngradeCollapseUI();
  setSaveIndicator('saved');
  if (historyMenuToggle) {
    historyMenuToggle.addEventListener('click', event => {
      event.stopPropagation();
      if (historyMenuToggle.disabled) return;
      toggleHistoryMenu();
    });
  }

  document.addEventListener('click', event => {
    if (!historyMenuOpen) return;
    if (historyMenu && historyMenu.contains(event.target)) return;
    closeHistoryMenu();
  });
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && appSettings.autoUpdatePolling) {
      void triggerAutomaticUpdateCheck();
    }
  });
  if (moduleSearchClearBtn) {
    moduleSearchClearBtn.classList.toggle('hidden', !(moduleSearchInput && moduleSearchInput.value));
  }

  if (moduleSearchInput) {
    moduleSearchInput.addEventListener('input', () => {
      sidebarSearchTerm = moduleSearchInput.value || '';
      if (moduleSearchClearBtn) moduleSearchClearBtn.classList.toggle('hidden', !moduleSearchInput.value);
      renderSidebar();
    });
  }

  if (moduleSearchClearBtn) {
    moduleSearchClearBtn.addEventListener('click', () => {
      if (!moduleSearchInput) return;
      moduleSearchInput.value = '';
      sidebarSearchTerm = '';
      moduleSearchClearBtn.classList.add('hidden');
      renderSidebar();
      moduleSearchInput.focus();
    });
  }

  if (downgradeToggle) {
    downgradeToggle.addEventListener('click', () => {
      downgradeCollapsed = !downgradeCollapsed;
      updateDowngradeCollapseUI();
      try {
        localStorage.setItem(DOWNGRADE_COLLAPSE_KEY, downgradeCollapsed ? '1' : '0');
      } catch (e) {}
    });
  }

  if (undoBtn) {
    undoBtn.addEventListener('click', async () => {
      if (!undoStack.length || historyInProgress) return;
      closeHistoryMenu();
      historyInProgress = true;
      const snapshot = undoStack.pop();
      const currentSnapshot = captureLayoutSnapshot();
      redoStack.push(JSON.parse(JSON.stringify(currentSnapshot)));
      updateUndoRedoButtons();
      try {
        if (snapshot) await restoreLayoutFromSnapshot(snapshot);
      } finally {
        historyInProgress = false;
        updateUndoRedoButtons();
      }
    });
  }

  if (redoBtn) {
    redoBtn.addEventListener('click', async () => {
      if (!redoStack.length || historyInProgress) return;
      closeHistoryMenu();
      historyInProgress = true;
      const snapshot = redoStack.pop();
      const currentSnapshot = captureLayoutSnapshot();
      undoStack.push(JSON.parse(JSON.stringify(currentSnapshot)));
      updateUndoRedoButtons();
      try {
        if (snapshot) await restoreLayoutFromSnapshot(snapshot);
      } finally {
        historyInProgress = false;
        updateUndoRedoButtons();
      }
    });
  }

  // Sidebar toggle
  sidebarToggle.addEventListener('click', () => {
    isSidebarOpen = !isSidebarOpen;
    sidebarEl.classList.toggle('collapsed', !isSidebarOpen);
    updateModuleDraggable();
    updateGridDraggable();
  });

  // Folder selection
  rootBtn.addEventListener('click', async () => {
    if (pendingRootPermission && rootDirHandle) {
      try {
        const granted = await ensureRWPermission(rootDirHandle, { mode: 'readwrite' });
        if (granted) {
          pendingRootPermission = false;
          rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
          rootBtn.classList.remove('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
          rootBtn.title = '';
          rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
          await loadModulesFromRoot(rootDirHandle);
          await loadAppSettings();
          applySettings();
          await loadAndInitTabs();
          await runUpdateCheck();
          return;
        }
      } catch (err) {
        console.warn('Erneute Berechtigungsabfrage für Arbeitsordner fehlgeschlagen', err);
      }
    }
    if (window.showDirectoryPicker) {
      try {
        rootDirHandle = await window.showDirectoryPicker();
        setGlobalHandle('root', rootDirHandle);                    // expose
        rootBtn.textContent = rootDirHandle.name;
        await idbSet(FS_HANDLE_KEY, rootDirHandle);                // persist handle
        try { localStorage.setItem(ROOT_HANDLE_NAME_KEY, rootDirHandle.name); } catch (e) {
          console.warn('Konnte Arbeitsordnernamen nicht speichern', e);
        }
        localStorage.setItem('rememberRootMeta', JSON.stringify({  // optional UI hint
          name: rootDirHandle.name, ts: Date.now()
        }));
        rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
        rootBtn.classList.remove('bg-yellow-400','hover:bg-yellow-500','text-gray-900');
        rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
        pendingRootPermission = false;
        rootBtn.title = '';
        await loadModulesFromRoot(rootDirHandle);
        await loadAppSettings();
        applySettings();
        await loadAndInitTabs();
        // ensure grid state reflects current sidebar state
        updateModuleDraggable();
        updateGridDraggable();
        await runUpdateCheck();
      } catch (e) {
        console.warn(e);
        alert('Ordnerauswahl abgebrochen oder nicht erlaubt.');
      }
    } else {
      const inp = document.getElementById('folder-input');
      inp.onchange = async e => {
        const files = Array.from(e.target.files);
        if (!files.length) return;
        setGlobalHandle('root', null);              // not reusable
        await idbDel(FS_HANDLE_KEY);                // forget saved handle
        localStorage.removeItem('rememberRootMeta');
        const any = files[0];
        const parts = any.webkitRelativePath.split('/');
        const rootName = parts[0];
        rootBtn.textContent = rootName;
        rootBtn.classList.remove('bg-blue-600','hover:bg-blue-700','text-white');
        rootBtn.classList.add('bg-gray-300','hover:bg-gray-400','text-gray-800');
        pendingRootPermission = false;
        rootBtn.title = '';
        try { localStorage.setItem(ROOT_HANDLE_NAME_KEY, rootName); } catch (e) {
          console.warn('Konnte Arbeitsordnernamen nicht speichern', e);
        }
        await loadModulesFromFileList(files, rootName);
        await loadAndInitTabs();
        inp.value = null;
        updateModuleDraggable();
        updateGridDraggable();
        pendingUpdates = [];
        renderUpdateList();
      };
      inp.click();
    }
  });

  if (selectUpdateFolderBtn) {
    selectUpdateFolderBtn.addEventListener('click', async () => {
      if (!('showDirectoryPicker' in window)) {
        alert('Update-Ordner können nur mit einem kompatiblen Browser gewählt werden.');
        return;
      }
      if (pendingUpdatePermission && updateDirHandle) {
        try {
          const granted = await ensureRWPermission(updateDirHandle, { mode: 'read' });
          if (granted) {
            pendingUpdatePermission = false;
            if (updateFolderNameEl) updateFolderNameEl.textContent = updateDirHandle.name;
            await runUpdateCheck();
            return;
          }
        } catch (err) {
          console.warn('Erneute Berechtigungsabfrage für Update-Ordner fehlgeschlagen', err);
        }
      }
      try {
        const handle = await window.showDirectoryPicker();
        const granted = await ensureRWPermission(handle, { mode: 'read' });
        if (!granted) {
          alert('Der Zugriff auf den Update-Ordner wurde nicht erlaubt.');
          return;
        }
        updateDirHandle = handle;
        setGlobalHandle('update', updateDirHandle);
        htmlUpdateChangelogHandle = null;
        htmlUpdateChangelogFileName = null;
        cachedHtmlChangelogSections = null;
        htmlChangelogSourceLabel = null;
        if (updateFolderNameEl) updateFolderNameEl.textContent = handle.name;
        try { localStorage.setItem(UPDATE_HANDLE_NAME_KEY, handle.name); } catch (e) {
          console.warn('Konnte Update-Ordnernamen nicht speichern', e);
        }
        await idbSet(UPDATE_HANDLE_KEY, handle);
        pendingUpdatePermission = false;
        await runUpdateCheck();
      } catch (e) {
        if (e?.name !== 'AbortError') {
          console.warn('Update-Ordner Auswahl fehlgeschlagen', e);
          alert('Der Update-Ordner konnte nicht gewählt werden.');
        }
      }
    });
  }

  if (clearUpdateFolderBtn) {
    clearUpdateFolderBtn.addEventListener('click', async () => {
      updateDirHandle = null;
      setGlobalHandle('update', updateDirHandle);
      if (updateFolderNameEl) updateFolderNameEl.textContent = 'Keiner gewählt';
      try { localStorage.removeItem(UPDATE_HANDLE_NAME_KEY); } catch (e) {
        console.warn('Konnte Update-Ordnernamen nicht entfernen', e);
      }
      await idbDel(UPDATE_HANDLE_KEY);
      pendingUpdatePermission = false;
      pendingUpdates = [];
      htmlUpdateChangelogHandle = null;
      htmlUpdateChangelogFileName = null;
      cachedHtmlChangelogSections = null;
      htmlChangelogSourceLabel = null;
      versionOverview = {
        html: {
          localVersion: versionOverview.html?.localVersion || null,
          updateVersion: null,
          localFileName: versionOverview.html?.localFileName || HTML_FILE_NAME,
          updateFileName: null
        },
        modules: versionOverview.modules.map(mod => ({
          ...mod,
          updateVersion: null,
          newVersion: mod.localVersion ?? null,
          currentVersion: mod.localVersion ?? null,
          updateDirHandle: null,
          updateRelPath: null,
          sourceRelPath: mod.localRelPath || null,
          changelogHandle: null,
          changelogFileName: null,
          changelogPath: null,
          changelogRelativePath: null
        }))
      };
      renderUpdateList();
      await runUpdateCheck();
    });
  }

  if (updateStatusBtn) {
    updateStatusBtn.addEventListener('click', () => {
      if (updateStatusBtn.disabled) return;
      openSettings('updates');
    });
  }

  if (updateAllBtn) {
    updateAllBtn.addEventListener('click', async () => {
      if (updateAllBtn.disabled || !currentUpgradeItems.length) return;

      const itemsToUpdate = currentUpgradeItems.slice();
      const originalText = updateAllBtn.textContent;
      updateAllBtn.disabled = true;
      updateAllBtn.classList.add('opacity-60','cursor-wait','cursor-not-allowed');
      updateAllBtn.textContent = 'Aktualisiere…';

      if (updatesTableBody) {
        updatesTableBody.querySelectorAll('button').forEach(btn => {
          btn.disabled = true;
          btn.classList.add('opacity-60','cursor-not-allowed');
        });
      }

      let encounteredError = false;
      try {
        for (const item of itemsToUpdate) {
          try {
            await applySingleUpdate(item, { skipRecheck: true });
          } catch (err) {
            encounteredError = true;
            console.error('Fehler beim Aktualisieren', err);
          }
        }
      } catch (err) {
        encounteredError = true;
        console.error('Fehler beim Aktualisieren', err);
      } finally {
        try {
          await runUpdateCheck();
        } catch (err) {
          encounteredError = true;
          console.error('Fehler beim Aktualisieren', err);
        }
        updateAllBtn.disabled = false;
        updateAllBtn.classList.remove('opacity-60','cursor-wait','cursor-not-allowed');
        updateAllBtn.textContent = originalText;
        if (encounteredError) {
          alert('Beim Aktualisieren ist ein Fehler aufgetreten.');
        }
      }
    });
  }

  // Add new tab
  addTabBtn.addEventListener('click', () => {
    const name = prompt('Name für neuen Tab:', 'Neuer Tab');
    if (!name) return;
    createTab(name);
    renderTabs();
    activateTab(tabs.length - 1);
    updateModuleDraggable();
    updateGridDraggable();
    saveLayout();
  });

  // Settings open
  if (settingsBtn) {
    settingsBtn.addEventListener('click', () => {
      openSettings('general');
    });
  }
  if (closeSettingsBtn) {
    closeSettingsBtn.addEventListener('click', () => {
      hideSettingsModal();
    });
  }
  // Settings nav
  settingsNavButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      activateSettingsSection(btn.dataset.section);
    });
  });
  // Live preview for colours
  [
    inputAppBg,
    inputBorderColor,
    inputButtonBg,
    inputButtonText,
    inputTopBarBg,
    inputTabActiveBg,
    inputTabActiveText,
    inputTabInactiveBg,
    inputTabInactiveText,
    inputSidebarBg,
    inputSidebarText,
    inputGridHint,
    inputDangerBg,
    inputDangerText,
    inputSidebarModuleBg,
    inputSidebarModuleText,
    inputSidebarModuleBorder
  ].filter(Boolean).forEach(inp => {
    inp.addEventListener('input', () => {
      readInputsIntoSettings();
      applySettings();
      renderTabs();
      scheduleSettingsSave();
    });
  });
  if (moduleColorLayersContainer) {
    moduleColorLayersContainer.addEventListener('input', handleModuleColorLayerInput);
    moduleColorLayersContainer.addEventListener('change', handleModuleColorLayerInput);
    moduleColorLayersContainer.addEventListener('click', handleModuleColorLayerClick);
  }
  if (addModuleColorLayerBtn) {
    addModuleColorLayerBtn.addEventListener('click', () => {
      const currentCount = typeof appSettings.moduleSubLayerCount === 'number' && appSettings.moduleSubLayerCount > 0
        ? appSettings.moduleSubLayerCount
        : DEFAULT_SUB_LAYER_COUNT;
      if (currentCount >= MAX_MODULE_SUB_LAYERS) {
        updateModuleColorLayerAddState();
        return;
      }
      const nextCount = currentCount + 1;
      appSettings.moduleSubLayerCount = nextCount;
      if (!Array.isArray(appSettings.moduleColorLayers)) {
        appSettings.moduleColorLayers = normalizeModuleColorLayers([], nextCount);
      } else {
        appSettings.moduleColorLayers = normalizeModuleColorLayers(appSettings.moduleColorLayers, nextCount);
      }
      renderModuleColorLayers(appSettings.moduleColorLayers);
      scheduleSettingsSave();
    });
  }
  if (inputShowUpdateButton) {
    inputShowUpdateButton.addEventListener('change', () => {
      appSettings.showUpdateStatusButton = inputShowUpdateButton.checked;
      setUpdateStatusButton();
      scheduleSettingsSave();
    });
  }
  if (inputUpdateAutoPoll) {
    inputUpdateAutoPoll.addEventListener('change', () => {
      appSettings.autoUpdatePolling = inputUpdateAutoPoll.checked;
      updateAutoPollingState({ immediate: inputUpdateAutoPoll.checked });
      scheduleSettingsSave();
    });
  }
  if (inputHideDowngradeButton) {
    inputHideDowngradeButton.addEventListener('change', () => {
      appSettings.hideDowngradeStatusButton = inputHideDowngradeButton.checked;
      setUpdateStatusButton();
      scheduleSettingsSave();
    });
  }
  if (inputAutoArrange) {
    inputAutoArrange.addEventListener('change', () => {
      readInputsIntoSettings();
      applySettings();
      scheduleSettingsSave();
    });
  }
  inputBorderRadius.addEventListener('input', () => {
    appSettings.moduleBorderRadius = ((parseFloat(inputBorderRadius.value)||0)/16) + 'rem';
    applySettings();
    scheduleSettingsSave();
  });

  /* First tab on initial load */
  createTab('Standard');
  renderTabs();
  activateTab(0, { skipSave: true });
  updateModuleDraggable();
  updateGridDraggable();
  updateGridAutoArrange();

  // --- Try to restore AFTER wiring handlers ---
  const restoredRoot = await tryRestoreRootHandle();
  await tryRestoreUpdateHandle();
  if (restoredRoot) {
    updateModuleDraggable();
    updateGridDraggable();
  }
  await runUpdateCheck();
});

/** Populate inputs from appSettings */
function populateInputsFromSettings() {
  setColorInputValue(inputAppBg, appSettings.appBgColor, { silent: true, setBaseline: true });
  setColorInputValue(inputBorderColor, appSettings.borderColor, { silent: true, setBaseline: true });
  setColorInputValue(inputButtonBg, appSettings.buttonBg, { silent: true, setBaseline: true });
  setColorInputValue(inputButtonText, appSettings.buttonText, { silent: true, setBaseline: true });
  setColorInputValue(inputTopBarBg, appSettings.topBarBg, { silent: true, setBaseline: true });
  setColorInputValue(inputTabActiveBg, appSettings.tabActiveBg, { silent: true, setBaseline: true });
  setColorInputValue(inputTabActiveText, appSettings.tabActiveText, { silent: true, setBaseline: true });
  setColorInputValue(inputTabInactiveBg, appSettings.tabInactiveBg, { silent: true, setBaseline: true });
  setColorInputValue(inputTabInactiveText, appSettings.tabInactiveText, { silent: true, setBaseline: true });
  setColorInputValue(inputSidebarBg, appSettings.sidebarBg, { silent: true, setBaseline: true });
  setColorInputValue(inputSidebarText, appSettings.sidebarText, { silent: true, setBaseline: true });
  setColorInputValue(inputGridHint, appSettings.gridHint, { silent: true, setBaseline: true });
  if (inputAutoArrange) inputAutoArrange.checked = !!appSettings.autoArrangeModules;
  inputBorderRadius.value = Math.round(parseFloat(appSettings.moduleBorderRadius) * 16 || 0);
  setColorInputValue(inputDangerBg, appSettings.dangerBg, { silent: true, setBaseline: true });
  setColorInputValue(inputDangerText, appSettings.dangerText, { silent: true, setBaseline: true });

  renderModuleColorLayers(appSettings.moduleColorLayers);

  // Sidebar module card settings
  if (inputSidebarModuleBg) setColorInputValue(inputSidebarModuleBg, appSettings.sidebarModuleCardBg, { silent: true, setBaseline: true });
  if (inputSidebarModuleText) setColorInputValue(inputSidebarModuleText, appSettings.sidebarModuleCardText, { silent: true, setBaseline: true });
  if (inputSidebarModuleBorder) setColorInputValue(inputSidebarModuleBorder, appSettings.sidebarModuleCardBorder, { silent: true, setBaseline: true });
  if (inputShowUpdateButton) inputShowUpdateButton.checked = appSettings.showUpdateStatusButton !== false;
  if (inputUpdateAutoPoll) inputUpdateAutoPoll.checked = !!appSettings.autoUpdatePolling;
  if (inputHideDowngradeButton) inputHideDowngradeButton.checked = !!appSettings.hideDowngradeStatusButton;
}

/** Read inputs into appSettings */
function readInputsIntoSettings() {
  appSettings.appBgColor = getColorInputValue(inputAppBg);
  appSettings.borderColor = getColorInputValue(inputBorderColor);
  appSettings.buttonBg = getColorInputValue(inputButtonBg);
  appSettings.buttonText = getColorInputValue(inputButtonText);
  appSettings.topBarBg = getColorInputValue(inputTopBarBg);
  appSettings.tabActiveBg = getColorInputValue(inputTabActiveBg);
  appSettings.tabActiveText = getColorInputValue(inputTabActiveText);
  appSettings.tabInactiveBg = getColorInputValue(inputTabInactiveBg);
  appSettings.tabInactiveText = getColorInputValue(inputTabInactiveText);
  appSettings.sidebarBg = getColorInputValue(inputSidebarBg);
  appSettings.sidebarText = getColorInputValue(inputSidebarText);
  appSettings.gridHint = getColorInputValue(inputGridHint);
  if (inputAutoArrange) appSettings.autoArrangeModules = inputAutoArrange.checked;
  appSettings.moduleBorderRadius = ((parseFloat(inputBorderRadius.value)||0)/16) + 'rem';
  appSettings.dangerBg = getColorInputValue(inputDangerBg);
  appSettings.dangerText = getColorInputValue(inputDangerText);

  if (moduleColorLayersContainer && moduleColorLayersContainer.children.length) {
    appSettings.moduleColorLayers = collectModuleColorLayersFromDom();
    syncModuleLayerCssVariables();
  }

  // Sidebar module card settings
  appSettings.sidebarModuleCardBg = getColorInputValue(inputSidebarModuleBg);
  appSettings.sidebarModuleCardText = getColorInputValue(inputSidebarModuleText);
  appSettings.sidebarModuleCardBorder = getColorInputValue(inputSidebarModuleBorder);
  if (inputShowUpdateButton) appSettings.showUpdateStatusButton = inputShowUpdateButton.checked;
  if (inputUpdateAutoPoll) appSettings.autoUpdatePolling = inputUpdateAutoPoll.checked;
  if (inputHideDowngradeButton) appSettings.hideDowngradeStatusButton = inputHideDowngradeButton.checked;
}

/** Apply CSS variables from appSettings */
function applySettings() {
  const assignments = {
    '--app-bg': appSettings.appBgColor,
    '--sidebar-bg': appSettings.sidebarBg,
    '--sidebar-text': appSettings.sidebarText,
    '--top-bar-bg': appSettings.topBarBg,
    '--button-bg': appSettings.buttonBg,
    '--button-text': appSettings.buttonText,
    '--border-color': appSettings.borderColor,
    '--module-border-radius': appSettings.moduleBorderRadius,
    '--danger-bg': appSettings.dangerBg,
    '--danger-text': appSettings.dangerText,
    '--tab-active-bg': appSettings.tabActiveBg,
    '--tab-active-text': appSettings.tabActiveText,
    '--tab-inactive-bg': appSettings.tabInactiveBg,
    '--tab-inactive-text': appSettings.tabInactiveText,
    '--grid-hint': appSettings.gridHint,
    '--sidebar-module-card-bg': appSettings.sidebarModuleCardBg,
    '--sidebar-module-card-text': appSettings.sidebarModuleCardText,
    '--sidebar-module-card-border': appSettings.sidebarModuleCardBorder
  };

  const primaryLayer = getPrimaryModuleLayer();
  const moduleBg = primaryLayer?.moduleBg || '#005983';
  const moduleText = primaryLayer?.moduleText || '#ffffff';
  const moduleBorder = primaryLayer?.moduleBorder || moduleText;
  const headerBg = primaryLayer?.headerBg || moduleBg;
  const headerText = primaryLayer?.headerText || moduleText;

  assignments['--module-bg'] = moduleBg;
  assignments['--text-color'] = moduleText;
  assignments['--module-border-color'] = moduleBorder;
  assignments['--module-header-bg'] = headerBg;
  assignments['--module-header-text'] = headerText;

  updateCssVariables(assignments);
  syncModuleLayerCssVariables();

  updateGridAutoArrange();
  setUpdateStatusButton();
}

/** Save settings to storage */
async function saveAppSettings() {
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(settingsFileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(appSettings));
      await writable.close();
    } catch (e) { console.warn('Konnte Einstellungsdatei nicht speichern', e); }
  } else {
    try {
      localStorage.setItem('appSettings', JSON.stringify(appSettings));
    } catch (e) { console.warn('Konnte Einstellungen nicht im localStorage speichern', e); }
  }
}

function applyLoadedSettings(loadedSettings) {
  if (!loadedSettings || typeof loadedSettings !== 'object') return;
  const {
    gridFloat,
    autoArrangeModules,
    moduleBgColor: _moduleBgColor,
    textColor: _textColor,
    moduleHeaderBg: _moduleHeaderBg,
    moduleHeaderText: _moduleHeaderText,
    moduleBorderColor: _moduleBorderColor,
    ...rest
  } = loadedSettings;
  // Legacy module colour values (moduleBgColor, textColor, moduleHeader*, moduleBorderColor) are ignored.
  appSettings = { ...appSettings, ...rest };
  const desiredSubLayerCount = (() => {
    if (typeof rest.moduleSubLayerCount === 'number') {
      return Math.min(Math.max(Math.floor(rest.moduleSubLayerCount), 1), MAX_MODULE_SUB_LAYERS);
    }
    if (Array.isArray(rest.moduleColorLayers) && rest.moduleColorLayers.length) {
      const maxLength = rest.moduleColorLayers.reduce((max, layer) => {
        if (Array.isArray(layer?.subLayers)) {
          return Math.max(max, layer.subLayers.length);
        }
        return max;
      }, DEFAULT_SUB_LAYER_COUNT);
      return Math.min(Math.max(maxLength, 1), MAX_MODULE_SUB_LAYERS);
    }
    return DEFAULT_SUB_LAYER_COUNT;
  })();
  appSettings.moduleSubLayerCount = desiredSubLayerCount;
  appSettings.moduleColorLayers = normalizeModuleColorLayers(appSettings.moduleColorLayers, desiredSubLayerCount);
  if (typeof autoArrangeModules === 'boolean') {
    appSettings.autoArrangeModules = autoArrangeModules;
  } else if (typeof gridFloat === 'boolean') {
    appSettings.autoArrangeModules = !gridFloat;
  }
}

/** Load settings from storage */
async function loadAppSettings() {
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(settingsFileName, { create: false });
      const file = await fileHandle.getFile();
      const text = await file.text();
      const loaded = JSON.parse(text);
      applyLoadedSettings(loaded);
    } catch (e) {}
  } else {
    try {
      const ls = localStorage.getItem('appSettings');
      if (ls) applyLoadedSettings(JSON.parse(ls));
    } catch (e) {}
  }
  applySettings();
  updateAutoPollingState();
}

/** Update card draggability */
function updateModuleDraggable() {
  listEl.querySelectorAll('.module-card[data-subdir]').forEach(card => {
    card.draggable = isSidebarOpen;
    card.style.webkitUserDrag = isSidebarOpen ? 'element' : 'none';
    card.style.cursor = isSidebarOpen ? 'grab' : 'default';
  });
}
function updateGridDraggable() {
  tabs.forEach(tab => {
    if (tab.grid) {
      // grid-wide static mode reflects sidebar state
      tab.grid.setStatic(!isSidebarOpen);
      tab.grid.engine.nodes.forEach(node => {
        tab.grid.movable(node.el, isSidebarOpen);
        tab.grid.resizable(node.el, isSidebarOpen);
        const dragHandle = node.el.querySelector('.drag-handle');
        if (dragHandle) dragHandle.style.cursor = isSidebarOpen ? 'move' : 'default';
        const delBtn = node.el.querySelector('.remove');
        if (delBtn) delBtn.style.display = isSidebarOpen ? '' : 'none';
        const resizeHandles = node.el.querySelectorAll('.ui-resizable-handle');
        resizeHandles.forEach(handle => {
          handle.style.display = isSidebarOpen ? '' : 'none';
          if (!isSidebarOpen) handle.style.cursor = 'default';
        });
      });
    }
  });
}

function updateGridAutoArrange() {
  const autoArrange = !!appSettings.autoArrangeModules;
  const shouldFloat = !autoArrange;
  tabs.forEach(tab => {
    const grid = tab.grid;
    if (!grid) return;
    if (typeof grid.float === 'function') {
      grid.float(shouldFloat);
    } else if (typeof grid.setFloat === 'function') {
      grid.setFloat(shouldFloat);
    } else {
      grid.opts = grid.opts || {};
      grid.opts.float = shouldFloat;
      if (grid.engine && Object.prototype.hasOwnProperty.call(grid.engine, 'float')) {
        grid.engine.float = shouldFloat;
      }
    }
  });
}

/** Load modules via FS API */
async function loadModulesFromRoot(rootHandle) {
  try {
    modulesDirHandle = await rootHandle.getDirectoryHandle('modules', { create: false });
  } catch {
    liveModuleTemplates = [];
    renderSidebar([]);
    alert('Kein "modules" Unterordner im gewählten Root gefunden.');
    return;
  }
  const { tree, modules } = await buildTreeFromHandle(modulesDirHandle);
  liveModuleTemplates = modules;
  renderSidebar(tree);

  // Apply a fade-in animation to grids container when modules load
  if (gridsContainer) {
    gridsContainer.classList.add('fade-in');
    setTimeout(() => gridsContainer.classList.remove('fade-in'), 600);
  }
}

/** Fallback load modules via file list */
async function loadModulesFromFileList(files, rootName) {
  const { tree, modules } = await buildTreeFromFileList(files, rootName);
  liveModuleTemplates = modules;
  renderSidebar(tree);

  // Apply fade-in to grids container when modules load via fallback
  if (gridsContainer) {
    gridsContainer.classList.add('fade-in');
    setTimeout(() => gridsContainer.classList.remove('fade-in'), 600);
  }
}

function filterSidebarTree(tree, filter) {
  if (!Array.isArray(tree)) return [];
  if (!filter) return tree;
  return tree
    .map(node => filterSidebarNode(node, filter))
    .filter(Boolean);
}

function filterSidebarNode(node, filter) {
  if (!node) return null;
  if (!filter) return node;
  if (node.type === 'folder') {
    const filteredChildren = (node.children || [])
      .map(child => filterSidebarNode(child, filter))
      .filter(Boolean);
    if (!filteredChildren.length) return null;
    return { ...node, children: filteredChildren };
  }
  const name = String(node.template?.name || node.subdir || '').toLowerCase();
  return name.includes(filter) ? node : null;
}

/** Render sidebar module cards */
function renderSidebar(tree) {
  if (Array.isArray(tree)) {
    sidebarTreeData = tree;
  } else if (!Array.isArray(sidebarTreeData)) {
    sidebarTreeData = [];
  }
  const sourceTree = Array.isArray(sidebarTreeData) ? sidebarTreeData : [];
  const filter = (sidebarSearchTerm || '').trim().toLowerCase();
  const displayTree = filterSidebarTree(sourceTree, filter);
  listEl.innerHTML = '';
  if (!displayTree.length) {
    listEl.innerHTML = `<div class="text-gray-400">${filter ? 'Keine passenden Module.' : 'Keine Module gefunden.'}</div>`;
    return;
  }
  displayTree.forEach(node => renderSidebarNode(node, listEl));
  updateModuleDraggable();
}

function renderSidebarNode(node, container) {
  if (node.type === 'folder') {
    const header = document.createElement('div');
    header.className = 'module-card rounded p-3 cursor-pointer shadow transition flex items-center';
    const nameSpan = document.createElement('span');
    nameSpan.className = 'font-semibold flex-1';
    nameSpan.textContent = node.name;
    const arrow = document.createElement('span');
    arrow.textContent = '▼';
    header.appendChild(nameSpan);
    header.appendChild(arrow);
    container.appendChild(header);
    const childrenContainer = document.createElement('div');
    childrenContainer.className = 'pl-4 flex flex-col gap-2 mt-2';
    childrenContainer.style.display = 'none';
    container.appendChild(childrenContainer);
    node.children.forEach(child => renderSidebarNode(child, childrenContainer));
    header.addEventListener('click', () => {
      const open = childrenContainer.style.display !== 'none';
      childrenContainer.style.display = open ? 'none' : '';
      arrow.textContent = open ? '▼' : '▲';
    });
  } else {
    const { template, subdir, attachments } = node;
    const card = document.createElement('div');
    card.className = 'module-card rounded p-3 cursor-grab shadow transition flex flex-col';
    card.dataset.subdir = subdir;
    const header = document.createElement('div');
    header.className = 'flex items-center gap-2';
    if (template.icon) {
      const iconSpan = document.createElement('span');
      iconSpan.className = 'text-xl';
      iconSpan.textContent = template.icon;
      header.appendChild(iconSpan);
    }
    const nameSpan = document.createElement('span');
    nameSpan.className = 'font-semibold flex-1';
    nameSpan.textContent = template.name || subdir;
    header.appendChild(nameSpan);
    card.appendChild(header);
    if (attachments?.length) {
      const att = document.createElement('div');
      att.className = 'sidebar-module-attachment mt-1';
      att.textContent = '📎 ' + attachments.join(', ');
      card.appendChild(att);
    }
    card.draggable = isSidebarOpen;
    card.addEventListener('dragstart', e => {
      if (!isSidebarOpen) {
        e.preventDefault(); return;
      }
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', subdir);
      e.dataTransfer.setData('application/x-module-subdir', subdir);
      card.classList.add('dragging');
    });
    card.addEventListener('dragend', () => card.classList.remove('dragging'));
    container.appendChild(card);
  }
}

async function buildTreeFromHandle(dirHandle, basePath = '') {
  const modules = [];
  async function scan(handle, relPath) {
    let moduleJson = null;
    const attachments = [];
    let hasJson = false, hasJs = false;
    const children = [];
    for await (const entry of handle.values()) {
      if (entry.kind === 'file') {
        if (entry.name.endsWith('.json')) {
          hasJson = true;
          const f = await entry.getFile();
          try { moduleJson = JSON.parse(await f.text()); } catch {}
        } else {
          if (entry.name.endsWith('.js')) hasJs = true;
          attachments.push(entry.name);
        }
      } else if (entry.kind === 'directory') {
        const child = await scan(entry, relPath ? `${relPath}/${entry.name}` : entry.name);
        if (child) children.push(child);
      }
    }
    if (hasJson && hasJs && moduleJson) {
      const node = { type: 'module', template: moduleJson, subdir: relPath, attachments, dirHandle: handle };
      modules.push(node);
      return node;
    }
    return { type: 'folder', name: handle.name, children };
  }
  const root = await scan(dirHandle, basePath);
  return { tree: root.children || [], modules };
}

async function buildTreeFromFileList(files, rootName) {
  const root = { name: 'modules', files: [], children: {} };
  for (const f of files) {
    const rel = f.webkitRelativePath.split('/');
    if (rel.length < 3) continue;
    if (rel[0] !== rootName || rel[1] !== 'modules') continue;
    insert(root, rel.slice(2), f);
  }
  const modules = [];
  async function finalize(node, relPath) {
    const hasJson = node.files.some(f => f.name.endsWith('.json'));
    const hasJs = node.files.some(f => f.name.endsWith('.js'));
    let moduleJson = null;
    const attachments = [];
    if (hasJson && hasJs) {
      for (const f of node.files) {
        if (f.name.endsWith('.json')) { try { moduleJson = JSON.parse(await f.text()); } catch {} }
        else attachments.push(f.name);
      }
      const subdir = relPath;
      const modNode = { type: 'module', template: moduleJson, subdir, attachments, fileList: node.files };
      modules.push(modNode);
      return modNode;
    }
    const children = [];
    for (const [name, child] of Object.entries(node.children)) {
      const childNode = await finalize(child, relPath ? `${relPath}/${name}` : name);
      if (childNode) children.push(childNode);
    }
    return { type: 'folder', name: node.name, children };
  }
  function insert(node, parts, file) {
    if (parts.length === 1) {
      node.files.push(file);
    } else {
      const [folder, ...rest] = parts;
      if (!node.children[folder]) node.children[folder] = { name: folder, files: [], children: {} };
      insert(node.children[folder], rest, file);
    }
  }
  const tree = await finalize(root, '');
  return { tree: tree.children || [], modules };
}

/** Reset and recreate tabs using saved layout */
async function loadAndInitTabs() {
  const savedActive = loadActiveTabIndex();
  resetTabs();
  let saved = await loadLayout();
  let migrated = false;

  if (saved && saved.length) {
    for (const tabData of saved) {
      if (!Array.isArray(tabData.modules)) continue;
      for (const mod of tabData.modules) {
        const name = mod.subdir || mod.name;
        const exists = name && liveModuleTemplates.find(t => t.subdir === name);
        if (!exists && name) {
          const base = name.split('/').pop();
          const found = liveModuleTemplates.find(t => t.subdir.split('/').pop() === base);
          if (found) {
            mod.subdir = found.subdir;
            delete mod.name;
            migrated = true;
          }
        }
      }
    }
  }

  // Seed used IDs and counter from saved layout
  usedInstanceIds = new Set();
  nextModuleInstanceId = 1;
  if (saved && saved.length) {
    for (const t of saved) {
      for (const m of (t.modules || [])) {
        if (m.id) {
          usedInstanceIds.add(m.id);
          const num = /^mod-(\d+)$/.exec(m.id)?.[1];
          if (num) nextModuleInstanceId = Math.max(nextModuleInstanceId, Number(num) + 1);
        }
      }
    }
  }

  if (saved && saved.length) {
    for (const tabData of saved) createTab(tabData.name, tabData.modules);
  } else {
    createTab('Standard');
  }
  if (tabs.length) {
    const initialIndex = (typeof savedActive === 'number' && savedActive >= 0 && savedActive < tabs.length)
      ? savedActive
      : 0;
    activateTab(initialIndex);
  }

  if (migrated) saveLayout();

  // ensure initial state reflects current sidebar state
  updateModuleDraggable();
  updateGridDraggable();
  updateGridAutoArrange();
}

/** Create a tab and grid */
function createTab(name, layoutModules = []) {
  const tabIndex = tabs.length;
  const tab = { name: name || ('Tab ' + (tabIndex + 1)), modules: [], grid: null, el: null, readyPromise: null };
  let resolveReady;
  tab.readyPromise = new Promise(resolve => {
    resolveReady = resolve;
  });
  const gridEl = document.createElement('div');
  gridEl.className = 'grid-stack p-4';
  gridEl.style.minHeight = 'calc(100vh - 40px)';
  gridEl.dataset.tabIndex = tabIndex;
  gridsContainer.appendChild(gridEl);

  const gridInstance = GridStack.init({ cellHeight: 30, margin: 5, handle: '.grid-stack-item-content', column: 12, float: !appSettings.autoArrangeModules, minRow: 8 }, gridEl);

  // Reflect current sidebar state immediately (no drag/resize when closed)
  gridInstance.setStatic(!isSidebarOpen);

  tab.grid = gridInstance;
  tab.el = gridEl;
  tabs.push(tab);
  gridInstance.on('change', () => {
    if (isLayoutRecordingSuppressed()) {
      updateModulesPositions(tab, { skipUndo: true, skipSave: true });
    } else {
      updateModulesPositions(tab);
    }
  });

  gridEl.addEventListener('dragover', e => {
    if (!isSidebarOpen) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
    gridEl.classList.add('grid-drop-hint');
  });
  gridEl.addEventListener('dragleave', () => gridEl.classList.remove('grid-drop-hint'));
  gridEl.addEventListener('drop', async e => {
    if (!isSidebarOpen) return;
    e.preventDefault();
    gridEl.classList.remove('grid-drop-hint');
    let subdir = e.dataTransfer.getData('application/x-module-subdir');
    if (!subdir) subdir = e.dataTransfer.getData('text/plain');
    if (!subdir) return;
    const modObj = liveModuleTemplates.find(m => m.subdir === subdir);
    if (!modObj) return;
    const rect = gridEl.getBoundingClientRect();
    const cell = gridInstance.getCellFromPixel({ left: e.clientX - rect.left, top: e.clientY - rect.top });
    const tmpl = modObj.template;
    const w = parseInt(tmpl.w) || 6;
    const h = parseInt(tmpl.h) || 3;
    const pos = { x: cell.x, y: cell.y, w, h };
    // Generate unique instance id for this drop
    const instanceId = generateInstanceId();
    if (tmpl.script) {
      const jsFileName = findScriptFileName(tmpl, modObj);
      if (!jsFileName) { alert('Kein Modul-JS gefunden für: ' + (tmpl.name || modObj.subdir)); return; }
      await loadAndRunModuleScript(jsFileName, tmpl, modObj, pos, gridInstance, tab, instanceId);
    } else if (tmpl.fields) {
      createUniversalModule(tmpl, pos, modObj, gridInstance, tab, instanceId);
    } else {
      createSimpleModule(tmpl.name || modObj.subdir, pos, gridInstance, tab, modObj.subdir, instanceId);
    }
  });

  if (layoutModules && layoutModules.length) {
    beginSuppressLayoutRecording();
    setTimeout(async () => {
      try {
        for (const m of layoutModules) {
          const modObj = liveModuleTemplates.find(t => t.subdir === m.subdir);
          const pos = { x: m.x || 0, y: m.y || 0, w: m.w || 6, h: m.h || 3 };
          // Use stored id if available; otherwise generate a new one
          const instanceId = m.id || generateInstanceId();
          if (modObj && modObj.template) {
            const tmpl = modObj.template;
            let handled = false;
            if (tmpl.script) {
              const jsFileName = findScriptFileName(tmpl, modObj);
              if (jsFileName) {
                await loadAndRunModuleScript(jsFileName, tmpl, modObj, pos, gridInstance, tab, instanceId, { skipUndo: true, skipSave: true });
                handled = true;
              }
            }
            if (!handled && tmpl.fields) {
              createUniversalModule(tmpl, pos, modObj, gridInstance, tab, instanceId, { skipUndo: true, skipSave: true });
              handled = true;
            }
            if (!handled) {
              createSimpleModule(tmpl.name || modObj.subdir, pos, gridInstance, tab, modObj.subdir, instanceId, { skipUndo: true, skipSave: true });
            }
          } else {
            createSimpleModule(m.subdir, pos, gridInstance, tab, m.subdir, instanceId, { skipUndo: true, skipSave: true });
          }
        }
      } finally {
        endSuppressLayoutRecording();
        if (typeof resolveReady === 'function') resolveReady();
      }
    }, 50);
  } else if (typeof resolveReady === 'function') {
    resolveReady();
  }
  return tab;
}

/** Render tabs */
function renderTabs() {
  if (tabsSortable) {
    tabsSortable.destroy();
    tabsSortable = null;
  }
  tabsContainer.innerHTML = '';
  tabs.forEach((tab, idx) => {
    const item = document.createElement('div');
    item.className = 'tab-item flex items-center gap-1 px-3 py-1 rounded cursor-pointer';
    if (idx === activeTabIndex) item.classList.add('tab-active'); else item.classList.add('tab-inactive','hover:opacity-90');
    item.dataset.tabIndex = idx;
    const label = document.createElement('span');
    label.className = 'truncate max-w-xs';
    label.textContent = tab.name;
    item.appendChild(label);
    item.addEventListener('click', () => activateTab(idx));
    item.addEventListener('contextmenu', e => openTabContextMenu(e, idx));
    tabsContainer.appendChild(item);
  });
  tabsSortable = Sortable.create(tabsContainer, {
    animation: 150,
    ghostClass: 'opacity-50',
    onStart: closeTabContextMenu,
    onEnd: handleTabReorder
  });
}

/** Handle tab drag-and-drop reorder */
function handleTabReorder(evt) {
  if (!evt || evt.oldIndex === undefined || evt.newIndex === undefined) return;
  const oldIndex = evt.oldIndex;
  const newIndex = evt.newIndex;
  if (oldIndex === newIndex) {
    activateTab(activeTabIndex);
    return;
  }
  const [movedTab] = tabs.splice(oldIndex, 1);
  tabs.splice(newIndex, 0, movedTab);

  if (activeTabIndex === oldIndex) {
    activeTabIndex = newIndex;
  } else if (oldIndex < activeTabIndex && activeTabIndex <= newIndex) {
    activeTabIndex -= 1;
  } else if (newIndex <= activeTabIndex && activeTabIndex < oldIndex) {
    activeTabIndex += 1;
  }

  updateGridsDomOrder();
  activateTab(activeTabIndex);
  saveLayout();
}

/** Sync grid DOM order with tab array order */
function updateGridsDomOrder() {
  tabs.forEach((tab, idx) => {
    if (tab.el && tab.el.parentNode === gridsContainer) {
      tab.el.dataset.tabIndex = idx;
      gridsContainer.appendChild(tab.el);
    }
  });
}

/** Activate a tab */
function activateTab(idx, options = {}) {
  if (idx < 0 || idx >= tabs.length) return;
  tabs.forEach((tab, i) => { if (tab.el) tab.el.style.display = (i === idx ? '' : 'none'); });
  activeTabIndex = idx;
  renderTabs();
  if (!options.skipSave) saveActiveTabIndex();
}

/** Delete tab */
function deleteTab(idx) {
  if (tabs.length <= 1) { alert('Mindestens ein Tab muss bestehen.'); return; }
  const removed = tabs.splice(idx,1)[0];
  if (removed && removed.el && removed.el.parentNode) removed.el.parentNode.removeChild(removed.el);
  if (activeTabIndex >= idx) activeTabIndex = Math.max(0, activeTabIndex - 1);
  renderTabs();
  activateTab(activeTabIndex);
  saveLayout();
}

/** Rename tab */
function renameTab(idx) {
  const newName = prompt('Neuer Name für den Tab:', tabs[idx].name);
  if (newName) {
    tabs[idx].name = newName;
    renderTabs();
    saveLayout();
  }
}

/** Open context menu for a tab */
function openTabContextMenu(e, idx) {
  e.preventDefault();
  closeTabContextMenu();
  const menu = document.createElement('div');
  menu.className = 'tab-context-menu absolute bg-white border rounded shadow z-50 text-sm';
  menu.style.left = e.pageX + 'px';
  menu.style.top = e.pageY + 'px';

  const renameItem = document.createElement('div');
  renameItem.className = 'px-3 py-1 hover:bg-gray-100 cursor-pointer';
  renameItem.textContent = 'Namen bearbeiten';
  renameItem.addEventListener('click', () => {
    closeTabContextMenu();
    renameTab(idx);
  });
  menu.appendChild(renameItem);

  const deleteItem = document.createElement('div');
  deleteItem.className = 'px-3 py-1 hover:bg-gray-100 cursor-pointer';
  deleteItem.textContent = 'Tab löschen';
  deleteItem.addEventListener('click', () => {
    closeTabContextMenu();
    if (!confirm('Tab wirklich löschen?')) return;
    deleteTab(idx);
  });
  menu.appendChild(deleteItem);

  document.body.appendChild(menu);
  tabContextMenu = menu;
}

function closeTabContextMenu() {
  if (tabContextMenu) {
    tabContextMenu.remove();
    tabContextMenu = null;
  }
}

document.addEventListener('click', () => closeTabContextMenu());

/** Remove all tabs */
function resetTabs() {
  tabs.forEach(tab => { if (tab.el && tab.el.parentNode) tab.el.parentNode.removeChild(tab.el); });
  tabs = [];
  tabsContainer.innerHTML = '';
  activeTabIndex = 0;
  clearActiveTabIndex();
}

/** Update module positions after drag/resizing */
function updateModulesPositions(tabOrIndex, options = {}) {
  const tab = typeof tabOrIndex === 'number' ? tabs[tabOrIndex] : tabOrIndex;
  if (!tab || !tab.grid) return;
  const { skipUndo = false, skipSave = false } = options;

  const nodes = tab.grid.engine.nodes || [];
  const newModules = nodes.map(node => {
    const subdir = node.el.dataset.subdir;
    const type = node.el.dataset.modType;
    let instanceId = node.el.dataset.instanceId;
    if (!instanceId) {
      instanceId = generateInstanceId();
      node.el.dataset.instanceId = instanceId;
    } else {
      usedInstanceIds.add(instanceId);
    }
    return { id: instanceId, subdir, type, x: node.x, y: node.y, w: node.w, h: node.h };
  });

  const prevModulesJson = JSON.stringify(tab.modules || []);
  const newModulesJson = JSON.stringify(newModules);
  const changed = prevModulesJson !== newModulesJson;

  let previousSnapshot = null;
  if (changed && !skipUndo && !isLayoutRecordingSuppressed()) {
    previousSnapshot = captureLayoutSnapshot();
  }

  tab.modules = newModules;

  if (changed && !skipUndo && !isLayoutRecordingSuppressed()) {
    pushUndoState(previousSnapshot);
  }

  if (changed && !skipSave) {
    saveLayout();
  } else if (!skipSave && saveIndicatorPending === 0) {
    setSaveIndicator('saved');
  }

  updateUndoRedoButtons();
}

function setSaveIndicator(state) {
  if (!saveIndicator) return;
  saveIndicator.classList.remove('bg-green-500','bg-yellow-400','bg-red-500');
  let title = '';
  if (state === 'pending') {
    saveIndicator.classList.add('bg-yellow-400');
    title = 'Speichern läuft…';
  } else if (state === 'error') {
    saveIndicator.classList.add('bg-red-500');
    title = 'Speichern fehlgeschlagen';
  } else {
    saveIndicator.classList.add('bg-green-500');
    title = 'Gespeichert';
  }
  saveIndicator.title = title;
}

/** Save layout */
async function saveLayout() {
  saveIndicatorPending++;
  setSaveIndicator('pending');
  const layoutData = { tabs: tabs.map(({name, modules}) => ({ name, modules })) };
  let success = true;
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(layoutFileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(layoutData));
      await writable.close();
    } catch (e) {
      success = false;
      setSaveIndicator('error');
      console.warn('Konnte Layout-Datei nicht speichern', e);
    }
  } else {
    try {
      localStorage.setItem('modulesLayout', JSON.stringify(layoutData));
    } catch (e) {
      success = false;
      setSaveIndicator('error');
      console.warn('Konnte Layout nicht im localStorage speichern', e);
    }
  }
  saveIndicatorPending = Math.max(0, saveIndicatorPending - 1);
  if (success && saveIndicatorPending === 0) {
    setSaveIndicator('saved');
  }
}

/** Load layout */
async function loadLayout() {
  if (rootDirHandle && window.showDirectoryPicker) {
    try {
      const fileHandle = await rootDirHandle.getFileHandle(layoutFileName, { create: false });
      const file = await fileHandle.getFile();
      const text = await file.text();
      const obj = JSON.parse(text);
      if (obj && Array.isArray(obj.tabs)) return obj.tabs;
    } catch (e) {}
  }
  try {
    const ls = localStorage.getItem('modulesLayout');
    if (ls) {
      const obj = JSON.parse(ls);
      if (obj && Array.isArray(obj.tabs)) return obj.tabs;
    }
  } catch (e) {}
  return null;
}

function saveActiveTabIndex() {
  try {
    localStorage.setItem(ACTIVE_TAB_STORAGE_KEY, String(activeTabIndex));
  } catch (e) {}
}

function loadActiveTabIndex() {
  try {
    const stored = localStorage.getItem(ACTIVE_TAB_STORAGE_KEY);
    if (stored === null) return null;
    const parsed = Number.parseInt(stored, 10);
    return Number.isNaN(parsed) ? null : parsed;
  } catch (e) {
    return null;
  }
}

function clearActiveTabIndex() {
  try { localStorage.removeItem(ACTIVE_TAB_STORAGE_KEY); } catch (e) {}
}

/** Determine script filename from module JSON */
function findScriptFileName(moduleJson, modObj) {
  const base = String(moduleJson.script).replace(/^render/, '');
  const candidates = (modObj.attachments || []).filter(n => n.endsWith('.js'));
  let jsFileName = candidates.find(n => n.replace(/\.js$/, '') === base);
  if (!jsFileName) jsFileName = candidates[0];
  return jsFileName;
}

/** Load and run script module */
async function loadAndRunModuleScript(jsFileName, moduleJson, modObj, gridPos, gridInstance, tabRef, instanceIdArg, options = {}) {
  let jsText = '';
  if (modObj.dirHandle) {
    const jsHandle = await modObj.dirHandle.getFileHandle(jsFileName);
    jsText = await (await jsHandle.getFile()).text();
  } else if (modObj.fileList) {
    const f = modObj.fileList.find(f => f.name === jsFileName);
    if (!f) { alert('JS-Datei nicht gefunden (Fallback).'); return; }
    jsText = await f.text();
  } else {
    alert('Keine Quelle für JS-Datei gefunden.');
    return;
  }
  try { eval(jsText); } catch (e) { console.error(e); alert('Fehler im Modul-JS.'); return; }
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  el.innerHTML = `<div class="grid-stack-item-content relative">
  <button class="remove gs-remove px-2 py-1 text-xs rounded">🗑</button>
  <div class="content"></div>
  </div>`;
  el.dataset.subdir = modObj.subdir;
  el.dataset.modType = 'script';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  const pos = gridPos || { x:0, y:0, w: moduleJson.w || 6, h: moduleJson.h || 3 };
  const widgetOptions = {
    ...pos,
    minW: moduleJson.minW || 1,
    minH: moduleJson.minH || 1
  };
  if (Number.isFinite(moduleJson.maxW)) widgetOptions.maxW = moduleJson.maxW;
  if (Number.isFinite(moduleJson.maxH)) widgetOptions.maxH = moduleJson.maxH;
  gridInstance.addWidget(el, widgetOptions);
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabRef);
    updateGridDraggable();
  };
  if (typeof window[moduleJson.script] === 'function') {
    window[moduleJson.script](el.querySelector('.content'), { moduleJson, attachments: modObj.attachments || [], subdir: modObj.subdir });
  } else {
    alert('Exportierte Funktion nicht gefunden: ' + moduleJson.script);
  }
  // Apply fade-in animation to new module content
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabRef, options);
  updateGridDraggable();
}

/** Create universal (fields) module */
function createUniversalModule(mod, pos, modObj, gridInstance, tabRef, instanceIdArg, options = {}) {
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  const defaultW = parseInt(mod.w) || 6;
  const defaultH = parseInt(mod.h) || 3;
  const finalPos = { ...pos };
  if (!pos || typeof pos.w === 'undefined') finalPos.w = defaultW;
  if (!pos || typeof pos.h === 'undefined') finalPos.h = defaultH;
  let html = `<div class="grid-stack-item-content">`;
  html += `<div class="drag-handle"><span class="font-semibold">${mod.name || modObj.subdir}</span><button class="remove px-2 py-1 text-xs rounded">🗑</button></div>`;
  html += `<form class="unimod-form grid grid-cols-2 gap-3">`;
  (mod.fields || []).forEach(field => {
    const colSpan = field.width === 2 ? 'col-span-2' : 'col-span-1';
    html += `<label class="${colSpan} text-sm flex flex-col gap-1"><span class="font-medium">${field.label || field.key}</span>`;
    if (field.type === 'textarea') {
      html += `<textarea name="${field.key}" class="w-full text-black p-1 rounded"></textarea>`;
    } else if (field.type === 'select') {
      html += `<select name="${field.key}" class="w-full text-black p-1 rounded">` + (field.options || []).map(o => `<option>${o}</option>`).join('') + `</select>`;
    } else {
      html += `<input type="${field.type || 'text'}" name="${field.key}" class="w-full text-black p-1 rounded" />`;
    }
    html += `</label>`;
  });
  html += `</form>`;
  if (mod.actions?.length) {
    html += `<div class="mt-2 flex flex-wrap gap-2">` + mod.actions.map((a,i) => `<button type="button" class="action-btn bg-indigo-500 hover:bg-indigo-600 text-white px-3 py-1 rounded text-sm" data-i="${i}">${a.label}</button>`).join('') + `</div>`;
  }
  html += `</div>`;
  el.innerHTML = html;
  el.dataset.subdir = modObj.subdir;
  el.dataset.modType = 'fields';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  const widgetOptions = {
    ...(finalPos || { x:0,y:0,w:defaultW,h:defaultH }),
    minW: mod.minW || 1,
    minH: mod.minH || 1,
    maxW: mod.maxW || finalPos.w,
    maxH: mod.maxH || finalPos.h
  };
  gridInstance.addWidget(el, widgetOptions);
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabRef);
    updateGridDraggable();
  };
  if (mod.actions?.length) {
    el.querySelectorAll('.action-btn').forEach(btn => {
      btn.onclick = () => {
        const i = Number(btn.dataset.i);
        const script = mod.actions[i].script;
        if (!script) return;
        runInlineScript(script, el.querySelector('form'), { modulename: mod.name || modObj.subdir });
      };
    });
  }
  // Apply fade-in animation to new universal module
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabRef, options);
  updateGridDraggable();
}

/** Run script for universal module */
function runInlineScript(script, formEl, context) {
  const fields = {};
  Array.from(formEl.elements).forEach(el => { if (el.name) fields[el.name] = el; });
  const helpers = {
    exportAsCSV: fields => {
      const row = Object.values(fields).map(f => (f && f.value || '')).join(';');
      const blob = new Blob([row], { type:'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (context.modulename || 'modul') + '.csv';
      a.click();
    }
  };
  const fn = new Function('fields','context',...Object.keys(helpers), script);
  try { fn(fields, context, ...Object.values(helpers)); } catch (e) { console.error(e); alert('Script-Fehler.'); }
}

/** Create simple module */
function createSimpleModule(title, pos, gridInstance, tabRef, subdir, instanceIdArg, options = {}) {
  const el = document.createElement('div');
  el.classList.add('grid-stack-item');
  const w = (pos && pos.w) || 4;
  const h = (pos && pos.h) || 2;
  el.innerHTML = `<div class="grid-stack-item-content relative">
  <button class="remove gs-remove px-2 py-1 text-xs rounded">🗑</button>
  <div class="text-sm opacity-80">Kein Script/Fields definiert.</div>
  </div>`;
  el.dataset.subdir = subdir || title;
  el.dataset.modType = 'simple';
  // Assign instance id
  const instanceId = instanceIdArg || generateInstanceId();
  usedInstanceIds.add(instanceId);
  el.dataset.instanceId = instanceId;

  gridInstance.addWidget(el, pos || { x:0, y:0, w, h });
  el.querySelector('.remove').onclick = () => {
    gridInstance.removeWidget(el);
    updateModulesPositions(tabRef);
    updateGridDraggable();
  };
  // Apply fade-in animation to new simple module
  try {
    const contentEl = el.querySelector('.grid-stack-item-content');
    if (contentEl) {
      contentEl.classList.add('fade-in');
      setTimeout(() => contentEl.classList.remove('fade-in'), 600);
    }
  } catch (e) {}
  updateModulesPositions(tabRef, options);
  updateGridDraggable();
}
  </script>
</body>
</html>
